(self.webpackChunkclient=self.webpackChunkclient||[]).push([[96],{6666:function(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3840);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n\nleaflet__WEBPACK_IMPORTED_MODULE_0__.Icon.Default.mergeOptions({\n  // Erase default options, so that they can be overridden by _initializeOptions if not supplied.\n  iconUrl: null,\n  iconRetinaUrl: null,\n  shadowUrl: null,\n  iconSize: null,\n  iconAnchor: null,\n  popupAnchor: null,\n  tooltipAnchor: null,\n  shadowSize: null,\n  // @option classNamePrefix: String = 'leaflet-default-icon-'\n  // Prefix for the classes defined in CSS that contain the Icon options.\n  // See the leaflet-defaulticon-compatibility.css file as a starter.\n  // Expected suffixes are \"icon\", \"shadow\", \"popup\" and \"tooltip\".\n  classNamePrefix: 'leaflet-default-icon-'\n});\nleaflet__WEBPACK_IMPORTED_MODULE_0__.Icon.Default.include({\n  _needsInit: true,\n  // Override to make sure options are retrieved from CSS.\n  _getIconUrl: function (name) {\n    // @option imagePath: String\n    // `Icon.Default` will try to auto-detect the location of\n    // the blue icon images. If you are placing these images in a\n    // non-standard way, set this option to point to the right\n    // path, before any marker is added to a map.\n    // Caution: do not use this option with inline base64 image(s).\n    var imagePath = this.options.imagePath || leaflet__WEBPACK_IMPORTED_MODULE_0__.Icon.Default.imagePath || '';\n    // Deprecated (IconDefault.imagePath), backwards-compatibility only\n\n    if (this._needsInit) {\n      // Modifying imagePath option after _getIconUrl has been called\n      // once in this instance of IconDefault will no longer have any\n      // effect.\n      this._initializeOptions(imagePath);\n    }\n    return imagePath + leaflet__WEBPACK_IMPORTED_MODULE_0__.Icon.prototype._getIconUrl.call(this, name);\n  },\n  // Initialize all necessary options for this instance.\n  _initializeOptions: function (imagePath) {\n    this._setOptions('icon', _detectIconOptions, imagePath);\n    this._setOptions('shadow', _detectIconOptions, imagePath);\n    this._setOptions('popup', _detectDivOverlayOptions);\n    this._setOptions('tooltip', _detectDivOverlayOptions);\n    this._needsInit = false;\n  },\n  // Retrieve values from CSS and assign to this instance options.\n  _setOptions: function (name, detectorFn, imagePath) {\n    var options = this.options,\n      prefix = options.classNamePrefix,\n      optionValues = detectorFn(prefix + name, imagePath);\n    for (var optionName in optionValues) {\n      options[name + optionName] = options[name + optionName] || optionValues[optionName];\n    }\n  }\n});\n\n// Retrieve icon option values from CSS (icon or shadow).\nfunction _detectIconOptions(className, imagePath) {\n  var el = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('div', className, document.body),\n    urlsContainer = _getBkgImageOrCursor(el),\n    urls = _extractUrls(urlsContainer, imagePath),\n    iconX = _getStyleInt(el, 'width'),\n    iconY = _getStyleInt(el, 'height'),\n    anchorNX = _getStyleInt(el, 'margin-left'),\n    anchorNY = _getStyleInt(el, 'margin-top');\n  el.parentNode.removeChild(el);\n  return {\n    Url: urls[0],\n    RetinaUrl: urls[1],\n    Size: [iconX, iconY],\n    Anchor: [-anchorNX, -anchorNY]\n  };\n}\n\n// Retrieve anchor option values from CSS (popup or tooltip).\nfunction _detectDivOverlayOptions(className) {\n  var el = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('div', className, document.body),\n    anchorX = _getStyleInt(el, 'margin-left'),\n    anchorY = _getStyleInt(el, 'margin-top');\n  el.parentNode.removeChild(el);\n  return {\n    Anchor: [anchorX, anchorY]\n  };\n}\n\n// Read the CSS url (could be path or inline base64), may be multiple.\n// First: normal icon\n// Second: Retina icon\nfunction _extractUrls(urlsContainer, imagePath) {\n  var re = /url\\(['\"]?([^\"']*?)['\"]?\\)/gi,\n    // Match anything between url( and ), possibly with single or double quotes.\n    urls = [],\n    m = re.exec(urlsContainer);\n  while (m) {\n    // Keep the entire URL from CSS rule, so that each image can have its own full URL.\n    // Except in the case imagePath is provided: remove the path part (i.e. keep only the file name).\n    urls.push(imagePath ? _stripPath(m[1]) : m[1]);\n    m = re.exec(urlsContainer);\n  }\n  return urls;\n}\n\n// Remove anything before the last slash (/) occurrence (inclusive).\n// Caution: will give unexpected result if url is inline base64 data\n// => do not specify imagePath in that case!\nfunction _stripPath(url) {\n  return url.substr(url.lastIndexOf('/') + 1);\n}\nfunction _getStyleInt(el, style) {\n  return parseInt(_getStyle(el, style), 10);\n}\n\n// Factorize style reading fallback for IE8.\nfunction _getStyle(el, style) {\n  return leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.getStyle(el, style) || leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.getStyle(el, _kebabToCamelCase(style));\n}\n\n// When Firefox high contrast (colours override) option is enabled,\n// \"background-image\" is overridden by the browser as \"none\".\n// In that case, fallback to \"cursor\". But keep \"background-image\"\n// as primary source because IE expects cursor URL as relative to HTML page\n// instead of relative to CSS file.\nfunction _getBkgImageOrCursor(el) {\n  var bkgImage = _getStyle(el, 'background-image');\n  return bkgImage && bkgImage !== 'none' ? bkgImage : _getStyle(el, 'cursor');\n}\n\n// Convert kebab-case CSS property name to camelCase for IE currentStyle.\nfunction _kebabToCamelCase(prop) {\n  return prop.replace(/-(\\w)/g, function (str, w) {\n    return w.toUpperCase();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFQyxDQUFDLEVBQUU7SUFDL0MsT0FBT0EsQ0FBQyxDQUFDQyxXQUFXLENBQUMsQ0FBQztFQUN2QixDQUFDLENBQUM7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9sZWFmbGV0LWRlZmF1bHRpY29uLWNvbXBhdGliaWxpdHkvc3JjL0ljb24uRGVmYXVsdC5jb21wYXRpYmlsaXR5LmpzP2M3YmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgTCBmcm9tICdsZWFmbGV0JztcblxuXG5MLkljb24uRGVmYXVsdC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBFcmFzZSBkZWZhdWx0IG9wdGlvbnMsIHNvIHRoYXQgdGhleSBjYW4gYmUgb3ZlcnJpZGRlbiBieSBfaW5pdGlhbGl6ZU9wdGlvbnMgaWYgbm90IHN1cHBsaWVkLlxuXHRpY29uVXJsOiBudWxsLFxuXHRpY29uUmV0aW5hVXJsOiBudWxsLFxuXHRzaGFkb3dVcmw6IG51bGwsXG5cdGljb25TaXplOiBudWxsLFxuXHRpY29uQW5jaG9yOiBudWxsLFxuXHRwb3B1cEFuY2hvcjogbnVsbCxcblx0dG9vbHRpcEFuY2hvcjogbnVsbCxcblx0c2hhZG93U2l6ZTogbnVsbCxcblxuXHQvLyBAb3B0aW9uIGNsYXNzTmFtZVByZWZpeDogU3RyaW5nID0gJ2xlYWZsZXQtZGVmYXVsdC1pY29uLSdcblx0Ly8gUHJlZml4IGZvciB0aGUgY2xhc3NlcyBkZWZpbmVkIGluIENTUyB0aGF0IGNvbnRhaW4gdGhlIEljb24gb3B0aW9ucy5cblx0Ly8gU2VlIHRoZSBsZWFmbGV0LWRlZmF1bHRpY29uLWNvbXBhdGliaWxpdHkuY3NzIGZpbGUgYXMgYSBzdGFydGVyLlxuXHQvLyBFeHBlY3RlZCBzdWZmaXhlcyBhcmUgXCJpY29uXCIsIFwic2hhZG93XCIsIFwicG9wdXBcIiBhbmQgXCJ0b29sdGlwXCIuXG5cdGNsYXNzTmFtZVByZWZpeDogJ2xlYWZsZXQtZGVmYXVsdC1pY29uLScsXG59KTtcblxuXG5MLkljb24uRGVmYXVsdC5pbmNsdWRlKHtcblxuXHRfbmVlZHNJbml0OiB0cnVlLFxuXG5cdC8vIE92ZXJyaWRlIHRvIG1ha2Ugc3VyZSBvcHRpb25zIGFyZSByZXRyaWV2ZWQgZnJvbSBDU1MuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2Zcblx0XHQvLyB0aGUgYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhXG5cdFx0Ly8gbm9uLXN0YW5kYXJkIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodFxuXHRcdC8vIHBhdGgsIGJlZm9yZSBhbnkgbWFya2VyIGlzIGFkZGVkIHRvIGEgbWFwLlxuXHRcdC8vIENhdXRpb246IGRvIG5vdCB1c2UgdGhpcyBvcHRpb24gd2l0aCBpbmxpbmUgYmFzZTY0IGltYWdlKHMpLlxuXHRcdHZhciBpbWFnZVBhdGggPSB0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCB8fCAnJztcblx0XHQvLyBEZXByZWNhdGVkIChJY29uRGVmYXVsdC5pbWFnZVBhdGgpLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cblx0XHRpZiAodGhpcy5fbmVlZHNJbml0KSB7XG5cdFx0XHQvLyBNb2RpZnlpbmcgaW1hZ2VQYXRoIG9wdGlvbiBhZnRlciBfZ2V0SWNvblVybCBoYXMgYmVlbiBjYWxsZWRcblx0XHRcdC8vIG9uY2UgaW4gdGhpcyBpbnN0YW5jZSBvZiBJY29uRGVmYXVsdCB3aWxsIG5vIGxvbmdlciBoYXZlIGFueVxuXHRcdFx0Ly8gZWZmZWN0LlxuXHRcdFx0dGhpcy5faW5pdGlhbGl6ZU9wdGlvbnMoaW1hZ2VQYXRoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2VQYXRoICsgTC5JY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuXHR9LFxuXG5cdC8vIEluaXRpYWxpemUgYWxsIG5lY2Vzc2FyeSBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuXHRfaW5pdGlhbGl6ZU9wdGlvbnM6IGZ1bmN0aW9uIChpbWFnZVBhdGgpIHtcblx0XHR0aGlzLl9zZXRPcHRpb25zKCdpY29uJywgX2RldGVjdEljb25PcHRpb25zLCBpbWFnZVBhdGgpO1xuXHRcdHRoaXMuX3NldE9wdGlvbnMoJ3NoYWRvdycsIF9kZXRlY3RJY29uT3B0aW9ucywgaW1hZ2VQYXRoKTtcblx0XHR0aGlzLl9zZXRPcHRpb25zKCdwb3B1cCcsIF9kZXRlY3REaXZPdmVybGF5T3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0T3B0aW9ucygndG9vbHRpcCcsIF9kZXRlY3REaXZPdmVybGF5T3B0aW9ucyk7XG5cdFx0dGhpcy5fbmVlZHNJbml0ID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gUmV0cmlldmUgdmFsdWVzIGZyb20gQ1NTIGFuZCBhc3NpZ24gdG8gdGhpcyBpbnN0YW5jZSBvcHRpb25zLlxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24gKG5hbWUsIGRldGVjdG9yRm4sIGltYWdlUGF0aCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdCAgICBwcmVmaXggPSBvcHRpb25zLmNsYXNzTmFtZVByZWZpeCxcblx0XHQgICAgb3B0aW9uVmFsdWVzID0gZGV0ZWN0b3JGbihwcmVmaXggKyBuYW1lLCBpbWFnZVBhdGgpO1xuXG5cdFx0Zm9yICh2YXIgb3B0aW9uTmFtZSBpbiBvcHRpb25WYWx1ZXMpIHtcblx0XHRcdG9wdGlvbnNbbmFtZSArIG9wdGlvbk5hbWVdID0gb3B0aW9uc1tuYW1lICsgb3B0aW9uTmFtZV0gfHwgb3B0aW9uVmFsdWVzW29wdGlvbk5hbWVdO1xuXHRcdH1cblx0fVxuXG59KTtcblxuXG4vLyBSZXRyaWV2ZSBpY29uIG9wdGlvbiB2YWx1ZXMgZnJvbSBDU1MgKGljb24gb3Igc2hhZG93KS5cbmZ1bmN0aW9uIF9kZXRlY3RJY29uT3B0aW9ucyhjbGFzc05hbWUsIGltYWdlUGF0aCkge1xuXHR2YXIgZWwgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAgY2xhc3NOYW1lLCBkb2N1bWVudC5ib2R5KSxcblx0ICAgIHVybHNDb250YWluZXIgPSBfZ2V0QmtnSW1hZ2VPckN1cnNvcihlbCksXG5cdCAgICB1cmxzID0gX2V4dHJhY3RVcmxzKHVybHNDb250YWluZXIsIGltYWdlUGF0aCksXG5cdCAgICBpY29uWCA9IF9nZXRTdHlsZUludChlbCwgJ3dpZHRoJyksXG5cdCAgICBpY29uWSA9IF9nZXRTdHlsZUludChlbCwgJ2hlaWdodCcpLFxuXHQgICAgYW5jaG9yTlggPSBfZ2V0U3R5bGVJbnQoZWwsICdtYXJnaW4tbGVmdCcpLFxuXHQgICAgYW5jaG9yTlkgPSBfZ2V0U3R5bGVJbnQoZWwsICdtYXJnaW4tdG9wJyk7XG5cblx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG5cblx0cmV0dXJuIHtcblx0XHRVcmw6IHVybHNbMF0sXG5cdFx0UmV0aW5hVXJsOiB1cmxzWzFdLFxuXHRcdFNpemU6IFtpY29uWCwgaWNvblldLFxuXHRcdEFuY2hvcjogWy1hbmNob3JOWCwgLWFuY2hvck5ZXVxuXHR9O1xufVxuXG4vLyBSZXRyaWV2ZSBhbmNob3Igb3B0aW9uIHZhbHVlcyBmcm9tIENTUyAocG9wdXAgb3IgdG9vbHRpcCkuXG5mdW5jdGlvbiBfZGV0ZWN0RGl2T3ZlcmxheU9wdGlvbnMoY2xhc3NOYW1lKSB7XG5cdHZhciBlbCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgZG9jdW1lbnQuYm9keSksXG5cdCAgICBhbmNob3JYID0gX2dldFN0eWxlSW50KGVsLCAnbWFyZ2luLWxlZnQnKSxcblx0ICAgIGFuY2hvclkgPSBfZ2V0U3R5bGVJbnQoZWwsICdtYXJnaW4tdG9wJyk7XG5cblx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG5cblx0cmV0dXJuIHtcblx0XHRBbmNob3I6IFthbmNob3JYLCBhbmNob3JZXVxuXHR9O1xufVxuXG4vLyBSZWFkIHRoZSBDU1MgdXJsIChjb3VsZCBiZSBwYXRoIG9yIGlubGluZSBiYXNlNjQpLCBtYXkgYmUgbXVsdGlwbGUuXG4vLyBGaXJzdDogbm9ybWFsIGljb25cbi8vIFNlY29uZDogUmV0aW5hIGljb25cbmZ1bmN0aW9uIF9leHRyYWN0VXJscyh1cmxzQ29udGFpbmVyLCBpbWFnZVBhdGgpIHtcblx0dmFyIHJlID0gL3VybFxcKFsnXCJdPyhbXlwiJ10qPylbJ1wiXT9cXCkvZ2ksIC8vIE1hdGNoIGFueXRoaW5nIGJldHdlZW4gdXJsKCBhbmQgKSwgcG9zc2libHkgd2l0aCBzaW5nbGUgb3IgZG91YmxlIHF1b3Rlcy5cblx0ICAgIHVybHMgPSBbXSxcblx0ICAgIG0gPSByZS5leGVjKHVybHNDb250YWluZXIpO1xuXG5cdHdoaWxlIChtKSB7XG5cdFx0Ly8gS2VlcCB0aGUgZW50aXJlIFVSTCBmcm9tIENTUyBydWxlLCBzbyB0aGF0IGVhY2ggaW1hZ2UgY2FuIGhhdmUgaXRzIG93biBmdWxsIFVSTC5cblx0XHQvLyBFeGNlcHQgaW4gdGhlIGNhc2UgaW1hZ2VQYXRoIGlzIHByb3ZpZGVkOiByZW1vdmUgdGhlIHBhdGggcGFydCAoaS5lLiBrZWVwIG9ubHkgdGhlIGZpbGUgbmFtZSkuXG5cdFx0dXJscy5wdXNoKGltYWdlUGF0aCA/IF9zdHJpcFBhdGgobVsxXSkgOiBtWzFdKTtcblx0XHRtID0gcmUuZXhlYyh1cmxzQ29udGFpbmVyKTtcblx0fVxuXG5cdHJldHVybiB1cmxzO1xufVxuXG4vLyBSZW1vdmUgYW55dGhpbmcgYmVmb3JlIHRoZSBsYXN0IHNsYXNoICgvKSBvY2N1cnJlbmNlIChpbmNsdXNpdmUpLlxuLy8gQ2F1dGlvbjogd2lsbCBnaXZlIHVuZXhwZWN0ZWQgcmVzdWx0IGlmIHVybCBpcyBpbmxpbmUgYmFzZTY0IGRhdGFcbi8vID0+IGRvIG5vdCBzcGVjaWZ5IGltYWdlUGF0aCBpbiB0aGF0IGNhc2UhXG5mdW5jdGlvbiBfc3RyaXBQYXRoKHVybCkge1xuXHRyZXR1cm4gdXJsLnN1YnN0cih1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xufVxuXG5mdW5jdGlvbiBfZ2V0U3R5bGVJbnQoZWwsIHN0eWxlKSB7XG5cdHJldHVybiBwYXJzZUludChfZ2V0U3R5bGUoZWwsIHN0eWxlKSwgMTApO1xufVxuXG4vLyBGYWN0b3JpemUgc3R5bGUgcmVhZGluZyBmYWxsYmFjayBmb3IgSUU4LlxuZnVuY3Rpb24gX2dldFN0eWxlKGVsLCBzdHlsZSkge1xuXHRyZXR1cm4gTC5Eb21VdGlsLmdldFN0eWxlKGVsLCBzdHlsZSkgfHwgTC5Eb21VdGlsLmdldFN0eWxlKGVsLCBfa2ViYWJUb0NhbWVsQ2FzZShzdHlsZSkpO1xufVxuXG4vLyBXaGVuIEZpcmVmb3ggaGlnaCBjb250cmFzdCAoY29sb3VycyBvdmVycmlkZSkgb3B0aW9uIGlzIGVuYWJsZWQsXG4vLyBcImJhY2tncm91bmQtaW1hZ2VcIiBpcyBvdmVycmlkZGVuIGJ5IHRoZSBicm93c2VyIGFzIFwibm9uZVwiLlxuLy8gSW4gdGhhdCBjYXNlLCBmYWxsYmFjayB0byBcImN1cnNvclwiLiBCdXQga2VlcCBcImJhY2tncm91bmQtaW1hZ2VcIlxuLy8gYXMgcHJpbWFyeSBzb3VyY2UgYmVjYXVzZSBJRSBleHBlY3RzIGN1cnNvciBVUkwgYXMgcmVsYXRpdmUgdG8gSFRNTCBwYWdlXG4vLyBpbnN0ZWFkIG9mIHJlbGF0aXZlIHRvIENTUyBmaWxlLlxuZnVuY3Rpb24gX2dldEJrZ0ltYWdlT3JDdXJzb3IoZWwpIHtcblx0dmFyIGJrZ0ltYWdlID0gX2dldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpO1xuXG5cdHJldHVybiBia2dJbWFnZSAmJiBia2dJbWFnZSAhPT0gJ25vbmUnID8gYmtnSW1hZ2UgOiBfZ2V0U3R5bGUoZWwsICdjdXJzb3InKTtcbn1cblxuLy8gQ29udmVydCBrZWJhYi1jYXNlIENTUyBwcm9wZXJ0eSBuYW1lIHRvIGNhbWVsQ2FzZSBmb3IgSUUgY3VycmVudFN0eWxlLlxuZnVuY3Rpb24gX2tlYmFiVG9DYW1lbENhc2UocHJvcCkge1xuXHRyZXR1cm4gcHJvcC5yZXBsYWNlKC8tKFxcdykvZywgZnVuY3Rpb24gKHN0ciwgdykge1xuXHRcdHJldHVybiB3LnRvVXBwZXJDYXNlKCk7XG5cdH0pO1xufVxuIl0sIm5hbWVzIjpbIkwiLCJJY29uIiwiRGVmYXVsdCIsIm1lcmdlT3B0aW9ucyIsImljb25VcmwiLCJpY29uUmV0aW5hVXJsIiwic2hhZG93VXJsIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwicG9wdXBBbmNob3IiLCJ0b29sdGlwQW5jaG9yIiwic2hhZG93U2l6ZSIsImNsYXNzTmFtZVByZWZpeCIsImluY2x1ZGUiLCJfbmVlZHNJbml0IiwiX2dldEljb25VcmwiLCJuYW1lIiwiaW1hZ2VQYXRoIiwib3B0aW9ucyIsIl9pbml0aWFsaXplT3B0aW9ucyIsInByb3RvdHlwZSIsImNhbGwiLCJfc2V0T3B0aW9ucyIsIl9kZXRlY3RJY29uT3B0aW9ucyIsIl9kZXRlY3REaXZPdmVybGF5T3B0aW9ucyIsImRldGVjdG9yRm4iLCJwcmVmaXgiLCJvcHRpb25WYWx1ZXMiLCJvcHRpb25OYW1lIiwiY2xhc3NOYW1lIiwiZWwiLCJEb21VdGlsIiwiY3JlYXRlIiwiZG9jdW1lbnQiLCJib2R5IiwidXJsc0NvbnRhaW5lciIsIl9nZXRCa2dJbWFnZU9yQ3Vyc29yIiwidXJscyIsIl9leHRyYWN0VXJscyIsImljb25YIiwiX2dldFN0eWxlSW50IiwiaWNvblkiLCJhbmNob3JOWCIsImFuY2hvck5ZIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiVXJsIiwiUmV0aW5hVXJsIiwiU2l6ZSIsIkFuY2hvciIsImFuY2hvclgiLCJhbmNob3JZIiwicmUiLCJtIiwiZXhlYyIsInB1c2giLCJfc3RyaXBQYXRoIiwidXJsIiwic3Vic3RyIiwibGFzdEluZGV4T2YiLCJzdHlsZSIsInBhcnNlSW50IiwiX2dldFN0eWxlIiwiZ2V0U3R5bGUiLCJfa2ViYWJUb0NhbWVsQ2FzZSIsImJrZ0ltYWdlIiwicHJvcCIsInJlcGxhY2UiLCJzdHIiLCJ3IiwidG9VcHBlckNhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6666\n")},3840:function(__unused_webpack_module,exports){eval("/* @preserve\n * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n\n(function (global, factory) {\n   true ? factory(exports) : 0;\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.9.4\";\n\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n\n  // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n  function extend(dest) {\n    var i, j, len, src;\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n    return dest;\n  }\n\n  // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n  var create$2 = Object.create || function () {\n    function F() {}\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }();\n\n  // @function bind(fn: Function, …): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  }\n\n  // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n  var lastId = 0;\n\n  // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n  function stamp(obj) {\n    if (!('_leaflet_id' in obj)) {\n      obj['_leaflet_id'] = ++lastId;\n    }\n    return obj._leaflet_id;\n  }\n\n  // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n    later = function () {\n      // reset lock and call if queued\n      lock = false;\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n    wrapperFn = function () {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n    return wrapperFn;\n  }\n\n  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n      min = range[0],\n      d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  }\n\n  // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n  function falseFn() {\n    return false;\n  }\n\n  // @function formatNum(num: Number, precision?: Number|false): Number\n  // Returns the number `num` rounded with specified `precision`.\n  // The default `precision` value is 6 decimal places.\n  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\n  function formatNum(num, precision) {\n    if (precision === false) {\n      return num;\n    }\n    var pow = Math.pow(10, precision === undefined ? 6 : precision);\n    return Math.round(num * pow) / pow;\n  }\n\n  // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  }\n\n  // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n  function setOptions(obj, options) {\n    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\n      obj.options = obj.options ? create$2(obj.options) : {};\n    }\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n    return obj.options;\n  }\n\n  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n  var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\n\n  // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values — they will be evaluated passing `data` as an argument.\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n      return value;\n    });\n  }\n\n  // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\n\n  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n  var lastTime = 0;\n\n  // fallback for IE 7-8\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n      timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  };\n\n  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  }\n\n  // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n  var Util = {\n    __proto__: null,\n    extend: extend,\n    create: create$2,\n    bind: bind,\n    get lastId() {\n      return lastId;\n    },\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  };\n\n  // @class Class\n  // @aka L.Class\n\n  // @section\n  // @uninheritable\n\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function () {\n      setOptions(this);\n\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      }\n\n      // call all constructor hooks\n      this.callInitHooks();\n    };\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create$2(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto;\n\n    // inherit parent's statics\n    for (var i in this) {\n      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    }\n\n    // mix static properties into the class\n    if (props.statics) {\n      extend(NewClass, props.statics);\n    }\n\n    // mix includes into the prototype\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n    }\n\n    // mix given properties into the prototype\n    extend(proto, props);\n    delete proto.statics;\n    delete proto.includes;\n\n    // merge options\n    if (proto.options) {\n      proto.options = parentProto.options ? create$2(parentProto.options) : {};\n      extend(proto.options, props.options);\n    }\n    proto._initHooks = [];\n\n    // add method for calling all hooks\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n      this._initHooksCalled = true;\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n    return NewClass;\n  };\n\n  // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n  Class.include = function (props) {\n    var parentOptions = this.prototype.options;\n    extend(this.prototype, props);\n    if (props.options) {\n      this.prototype.options = parentOptions;\n      this.mergeOptions(props.options);\n    }\n    return this;\n  };\n\n  // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  };\n\n  // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n    this.prototype._initHooks.push(init);\n    return this;\n  };\n  function checkDeprecatedMixinEvents(includes) {\n    /* global L: true */\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n    includes = isArray(includes) ? includes : [includes];\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n      return this;\n    },\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function (types, fn, context) {\n      if (!arguments.length) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (typeof types === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n        var removeAll = arguments.length === 1;\n        for (var i = 0, len = types.length; i < len; i++) {\n          if (removeAll) {\n            this._off(types[i]);\n          } else {\n            this._off(types[i], fn, context);\n          }\n        }\n      }\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function (type, fn, context, _once) {\n      if (typeof fn !== 'function') {\n        console.warn('wrong listener type: ' + typeof fn);\n        return;\n      }\n\n      // check if fn already there\n      if (this._listens(type, fn, context) !== false) {\n        return;\n      }\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n      var newListener = {\n        fn: fn,\n        ctx: context\n      };\n      if (_once) {\n        newListener.once = true;\n      }\n      this._events = this._events || {};\n      this._events[type] = this._events[type] || [];\n      this._events[type].push(newListener);\n    },\n    _off: function (type, fn, context) {\n      var listeners, i, len;\n      if (!this._events) {\n        return;\n      }\n      listeners = this._events[type];\n      if (!listeners) {\n        return;\n      }\n      if (arguments.length === 1) {\n        // remove all\n        if (this._firingCount) {\n          // Set all removed listeners to noop\n          // so they are not called if remove happens in fire\n          for (i = 0, len = listeners.length; i < len; i++) {\n            listeners[i].fn = falseFn;\n          }\n        }\n        // clear all listeners for a type if function isn't specified\n        delete this._events[type];\n        return;\n      }\n      if (typeof fn !== 'function') {\n        console.warn('wrong listener type: ' + typeof fn);\n        return;\n      }\n\n      // find fn and remove it\n      var index = this._listens(type, fn, context);\n      if (index !== false) {\n        var listener = listeners[index];\n        if (this._firingCount) {\n          // set the removed listener to noop so that's not called if remove happens in fire\n          listener.fn = falseFn;\n\n          /* copy array in case events are being fired */\n          this._events[type] = listeners = listeners.slice();\n        }\n        listeners.splice(index, 1);\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide a data\n    // object — the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function (type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n      if (this._events) {\n        var listeners = this._events[type];\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            // off overwrites l.fn, so we need to copy fn to a var\n            var fn = l.fn;\n            if (l.once) {\n              this.off(type, fn, l.ctx);\n            }\n            fn.call(l.ctx || this, event);\n          }\n          this._firingCount--;\n        }\n      }\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n      return this;\n    },\n    // @method listens(type: String, propagate?: Boolean): Boolean\n    // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\n    listens: function (type, fn, context, propagate) {\n      if (typeof type !== 'string') {\n        console.warn('\"string\" type argument expected');\n      }\n\n      // we don't overwrite the input `fn` value, because we need to use it for propagation\n      var _fn = fn;\n      if (typeof fn !== 'function') {\n        propagate = !!fn;\n        _fn = undefined;\n        context = undefined;\n      }\n      var listeners = this._events && this._events[type];\n      if (listeners && listeners.length) {\n        if (this._listens(type, _fn, context) !== false) {\n          return true;\n        }\n      }\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, fn, context, propagate)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    // returns the index (number) or false\n    _listens: function (type, fn, context) {\n      if (!this._events) {\n        return false;\n      }\n      var listeners = this._events[type] || [];\n      if (!fn) {\n        return !!listeners.length;\n      }\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return i;\n        }\n      }\n      return false;\n    },\n    // @method once(…): this\n    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\n    once: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn, true);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context, true);\n        }\n      }\n      return this;\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function (obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function (obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n      return this;\n    },\n    _propagateEvent: function (e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  };\n\n  // aliases; we should ditch those eventually\n\n  // @method addEventListener(…): this\n  // Alias to [`on(…)`](#evented-on)\n  Events.addEventListener = Events.on;\n\n  // @method removeEventListener(…): this\n  // Alias to [`off(…)`](#evented-off)\n\n  // @method clearAllEventListeners(…): this\n  // Alias to [`off()`](#evented-off)\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off;\n\n  // @method addOneTimeEventListener(…): this\n  // Alias to [`once(…)`](#evented-once)\n  Events.addOneTimeEventListener = Events.once;\n\n  // @method fireEvent(…): this\n  // Alias to [`fire(…)`](#evented-fire)\n  Events.fireEvent = Events.fire;\n\n  // @method hasEventListeners(…): Boolean\n  // Alias to [`listens(…)`](#evented-listens)\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x;\n    // @property y: Number; The `y` coordinate of the point\n    this.y = round ? Math.round(y) : y;\n  }\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function () {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function (point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function (point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function (point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function (point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function (num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function (num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function (num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function (num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function (point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function (point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function () {\n      return this.clone()._round();\n    },\n    _round: function () {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function () {\n      return this.clone()._floor();\n    },\n    _floor: function () {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function () {\n      return this.clone()._ceil();\n    },\n    _ceil: function () {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function () {\n      return this.clone()._trunc();\n    },\n    _trunc: function () {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function (point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n        y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function (point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function (point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function () {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  };\n\n  // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n    if (x === undefined || x === null) {\n      return x;\n    }\n    if (typeof x === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n    return new Point(x, y, round);\n  }\n\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n    var points = b ? [a, b] : a;\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n\n    // @alternative\n    // @method extend(otherBounds: Bounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var min2, max2;\n      if (!obj) {\n        return this;\n      }\n      if (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {\n        min2 = max2 = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n        min2 = obj.min;\n        max2 = obj.max;\n        if (!min2 || !max2) {\n          return this;\n        }\n      }\n\n      // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n      if (!this.min && !this.max) {\n        this.min = min2.clone();\n        this.max = max2.clone();\n      } else {\n        this.min.x = Math.min(min2.x, this.min.x);\n        this.max.x = Math.max(max2.x, this.max.x);\n        this.min.y = Math.min(min2.y, this.min.y);\n        this.max.y = Math.max(max2.y, this.max.y);\n      }\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function (round) {\n      return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function () {\n      return toPoint(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function () {\n      // -> Point\n      return toPoint(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function () {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function () {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function () {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      var min, max;\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xIntersects = max2.x >= min.x && min2.x <= max.x,\n        yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xOverlaps = max2.x > min.x && min2.x < max.x,\n        yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this.min && this.max);\n    },\n    // @method pad(bufferRatio: Number): Bounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var min = this.min,\n        max = this.max,\n        heightBuffer = Math.abs(min.x - max.x) * bufferRatio,\n        widthBuffer = Math.abs(min.y - max.y) * bufferRatio;\n      return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));\n    },\n    // @method equals(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle is equivalent to the given bounds.\n    equals: function (bounds) {\n      if (!bounds) {\n        return false;\n      }\n      bounds = toBounds(bounds);\n      return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());\n    }\n  };\n\n  // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n    return new Bounds(a, b);\n  }\n\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var sw = this._southWest,\n        ne = this._northEast,\n        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function () {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function () {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function () {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function () {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function () {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function () {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function () {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function () {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function () {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n        lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n        lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function () {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this._southWest && this._northEast);\n    }\n  };\n\n  // TODO International date line?\n\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n    return new LatLngBounds(a, b);\n  }\n\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    }\n\n    // @property lat: Number\n    // Latitude in degrees\n    this.lat = +lat;\n\n    // @property lng: Number\n    // Longitude in degrees\n    this.lng = +lng;\n\n    // @property alt: Number\n    // Altitude in meters (optional)\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function (precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function (other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function () {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function (sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n        lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function () {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  };\n\n  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n    if (isArray(a) && typeof a[0] !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n      return null;\n    }\n    if (a === undefined || a === null) {\n      return a;\n    }\n    if (typeof a === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n    if (b === undefined) {\n      return null;\n    }\n    return new LatLng(a, b, c);\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function (latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n        scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function (point, zoom) {\n      var scale = this.scale(zoom),\n        untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function (latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function (point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function (zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function (scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function (zoom) {\n      if (this.infinite) {\n        return null;\n      }\n      var b = this.projection.bounds,\n        s = this.scale(zoom),\n        min = this.transformation.transform(b.min, s),\n        max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function (latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n        lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n        alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function (bounds) {\n      var center = bounds.getCenter(),\n        newCenter = this.wrapLatLng(center),\n        latShift = center.lat - newCenter.lat,\n        lngShift = center.lng - newCenter.lng;\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n      var sw = bounds.getSouthWest(),\n        ne = bounds.getNorthEast(),\n        newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n        newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see https://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n        sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n        a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n        c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection — the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function (latlng) {\n      var d = Math.PI / 180,\n        max = this.MAX_LATITUDE,\n        lat = Math.max(Math.min(max, latlng.lat), -max),\n        sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function (point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function (point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function (point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  };\n\n  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  });\n\n  // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n  function pointsToPath(rings, closed) {\n    var str = '',\n      i,\n      j,\n      len,\n      len2,\n      points,\n      p;\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      }\n\n      // closes the ring for polygons; \"x\" is VML syntax\n      str += closed ? Browser.svg ? 'z' : 'x' : '';\n    }\n\n    // SVG complains about empty path strings\n    return str || 'M0 0';\n  }\n\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n  var style = document.documentElement.style;\n\n  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n  var ie = ('ActiveXObject' in window);\n\n  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n  var ielt9 = ie && !document.addEventListener;\n\n  // @property edge: Boolean; `true` for the Edge web browser.\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);\n\n  // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n  var webkit = userAgentContains('webkit');\n\n  // @property android: Boolean\n  // **Deprecated.** `true` for any browser running on an Android platform.\n  var android = userAgentContains('android');\n\n  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);\n\n  // @property opera: Boolean; `true` for the Opera browser\n  var opera = !!window.opera;\n\n  // @property chrome: Boolean; `true` for the Chrome browser.\n  var chrome = !edge && userAgentContains('chrome');\n\n  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;\n\n  // @property safari: Boolean; `true` for the Safari browser.\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom');\n\n  // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n  var opera12 = ('OTransition' in style);\n\n  // @property win: Boolean; `true` when the browser is running in a Windows platform\n  var win = navigator.platform.indexOf('Win') === 0;\n\n  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n  var ie3d = ie && 'transition' in style;\n\n  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;\n\n  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n  var gecko3d = ('MozPerspective' in style);\n\n  // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\n\n  // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');\n\n  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n  var mobileWebkit = mobile && webkit;\n\n  // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n  var mobileWebkit3d = mobile && webkit3d;\n\n  // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n  var msPointer = !window.PointerEvent && window.MSPointerEvent;\n\n  // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n  var pointer = !!(window.PointerEvent || msPointer);\n\n  // @property touchNative: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // **This does not necessarily mean** that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;\n\n  // @property touch: Boolean\n  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\n  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\n  var touch = !window.L_NO_TOUCH && (touchNative || pointer);\n\n  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n  var mobileOpera = mobile && opera;\n\n  // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n  var mobileGecko = mobile && gecko;\n\n  // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;\n\n  // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          // eslint-disable-line getter-return\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {\n      // Errors can safely be ignored since this is only a browser support test.\n    }\n    return supportsPassiveOption;\n  }();\n\n  // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n  var canvas$1 = function () {\n    return !!document.createElement('canvas').getContext;\n  }();\n\n  // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);\n  var inlineSvg = !!svg$1 && function () {\n    var div = document.createElement('div');\n    div.innerHTML = '<svg/>';\n    return (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';\n  }();\n\n  // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n  var vml = !svg$1 && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && typeof shape.adj === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  // @property mac: Boolean; `true` when the browser is running in a Mac platform\n  var mac = navigator.platform.indexOf('Mac') === 0;\n\n  // @property mac: Boolean; `true` when the browser is running in a Linux platform\n  var linux = navigator.platform.indexOf('Linux') === 0;\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n  var Browser = {\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    touchNative: touchNative,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas$1,\n    svg: svg$1,\n    vml: vml,\n    inlineSvg: inlineSvg,\n    mac: mac,\n    linux: linux\n  };\n\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = Browser.msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = Browser.msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = Browser.msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var pEvent = {\n    touchstart: POINTER_DOWN,\n    touchmove: POINTER_MOVE,\n    touchend: POINTER_UP,\n    touchcancel: POINTER_CANCEL\n  };\n  var handle = {\n    touchstart: _onPointerStart,\n    touchmove: _handlePointer,\n    touchend: _handlePointer,\n    touchcancel: _handlePointer\n  };\n  var _pointers = {};\n  var _pointerDocListener = false;\n\n  // Provides a touch events wrapper for (ms)pointer events.\n  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler) {\n    if (type === 'touchstart') {\n      _addPointerDocListener();\n    }\n    if (!handle[type]) {\n      console.warn('wrong event specified:', type);\n      return falseFn;\n    }\n    handler = handle[type].bind(this, handler);\n    obj.addEventListener(pEvent[type], handler, false);\n    return handler;\n  }\n  function removePointerListener(obj, type, handler) {\n    if (!pEvent[type]) {\n      console.warn('wrong event specified:', type);\n      return;\n    }\n    obj.removeEventListener(pEvent[type], handler, false);\n  }\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n  }\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n  }\n  function _addPointerDocListener() {\n    // need to keep track of what pointers and how many are active to provide e.touches emulation\n    if (!_pointerDocListener) {\n      // we listen document as any drags that end by moving the touch off the screen get fired there\n      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n  function _handlePointer(handler, e) {\n    if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {\n      return;\n    }\n    e.touches = [];\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n    e.changedTouches = [e];\n    handler(e);\n  }\n  function _onPointerStart(handler, e) {\n    // IE10 specific: MsTouch needs preventDefault. See #2000\n    if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n      preventDefault(e);\n    }\n    _handlePointer(handler, e);\n  }\n\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */\n\n  function makeDblclick(event) {\n    // in modern browsers `type` cannot be just overridden:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\n    var newEvent = {},\n      prop,\n      i;\n    for (i in event) {\n      prop = event[i];\n      newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\n    }\n    event = newEvent;\n    newEvent.type = 'dblclick';\n    newEvent.detail = 2;\n    newEvent.isTrusted = false;\n    newEvent._simulated = true; // for debug purposes\n    return newEvent;\n  }\n  var delay = 200;\n  function addDoubleTapListener(obj, handler) {\n    // Most browsers handle double tap natively\n    obj.addEventListener('dblclick', handler);\n\n    // On some platforms the browser doesn't fire native dblclicks for touch events.\n    // It seems that in all such cases `detail` property of `click` event is always `1`.\n    // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\n    var last = 0,\n      detail;\n    function simDblclick(e) {\n      if (e.detail !== 1) {\n        detail = e.detail; // keep in sync to avoid false dblclick in some cases\n        return;\n      }\n      if (e.pointerType === 'mouse' || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // When clicking on an <input>, the browser generates a click on its\n      // <label> (and vice versa) triggering two clicks in quick succession.\n      // This ignores clicks on elements which are a label with a 'for'\n      // attribute (or children of such a label), but not children of\n      // a <input>.\n      var path = getPropagationPath(e);\n      if (path.some(function (el) {\n        return el instanceof HTMLLabelElement && el.attributes.for;\n      }) && !path.some(function (el) {\n        return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;\n      })) {\n        return;\n      }\n      var now = Date.now();\n      if (now - last <= delay) {\n        detail++;\n        if (detail === 2) {\n          handler(makeDblclick(e));\n        }\n      } else {\n        detail = 1;\n      }\n      last = now;\n    }\n    obj.addEventListener('click', simDblclick);\n    return {\n      dblclick: handler,\n      simDblclick: simDblclick\n    };\n  }\n  function removeDoubleTapListener(obj, handlers) {\n    obj.removeEventListener('dblclick', handlers.dblclick);\n    obj.removeEventListener('click', handlers.simDblclick);\n  }\n\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\n\n  // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\n\n  // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';\n\n  // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  }\n\n  // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n    return value === 'auto' ? null : value;\n  }\n\n  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n    if (container) {\n      container.appendChild(el);\n    }\n    return el;\n  }\n\n  // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n  function remove(el) {\n    var parent = el.parentNode;\n    if (parent) {\n      parent.removeChild(el);\n    }\n  }\n\n  // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  }\n\n  // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n  function toFront(el) {\n    var parent = el.parentNode;\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  }\n\n  // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n  function toBack(el) {\n    var parent = el.parentNode;\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  }\n\n  // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  }\n\n  // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  }\n\n  // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  }\n\n  // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  }\n\n  // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  }\n\n  // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n  function setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n  function _setOpacityIE(el, value) {\n    var filter = false,\n      filterName = 'DXImageTransform.Microsoft.Alpha';\n\n    // filters collection throws an error if we try to retrieve a filter that doesn't exist\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n    value = Math.round(value * 100);\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  }\n\n  // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n  function testProp(props) {\n    var style = document.documentElement.style;\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n    return false;\n  }\n\n  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  }\n\n  // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (Browser.any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  }\n\n  // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n\n    return el._leaflet_pos || new Point(0, 0);\n  }\n\n  // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n  var disableTextSelection;\n  var enableTextSelection;\n  var _userSelect;\n  if ('onselectstart' in document) {\n    disableTextSelection = function () {\n      on(window, 'selectstart', preventDefault);\n    };\n    enableTextSelection = function () {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n    disableTextSelection = function () {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n    enableTextSelection = function () {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  }\n\n  // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  }\n\n  // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n  var _outlineElement, _outlineStyle;\n  // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n    if (!element.style) {\n      return;\n    }\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outlineStyle;\n    element.style.outlineStyle = 'none';\n    on(window, 'keydown', restoreOutline);\n  }\n\n  // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n    _outlineElement.style.outlineStyle = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  }\n\n  // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n    return element;\n  }\n\n  // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n  var DomUtil = {\n    __proto__: null,\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    get disableTextSelection() {\n      return disableTextSelection;\n    },\n    get enableTextSelection() {\n      return enableTextSelection;\n    },\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  };\n\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n  function on(obj, types, fn, context) {\n    if (types && typeof types === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n    return this;\n  }\n  var eventsKey = '_leaflet_events';\n\n  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  // @alternative\n  // @function off(el: HTMLElement, types: String): this\n  // Removes all previously added listeners of given types.\n\n  // @alternative\n  // @function off(el: HTMLElement): this\n  // Removes all previously added listeners from given HTMLElement\n  function off(obj, types, fn, context) {\n    if (arguments.length === 1) {\n      batchRemove(obj);\n      delete obj[eventsKey];\n    } else if (types && typeof types === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n      if (arguments.length === 2) {\n        batchRemove(obj, function (type) {\n          return indexOf(types, type) !== -1;\n        });\n      } else {\n        for (var i = 0, len = types.length; i < len; i++) {\n          removeOne(obj, types[i], fn, context);\n        }\n      }\n    }\n    return this;\n  }\n  function batchRemove(obj, filterFn) {\n    for (var id in obj[eventsKey]) {\n      var type = id.split(/\\d/)[0];\n      if (!filterFn || filterFn(type)) {\n        removeOne(obj, type, null, null, id);\n      }\n    }\n  }\n  var mouseSubst = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout',\n    wheel: !('onwheel' in window) && 'mousewheel'\n  };\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n    var handler = function (e) {\n      return fn.call(context || obj, e || window.event);\n    };\n    var originalHandler = handler;\n    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      handler = addPointerListener(obj, type, handler);\n    } else if (Browser.touch && type === 'dblclick') {\n      handler = addDoubleTapListener(obj, handler);\n    } else if ('addEventListener' in obj) {\n      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {\n        obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function (e) {\n          e = e || window.event;\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n        obj.addEventListener(mouseSubst[type], handler, false);\n      } else {\n        obj.addEventListener(type, originalHandler, false);\n      }\n    } else {\n      obj.attachEvent('on' + type, handler);\n    }\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n  function removeOne(obj, type, fn, context, id) {\n    id = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');\n    var handler = obj[eventsKey] && obj[eventsKey][id];\n    if (!handler) {\n      return this;\n    }\n    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, handler);\n    } else if (Browser.touch && type === 'dblclick') {\n      removeDoubleTapListener(obj, handler);\n    } else if ('removeEventListener' in obj) {\n      obj.removeEventListener(mouseSubst[type] || type, handler, false);\n    } else {\n      obj.detachEvent('on' + type, handler);\n    }\n    obj[eventsKey][id] = null;\n  }\n\n  // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n    return this;\n  }\n\n  // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\n  function disableScrollPropagation(el) {\n    addOne(el, 'wheel', stopPropagation);\n    return this;\n  }\n\n  // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);\n    el['_leaflet_disable_click'] = true;\n    return this;\n  }\n\n  // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n    return this;\n  }\n\n  // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  }\n\n  // @function getPropagationPath(ev: DOMEvent): Array\n  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).\n  // Returns an array containing the `HTMLElement`s that the given DOM event\n  // should propagate to (if not stopped).\n  function getPropagationPath(ev) {\n    if (ev.composedPath) {\n      return ev.composedPath();\n    }\n    var path = [];\n    var el = ev.target;\n    while (el) {\n      path.push(el);\n      el = el.parentNode;\n    }\n    return path;\n  }\n\n  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n    var scale = getScale(container),\n      offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point(\n    // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  }\n\n  //  except , Safari and\n  // We need double the scroll pixels (see #7403 and #4538) for all Browsers\n  // except OSX (Mac) -> 3x, Chrome running on Linux 1x\n\n  var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;\n  // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a wheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n  function getWheelDelta(e) {\n    return Browser.edge ? e.wheelDeltaY / 2 :\n    // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor :\n    // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 :\n    // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 :\n    // Pages\n    e.deltaX || e.deltaZ ? 0 :\n    // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 :\n    // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 :\n    // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 :\n    // Legacy Moz pages\n    0;\n  }\n\n  // check if element really left/entered the event target (for mouseenter/mouseleave)\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n    if (!related) {\n      return true;\n    }\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n    return related !== el;\n  }\n  var DomEvent = {\n    __proto__: null,\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getPropagationPath: getPropagationPath,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  };\n\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);\n   *\n   * myPositionMarker.on(\"click\", function() {\n   * \tvar pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());\n   * \tpos.y -= 25;\n   * \tvar fx = new L.PosAnimation();\n   *\n   * \tfx.once('end',function() {\n   * \t\tpos.y += 25;\n   * \t\tfx.run(myPositionMarker._icon, pos, 0.8);\n   * \t});\n   *\n   * \tfx.run(myPositionMarker._icon, pos, 0.3);\n   * });\n   *\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function (el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date();\n\n      // @event start: Event\n      // Fired when the animation starts\n      this.fire('start');\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function () {\n      if (!this._inProgress) {\n        return;\n      }\n      this._step(true);\n      this._complete();\n    },\n    _animate: function () {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n      this._step();\n    },\n    _step: function (round) {\n      var elapsed = +new Date() - this._startTime,\n        duration = this._duration * 1000;\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n        this._complete();\n      }\n    },\n    _runFrame: function (progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n      if (round) {\n        pos._round();\n      }\n      setPosition(this._el, pos);\n\n      // @event step: Event\n      // Fired continuously during the animation.\n      this.fire('step');\n    },\n    _complete: function () {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false;\n      // @event end: Event\n      // Fired when the animation ends.\n      this.fire('end');\n    },\n    _easeOut: function (t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API — it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function (id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options);\n\n      // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n      this._initContainer(id);\n      this._initLayout();\n\n      // hack for https://github.com/Leaflet/Leaflet/issues/1980\n      this._onResize = bind(this._onResize, this);\n      this._initEvents();\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n      this.callInitHooks();\n\n      // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n      this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;\n\n      // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function (center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n      this._stop();\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        }\n\n        // try animating pan or zoom\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      }\n\n      // animation didn't start, just reset the map view\n      this._resetView(center, zoom, options.pan && options.pan.noMoveStart);\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function (zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function (delta, options) {\n      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function (delta, options) {\n      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function (latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n        viewHalf = this.getSize().divideBy(2),\n        containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function (bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n        swPoint = this.project(bounds.getSouthWest(), zoom),\n        nePoint = this.project(bounds.getNorthEast(), zoom),\n        center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function (bounds, options) {\n      bounds = toLatLngBounds(bounds);\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n      var target = this._getBoundsCenterZoom(bounds, options);\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function (options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function (center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function (offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      }\n      // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n        return this;\n      }\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      }\n\n      // don't fire movestart if animating inertia\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      }\n\n      // animate pan unless animate: false specified\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n        var newPos = this._getMapPanePos().subtract(offset).round();\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n        this.fire('move').fire('moveend');\n      }\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function (targetCenter, targetZoom, options) {\n      options = options || {};\n      if (options.animate === false || !Browser.any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n      this._stop();\n      var from = this.project(this.getCenter()),\n        to = this.project(targetCenter),\n        size = this.getSize(),\n        startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n        w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n        u1 = to.distanceTo(from) || 1,\n        rho = 1.42,\n        rho2 = rho * rho;\n      function r(i) {\n        var s1 = i ? -1 : 1,\n          s2 = i ? w1 : w0,\n          t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n          b1 = 2 * s2 * rho2 * u1,\n          b = t1 / b1,\n          sq = Math.sqrt(b * b + 1) - b;\n\n        // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n      var r0 = r(0);\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n      var start = Date.now(),\n        S = (r(1) - r0) / rho,\n        duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n      function frame() {\n        var t = (Date.now() - start) / duration,\n          s = easeOut(t) * S;\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n      this._moveStart(true, options.noMoveStart);\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function (bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: LatLngBounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      if (this.listens('moveend', this._panInsideMaxBounds)) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this;\n      }\n      this.options.maxBounds = bounds;\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function (zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function (zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function (bounds, options) {\n      this._enforcingBounds = true;\n      var center = this.getCenter(),\n        newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: padding options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // padding options to fit the display to more restricted bounds.\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function (latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n        pixelCenter = this.project(this.getCenter()),\n        pixelPoint = this.project(latlng),\n        pixelBounds = this.getPixelBounds(),\n        paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\n        paddedSize = paddedBounds.getSize();\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n        var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n        pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n        pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n        this.panTo(this.unproject(pixelCenter), options);\n        this._enforcingBounds = false;\n      }\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function (options) {\n      if (!this._loaded) {\n        return this;\n      }\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n        oldCenter = oldSize.divideBy(2).round(),\n        newCenter = newSize.divideBy(2).round(),\n        offset = oldCenter.subtract(newCenter);\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n        this.fire('move');\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      }\n\n      // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function () {\n      this.setZoom(this._limitZoom(this._zoom));\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function (options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false\n        // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n      }, options);\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n        return this;\n      }\n      var onResponse = bind(this._handleGeolocationResponse, this),\n        onError = bind(this._handleGeolocationError, this);\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function () {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n      return this;\n    },\n    _handleGeolocationError: function (error) {\n      if (!this._container._leaflet_id) {\n        return;\n      }\n      var c = error.code,\n        message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      }\n\n      // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function (pos) {\n      if (!this._container._leaflet_id) {\n        return;\n      }\n      var lat = pos.coords.latitude,\n        lng = pos.coords.longitude,\n        latlng = new LatLng(lat, lng),\n        bounds = latlng.toBounds(pos.coords.accuracy * 2),\n        options = this._locateOptions;\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      }\n\n      // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function (name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n      var handler = this[name] = new HandlerClass(this);\n      this._handlers.push(handler);\n      if (this.options[name]) {\n        handler.enable();\n      }\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function () {\n      this._initEvents(true);\n      if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n        this._containerId = undefined;\n      }\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n      this._stop();\n      remove(this._mapPane);\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n      this._clearHandlers();\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n      var i;\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n      for (i in this._panes) {\n        remove(this._panes[i]);\n      }\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function (name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n        pane = create$1('div', className, container || this._mapPane);\n      if (name) {\n        this._panes[name] = pane;\n      }\n      return pane;\n    },\n    // @section Methods for Getting Map State\n\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function () {\n      this._checkIfLoaded();\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter.clone();\n      }\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function () {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function () {\n      var bounds = this.getPixelBounds(),\n        sw = this.unproject(bounds.getBottomLeft()),\n        ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function () {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function () {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function (bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n        min = this.getMinZoom(),\n        max = this.getMaxZoom(),\n        nw = bounds.getNorthWest(),\n        se = bounds.getSouthEast(),\n        size = this.getSize().subtract(padding),\n        boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n        snap = Browser.any3d ? this.options.zoomSnap : 1,\n        scalex = size.x / boundsSize.x,\n        scaley = size.y / boundsSize.y,\n        scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function () {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function (center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function () {\n      this._checkIfLoaded();\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function (zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function (pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function () {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function () {\n      return this._container;\n    },\n    // @section Conversion Methods\n\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function (toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function (scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function (latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function (point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function (point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function (latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function (latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function (latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function (latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function (point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function (point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function (point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function (latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function (e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function (e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function (e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n\n    _initContainer: function (id) {\n      var container = this._container = get(id);\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function () {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\n      addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {\n        container.style.position = 'relative';\n      }\n      this._initPanes();\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function () {\n      var panes = this._panes = {};\n      this._paneRenderers = {};\n\n      // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0));\n\n      // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n      this.createPane('tilePane');\n      // @pane overlayPane: HTMLElement = 400\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n      this.createPane('overlayPane');\n      // @pane shadowPane: HTMLElement = 500\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n      this.createPane('shadowPane');\n      // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n      this.createPane('markerPane');\n      // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n      this.createPane('tooltipPane');\n      // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n      this.createPane('popupPane');\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n\n    // @section Map state change events\n    _resetView: function (center, zoom, noMoveStart) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n      this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);\n\n      // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n      this.fire('viewreset');\n\n      // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function (zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n      return this;\n    },\n    _move: function (center, zoom, data, supressEvent) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center);\n      if (!supressEvent) {\n        // @event zoom: Event\n        // Fired repeatedly during any change in zoom level,\n        // including zoom and fly animations.\n        if (zoomChanged || data && data.pinch) {\n          // Always fire 'zoom' if pinching because #3530\n          this.fire('zoom', data);\n        }\n\n        // @event move: Event\n        // Fired repeatedly during any movement of the map,\n        // including pan and fly animations.\n        this.fire('move', data);\n      } else if (data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      }\n      return this;\n    },\n    _moveEnd: function (zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map zoom changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      }\n\n      // @event moveend: Event\n      // Fired when the center of the map stops changing\n      // (e.g. user stopped dragging the map or after non-centered zoom).\n      return this.fire('moveend');\n    },\n    _stop: function () {\n      cancelAnimFrame(this._flyToFrame);\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n      return this;\n    },\n    _rawPanBy: function (offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function () {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function () {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function () {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n\n    // @section Interaction events\n    _initEvents: function (remove) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove ? off : on;\n\n      // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n      if (Browser.any3d && this.options.transform3DLimit) {\n        (remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function () {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function () {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function () {\n      var pos = this._getMapPanePos();\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function (e, type) {\n      var targets = [],\n        target,\n        isHover = type === 'mouseout' || type === 'mouseover',\n        src = e.target || e.srcElement,\n        dragging = false;\n      while (src) {\n        target = this._targets[stamp(src)];\n        if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n          targets.push(target);\n          if (isHover) {\n            break;\n          }\n        }\n        if (src === this._container) {\n          break;\n        }\n        src = src.parentNode;\n      }\n      if (!targets.length && !dragging && !isHover && this.listens(type, true)) {\n        targets = [this];\n      }\n      return targets;\n    },\n    _isClickDisabled: function (el) {\n      while (el && el !== this._container) {\n        if (el['_leaflet_disable_click']) {\n          return true;\n        }\n        el = el.parentNode;\n      }\n    },\n    _handleDOMEvent: function (e) {\n      var el = e.target || e.srcElement;\n      if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\n        return;\n      }\n      var type = e.type;\n      if (type === 'mousedown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(el);\n      }\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function (e, type, canvasTargets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n        this._fireDOMEvent(synth, synth.type, canvasTargets);\n      }\n\n      // Find the layer the event is propagating from and its parents.\n      var targets = this._findEventTargets(e, type);\n      if (canvasTargets) {\n        var filtered = []; // pick only targets with listeners\n        for (var i = 0; i < canvasTargets.length; i++) {\n          if (canvasTargets[i].listens(type, true)) {\n            filtered.push(canvasTargets[i]);\n          }\n        }\n        targets = filtered.concat(targets);\n      }\n      if (!targets.length) {\n        return;\n      }\n      if (type === 'contextmenu') {\n        preventDefault(e);\n      }\n      var target = targets[0];\n      var data = {\n        originalEvent: e\n      };\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n      for (i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function (obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function () {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function (callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n      return this;\n    },\n    // private methods for getting map state\n\n    _getMapPanePos: function () {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function () {\n      var pos = this._getMapPanePos();\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function (center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function (center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function (latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function () {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function (latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function (center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n      var centerPoint = this.project(center, zoom),\n        viewHalf = this.getSize().divideBy(2),\n        viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n        offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n\n      // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n      if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n        return center;\n      }\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function (offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n      var viewBounds = this.getPixelBounds(),\n        newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n        minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n        maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n        dx = this._rebound(minOffset.x, -maxOffset.x),\n        dy = this._rebound(minOffset.y, -maxOffset.y);\n      return new Point(dx, dy);\n    },\n    _rebound: function (left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function (zoom) {\n      var min = this.getMinZoom(),\n        max = this.getMaxZoom(),\n        snap = Browser.any3d ? this.options.zoomSnap : 1;\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function () {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function () {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function (center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc();\n\n      // don't animate too far unless animate: true specified in options\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function () {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n      this._panes.mapPane.appendChild(proxy);\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n          transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n\n        // workaround for case when transform is the same and so transitionend event is not fired\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function () {\n      remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function () {\n      var c = this.getCenter(),\n        z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function (e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function () {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function (center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n      options = options || {};\n\n      // don't animate if disabled, not supported or zoom difference is too large\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      }\n\n      // offset is the pixel coords of the zoom origin relative to the current center\n      var scale = this.getZoomScale(zoom),\n        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n\n      // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      requestAnimFrame(function () {\n        this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function (center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n      if (startAnim) {\n        this._animatingZoom = true;\n\n        // remember what center/zoom to set after animation\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      });\n      if (!this._tempFireZoomEvent) {\n        this._tempFireZoomEvent = this._zoom !== this._animateToZoom;\n      }\n      this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n\n      // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function () {\n      if (!this._animatingZoom) {\n        return;\n      }\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n      this._animatingZoom = false;\n      this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n      if (this._tempFireZoomEvent) {\n        this.fire('zoom');\n      }\n      delete this._tempFireZoomEvent;\n      this.fire('move');\n      this._moveEnd(true);\n    }\n  });\n\n  // @section\n\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control Options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function () {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function (position) {\n      var map = this._map;\n      if (map) {\n        map.removeControl(this);\n      }\n      this.options.position = position;\n      if (map) {\n        map.addControl(this);\n      }\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function (map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n        pos = this.getPosition(),\n        corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n      this._map.on('unload', this.remove, this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function () {\n      if (!this._map) {\n        return this;\n      }\n      remove(this._container);\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n      this._map.off('unload', this.remove, this);\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function (e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n  var control = function (options) {\n    return new Control(options);\n  };\n\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function (control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function (control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function () {\n      var corners = this._controlCorners = {},\n        l = 'leaflet-',\n        container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function () {\n      for (var i in this._controlCorners) {\n        remove(this._controlCorners[i]);\n      }\n      remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function (layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function (baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n      this._preventClick = false;\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function (map) {\n      this._initLayout();\n      this._update();\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n      return this._container;\n    },\n    addTo: function (map) {\n      Control.prototype.addTo.call(this, map);\n      // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function () {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function (layer, name) {\n      this._addLayer(layer, name);\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function (layer, name) {\n      this._addLayer(layer, name, true);\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function (layer) {\n      layer.off('add remove', this._onLayerChange, this);\n      var obj = this._getLayer(stamp(layer));\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function () {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n      this._checkDisabledLayers();\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function () {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function () {\n      var className = 'leaflet-control-layers',\n        container = this._container = create$1('div', className),\n        collapsed = this.options.collapsed;\n\n      // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n        on(container, {\n          mouseenter: this._expandSafely,\n          mouseleave: this.collapse\n        }, this);\n      }\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n      link.setAttribute('role', 'button');\n      on(link, {\n        keydown: function (e) {\n          if (e.keyCode === 13) {\n            this._expandSafely();\n          }\n        },\n        // Certain screen readers intercept the key event and instead send a click event\n        click: function (e) {\n          preventDefault(e);\n          this._expandSafely();\n        }\n      }, this);\n      if (!collapsed) {\n        this.expand();\n      }\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function (id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function (layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n      this._expandIfNotCollapsed();\n    },\n    _update: function () {\n      if (!this._container) {\n        return this;\n      }\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n        overlaysPresent,\n        i,\n        obj,\n        baseLayersCount = 0;\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n        this._addItem(obj);\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      }\n\n      // Hide base layers section if there's only one layer.\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function (e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n      var obj = this._getLayer(stamp(e.target));\n\n      // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layers control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layers control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layers control](#control-layers).\n      // @namespace Control.Layers\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\n    _createRadioElement: function (name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function (obj) {\n      var label = document.createElement('label'),\n        checked = this._map.hasLayer(obj.layer),\n        input;\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n      this._layerControlInputs.push(input);\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name;\n\n      // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n      var holder = document.createElement('span');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n      this._checkDisabledLayers();\n      return label;\n    },\n    _onInputClick: function () {\n      // expanding the control on mobile with a click can cause adding a layer - we don't want this\n      if (this._preventClick) {\n        return;\n      }\n      var inputs = this._layerControlInputs,\n        input,\n        layer;\n      var addedLayers = [],\n        removedLayers = [];\n      this._handlingClick = true;\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      }\n\n      // Bugfix issue 2318: Should remove all old layers before readding new ones\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n      this._handlingClick = false;\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function () {\n      var inputs = this._layerControlInputs,\n        input,\n        layer,\n        zoom = this._map.getZoom();\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function () {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n      return this;\n    },\n    _expandSafely: function () {\n      var section = this._section;\n      this._preventClick = true;\n      on(section, 'click', preventDefault);\n      this.expand();\n      var that = this;\n      setTimeout(function () {\n        off(section, 'click', preventDefault);\n        that._preventClick = false;\n      });\n    }\n  });\n\n  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n  var layers = function (baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\n      // The text set on the 'zoom in' button.\n      zoomInText: '<span aria-hidden=\"true\">+</span>',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function (map) {\n      var zoomName = 'leaflet-control-zoom',\n        container = create$1('div', zoomName + ' leaflet-bar'),\n        options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n      this._updateDisabled();\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function () {\n      this._disabled = true;\n      this._updateDisabled();\n      return this;\n    },\n    enable: function () {\n      this._disabled = false;\n      this._updateDisabled();\n      return this;\n    },\n    _zoomIn: function (e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function (e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function (html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function () {\n      var map = this._map,\n        className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n      this._zoomInButton.setAttribute('aria-disabled', 'false');\n      this._zoomOutButton.setAttribute('aria-disabled', 'false');\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n        this._zoomOutButton.setAttribute('aria-disabled', 'true');\n      }\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n        this._zoomInButton.setAttribute('aria-disabled', 'true');\n      }\n    }\n  });\n\n  // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  });\n\n  // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n  var zoom = function (options) {\n    return new Zoom(options);\n  };\n\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true\n\n      // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n    },\n    onAdd: function (map) {\n      var className = 'leaflet-control-scale',\n        container = create$1('div', className),\n        options = this.options;\n      this._addScales(options, className + '-line', container);\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function (options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function () {\n      var map = this._map,\n        y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function (maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function (maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n        label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function (maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n        maxMiles,\n        miles,\n        feet;\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function (scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function (num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n        d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  });\n\n  // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n  var scale = function (options) {\n    return new Scale(options);\n  };\n  var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\n\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String|false = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function (map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container);\n\n      // TODO ugly, refactor\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n      this._update();\n      map.on('layeradd', this._addAttribution, this);\n      return this._container;\n    },\n    onRemove: function (map) {\n      map.off('layeradd', this._addAttribution, this);\n    },\n    _addAttribution: function (ev) {\n      if (ev.layer.getAttribution) {\n        this.addAttribution(ev.layer.getAttribution());\n        ev.layer.once('remove', function () {\n          this.removeAttribution(ev.layer.getAttribution());\n        }, this);\n      }\n    },\n    // @method setPrefix(prefix: String|false): this\n    // The HTML text shown before the attributions. Pass `false` to disable.\n    setPrefix: function (prefix) {\n      this.options.prefix = prefix;\n      this._update();\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).\n    addAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n      this._attributions[text]++;\n      this._update();\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n        this._update();\n      }\n      return this;\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n      var attribs = [];\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n      var prefixAndAttribs = [];\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n      this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\n    }\n  });\n\n  // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  });\n\n  // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n  var attribution = function (options) {\n    return new Attribution(options);\n  };\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function (map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function () {\n      if (this._enabled) {\n        return this;\n      }\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function () {\n      if (!this._enabled) {\n        return this;\n      }\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function () {\n      return !!this._enabled;\n    }\n\n    // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n  });\n\n  // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n  var Mixin = {\n    Events: Events\n  };\n\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function (element, dragStartTarget, preventOutline, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function () {\n      if (this._enabled) {\n        return;\n      }\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function () {\n      if (!this._enabled) {\n        return;\n      }\n\n      // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n      if (Draggable._dragging === this) {\n        this.finishDrag(true);\n      }\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function (e) {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      this._moved = false;\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n      if (e.touches && e.touches.length !== 1) {\n        // Finish dragging to avoid conflict with touchZoom\n        if (Draggable._dragging === this) {\n          this.finishDrag();\n        }\n        return;\n      }\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n      disableImageDrag();\n      disableTextSelection();\n      if (this._moving) {\n        return;\n      }\n\n      // @event down: Event\n      // Fired when a drag is about to start.\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n        sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY);\n      this._startPos = getPosition(this._element);\n\n      // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n      this._parentScale = getScale(sizedParent);\n      var mouseevent = e.type === 'mousedown';\n      on(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);\n      on(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);\n    },\n    _onMove: function (e) {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n        offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n      if (!offset.x && !offset.y) {\n        return;\n      }\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      }\n\n      // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement;\n        // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      this._lastEvent = e;\n      this._updatePosition();\n    },\n    _updatePosition: function () {\n      var e = {\n        originalEvent: this._lastEvent\n      };\n\n      // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos);\n\n      // @event drag: Event\n      // Fired continuously during dragging.\n      this.fire('drag', e);\n    },\n    _onUp: function () {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      this.finishDrag();\n    },\n    finishDrag: function (noInertia) {\n      removeClass(document.body, 'leaflet-dragging');\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n      off(document, 'mousemove touchmove', this._onMove, this);\n      off(document, 'mouseup touchend touchcancel', this._onUp, this);\n      enableImageDrag();\n      enableTextSelection();\n      var fireDragend = this._moved && this._moving;\n      this._moving = false;\n      Draggable._dragging = false;\n      if (fireDragend) {\n        // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n        this.fire('dragend', {\n          noInertia: noInertia,\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n    }\n  });\n\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n      edges = [1, 4, 2, 8],\n      i,\n      j,\n      k,\n      a,\n      b,\n      len,\n      edge,\n      p;\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    }\n\n    // for each edge (left, bottom, right, top)\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j];\n\n        // if a is inside the clip window\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n          clippedPoints.push(a);\n\n          // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n      points = clippedPoints;\n    }\n    return points;\n  }\n\n  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.\r\n   */\n  function polygonCenter(latlngs, crs) {\n    var i, j, p1, p2, f, area, x, y, center;\n    if (!latlngs || latlngs.length === 0) {\n      throw new Error('latlngs not passed');\n    }\n    if (!isFlat(latlngs)) {\n      console.warn('latlngs are not flat! Only the first ring will be used');\n      latlngs = latlngs[0];\n    }\n    var centroidLatLng = toLatLng([0, 0]);\n    var bounds = toLatLngBounds(latlngs);\n    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n    // tests showed that below 1700 rounding errors are happening\n    if (areaBounds < 1700) {\n      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n      centroidLatLng = centroid(latlngs);\n    }\n    var len = latlngs.length;\n    var points = [];\n    for (i = 0; i < len; i++) {\n      var latlng = toLatLng(latlngs[i]);\n      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\n    }\n    area = x = y = 0;\n\n    // polygon centroid algorithm;\n    for (i = 0, j = len - 1; i < len; j = i++) {\n      p1 = points[i];\n      p2 = points[j];\n      f = p1.y * p2.x - p2.y * p1.x;\n      x += (p1.x + p2.x) * f;\n      y += (p1.y + p2.y) * f;\n      area += f * 3;\n    }\n    if (area === 0) {\n      // Polygon is so small that all points are on same pixel.\n      center = points[0];\n    } else {\n      center = [x / area, y / area];\n    }\n    var latlngCenter = crs.unproject(toPoint(center));\n    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\n  }\n\n  /* @function centroid(latlngs: LatLng[]): LatLng\r\n   * Returns the 'center of mass' of the passed LatLngs.\r\n   */\n  function centroid(coords) {\n    var latSum = 0;\n    var lngSum = 0;\n    var len = 0;\n    for (var i = 0; i < coords.length; i++) {\n      var latlng = toLatLng(coords[i]);\n      latSum += latlng.lat;\n      lngSum += latlng.lng;\n      len++;\n    }\n    return toLatLng([latSum / len, lngSum / len]);\n  }\n  var PolyUtil = {\n    __proto__: null,\n    clipPolygon: clipPolygon,\n    polygonCenter: polygonCenter,\n    centroid: centroid\n  };\n\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n    var sqTolerance = tolerance * tolerance;\n\n    // stage 1: vertex reduction\n    points = _reducePoints(points, sqTolerance);\n\n    // stage 2: Douglas-Peucker simplification\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  }\n\n  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  }\n\n  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  }\n\n  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n      ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\n      markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n    var i,\n      newPoints = [];\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n    return newPoints;\n  }\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n      index,\n      i,\n      sqDist;\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  }\n\n  // reduce points that are too close to each other to a single point\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n    return reducedPoints;\n  }\n  var _lastCode;\n\n  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n      codeB = _getBitCode(b, bounds),\n      codeOut,\n      p,\n      newCode;\n\n    // save 2nd code to avoid calculating it on the next segment\n    _lastCode = codeB;\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      }\n\n      // if a,b is outside the clip window (trivial reject)\n      if (codeA & codeB) {\n        return false;\n      }\n\n      // other cases\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n      dy = b.y - a.y,\n      min = bounds.min,\n      max = bounds.max,\n      x,\n      y;\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n    return new Point(x, y, round);\n  }\n  function _getBitCode(p, bounds) {\n    var code = 0;\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n    return code;\n  }\n\n  // square distance (to avoid unnecessary Math.sqrt calls)\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n      dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  }\n\n  // return closest point on segment or distance to that point\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n      y = p1.y,\n      dx = p2.x - x,\n      dy = p2.y - y,\n      dot = dx * dx + dy * dy,\n      t;\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  }\n\n  // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.\r\n   */\n  function polylineCenter(latlngs, crs) {\n    var i, halfDist, segDist, dist, p1, p2, ratio, center;\n    if (!latlngs || latlngs.length === 0) {\n      throw new Error('latlngs not passed');\n    }\n    if (!isFlat(latlngs)) {\n      console.warn('latlngs are not flat! Only the first ring will be used');\n      latlngs = latlngs[0];\n    }\n    var centroidLatLng = toLatLng([0, 0]);\n    var bounds = toLatLngBounds(latlngs);\n    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n    // tests showed that below 1700 rounding errors are happening\n    if (areaBounds < 1700) {\n      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n      centroidLatLng = centroid(latlngs);\n    }\n    var len = latlngs.length;\n    var points = [];\n    for (i = 0; i < len; i++) {\n      var latlng = toLatLng(latlngs[i]);\n      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\n    }\n    for (i = 0, halfDist = 0; i < len - 1; i++) {\n      halfDist += points[i].distanceTo(points[i + 1]) / 2;\n    }\n\n    // The line is so small in the current view that all points are on the same pixel.\n    if (halfDist === 0) {\n      center = points[0];\n    } else {\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          center = [p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)];\n          break;\n        }\n      }\n    }\n    var latlngCenter = crs.unproject(toPoint(center));\n    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\n  }\n  var LineUtil = {\n    __proto__: null,\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat,\n    polylineCenter: polylineCenter\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection — the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function (latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function (point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function (latlng) {\n      var d = Math.PI / 180,\n        r = this.R,\n        y = latlng.lat * d,\n        tmp = this.R_MINOR / r,\n        e = Math.sqrt(1 - tmp * tmp),\n        con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI,\n        r = this.R,\n        tmp = this.R_MINOR / r,\n        e = Math.sqrt(1 - tmp * tmp),\n        ts = Math.exp(-point.y / r),\n        phi = Math.PI / 2 - 2 * Math.atan(ts);\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n\n  /*\n   * @class Projection\n    * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n    * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n    * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n    * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n    * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n    */\n\n  var index = {\n    __proto__: null,\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  };\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function (zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function (scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function (latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n        dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \"© OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function (map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function () {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    //\n    // @alternative\n    // @method removeFrom(group: LayerGroup): this\n    // Removes the layer from the given `LayerGroup`\n    removeFrom: function (obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function (name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function (targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function (targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function () {\n      return this.options.attribution;\n    },\n    _layerAdd: function (e) {\n      var map = e.target;\n\n      // check in case layer gets added and then removed before the map is ready\n      if (!map.hasLayer(this)) {\n        return;\n      }\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n      this.onAdd(map);\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function (layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n      var id = stamp(layer);\n      if (this._layers[id]) {\n        return this;\n      }\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function (layer) {\n      var id = stamp(layer);\n      if (!this._layers[id]) {\n        return this;\n      }\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n      delete this._layers[id];\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function (layer) {\n      return stamp(layer) in this._layers;\n    },\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    _addLayers: function (layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function (layer) {\n      if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function (layer) {\n      var id = stamp(layer);\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function () {\n      var minZoom = Infinity,\n        maxZoom = -Infinity,\n        oldZoomSpan = this._getZoomSpan();\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n      // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function (layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function (layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function (layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function (layer) {\n      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);\n      return layerId in this._layers;\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function () {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, …): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function (methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        i,\n        layer;\n      for (i in this._layers) {\n        layer = this._layers[i];\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n      return this;\n    },\n    onAdd: function (map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function (map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function (id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function () {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function (zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function (layer) {\n      return stamp(layer);\n    }\n  });\n\n  // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n  var layerGroup = function (layers, options) {\n    return new LayerGroup(layers, options);\n  };\n\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function (layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer);\n\n      // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function (layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer);\n\n      // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function (style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function () {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function () {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function () {\n      var bounds = new LatLngBounds();\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n      return bounds;\n    }\n  });\n\n  // @factory L.featureGroup(layers?: Layer[], options?: Object)\n  // Create a feature group, optionally given an initial set of layers and an `options` object.\n  var featureGroup = function (layers, options) {\n    return new FeatureGroup(layers, options);\n  };\n\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0],\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function (oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function (oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function (name, oldIcon) {\n      var src = this._getIconUrl(name);\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n        return null;\n      }\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n      this._setIconStyles(img, name);\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      return img;\n    },\n    _setIconStyles: function (img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n      var size = toPoint(sizeOption),\n        anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function (src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function (name) {\n      return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  });\n\n  // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n  function icon(options) {\n    return new Icon(options);\n  }\n\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function (name) {\n      if (typeof IconDefault.imagePath !== 'string') {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      }\n\n      // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _stripUrl: function (path) {\n      // separate function to use in tests\n      var strip = function (str, re, idx) {\n        var match = re.exec(str);\n        return match && match[idx];\n      };\n      path = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n      return path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n    },\n    _detectIconPath: function () {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n      path = this._stripUrl(path);\n      if (path) {\n        return path;\n      }\n      var link = document.querySelector('link[href$=\"leaflet.css\"]');\n      if (!link) {\n        return '';\n      }\n      return link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);\n    }\n  });\n\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function (marker) {\n      this._marker = marker;\n    },\n    addHooks: function () {\n      var icon = this._marker._icon;\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function () {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function (e) {\n      var marker = this._marker,\n        map = marker._map,\n        speed = this._marker.options.autoPanSpeed,\n        padding = this._marker.options.autoPanPadding,\n        iconPos = getPosition(marker._icon),\n        bounds = map.getPixelBounds(),\n        origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n        this._draggable._newPos._add(movement);\n        this._draggable._startPos._add(movement);\n        setPosition(marker._icon, this._draggable._newPos);\n        this._onDrag(e);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function () {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n\n      this._oldLatLng = this._marker.getLatLng();\n\n      // When using ES6 imports it could not be set when `Popup` was not imported as well\n      this._marker.closePopup && this._marker.closePopup();\n      this._marker.fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function (e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function (e) {\n      var marker = this._marker,\n        shadow = marker._shadow,\n        iconPos = getPosition(marker._icon),\n        latlng = marker._map.layerPointToLatLng(iconPos);\n\n      // update shadow position\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng;\n\n      // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function (e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n\n      cancelAnimFrame(this._panRequest);\n\n      // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n      delete this._oldLatLng;\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n      title: '',\n      // @option alt: String = 'Marker'\n      // Text for the `alt` attribute of the icon image.\n      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n      alt: 'Marker',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option shadowPane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @option autoPanOnFocus: Boolean = true\n      // When `true`, the map will pan whenever the marker is focused (via\n      // e.g. pressing `tab` on the keyboard) to ensure the marker is\n      // visible within the map's bounds\n      autoPanOnFocus: true,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n      this._initIcon();\n      this.update();\n    },\n    onRemove: function (map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n      delete this.dragging;\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n      this._removeIcon();\n      this._removeShadow();\n    },\n    getEvents: function () {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update();\n\n      // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function (offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function () {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function (icon) {\n      this.options.icon = icon;\n      if (this._map) {\n        this._initIcon();\n        this.update();\n      }\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n      return this;\n    },\n    getElement: function () {\n      return this._icon;\n    },\n    update: function () {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n        this._setPos(pos);\n      }\n      return this;\n    },\n    _initIcon: function () {\n      var options = this.options,\n        classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n        addIcon = false;\n\n      // if we're not reusing the icon, remove the old one and init new one\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n        addIcon = true;\n        if (options.title) {\n          icon.title = options.title;\n        }\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n      addClass(icon, classToAdd);\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n        icon.setAttribute('role', 'button');\n      }\n      this._icon = icon;\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n      if (this.options.autoPanOnFocus) {\n        on(icon, 'focus', this._panOnFocus, this);\n      }\n      var newShadow = options.icon.createShadow(this._shadow),\n        addShadow = false;\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n        addShadow = true;\n      }\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n      this._shadow = newShadow;\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n      this._initInteraction();\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function () {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n      if (this.options.autoPanOnFocus) {\n        off(this._icon, 'focus', this._panOnFocus, this);\n      }\n      remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function () {\n      if (this._shadow) {\n        remove(this._shadow);\n      }\n      this._shadow = null;\n    },\n    _setPos: function (pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n      this._zIndex = pos.y + this.options.zIndexOffset;\n      this._resetZIndex();\n    },\n    _updateZIndex: function (offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function (opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n      this._setPos(pos);\n    },\n    _initInteraction: function () {\n      if (!this.options.interactive) {\n        return;\n      }\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n        this.dragging = new MarkerDrag(this);\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n      if (this._map) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    _updateOpacity: function () {\n      var opacity = this.options.opacity;\n      if (this._icon) {\n        setOpacity(this._icon, opacity);\n      }\n      if (this._shadow) {\n        setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function () {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function () {\n      this._updateZIndex(0);\n    },\n    _panOnFocus: function () {\n      var map = this._map;\n      if (!map) {\n        return;\n      }\n      var iconOpts = this.options.icon.options;\n      var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\n      var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\n      map.panInside(this._latlng, {\n        paddingTopLeft: anchor,\n        paddingBottomRight: size.subtract(anchor)\n      });\n    },\n    _getPopupAnchor: function () {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function () {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  });\n\n  // factory L.marker(latlng: LatLng, options? : Marker options)\n\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function (map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function () {\n      this._renderer._initPath(this);\n      this._reset();\n      this._renderer._addPath(this);\n    },\n    onRemove: function () {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function () {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function (style) {\n      setOptions(this, style);\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {\n          this._updateBounds();\n        }\n      }\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function () {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function () {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n      return this;\n    },\n    getElement: function () {\n      return this._path;\n    },\n    _reset: function () {\n      // defined in child classes\n      this._project();\n      this._update();\n    },\n    _clickTolerance: function () {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);\n    }\n  });\n\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw();\n\n      // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function (radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function () {\n      return this._radius;\n    },\n    setStyle: function (options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function () {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n      this._updateBounds();\n    },\n    _updateBounds: function () {\n      var r = this._radius,\n        r2 = this._radiusY || r,\n        w = this._clickTolerance(),\n        p = [r + w, r2 + w];\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function () {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function () {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  });\n\n  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n  var Circle = CircleMarker.extend({\n    initialize: function (latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      }\n\n      // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function (radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function () {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function () {\n      var lng = this._latlng.lng,\n        lat = this._latlng.lat,\n        map = this._map,\n        crs = map.options.crs;\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n          latR = this._mRadius / Earth.R / d,\n          top = map.project([lat + latR, lng]),\n          bottom = map.project([lat - latR, lng]),\n          p = top.add(bottom).divideBy(2),\n          lat2 = map.unproject(p).lat,\n          lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n      this._updateBounds();\n    }\n  });\n\n  // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function (latlngs, options) {\n      setOptions(this, options);\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function () {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function (latlngs) {\n      this._setLatLngs(latlngs);\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function () {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function (p) {\n      var minDistance = Infinity,\n        minPoint = null,\n        closest = _sqClosestPointOnSegment,\n        p1,\n        p2;\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n      return polylineCenter(this._defaultShape(), this._map.options.crs);\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function (latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n      this._bounds.extend(latlng);\n      return this.redraw();\n    },\n    _setLatLngs: function (latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function (latlngs) {\n      var result = [],\n        flat = isFlat(latlngs);\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n      return result;\n    },\n    _project: function () {\n      var pxBounds = new Bounds();\n      this._rings = [];\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function () {\n      var w = this._clickTolerance(),\n        p = new Point(w, w);\n      if (!this._rawPxBounds) {\n        return;\n      }\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function (latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n        len = latlngs.length,\n        i,\n        ring;\n      if (flat) {\n        ring = [];\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function () {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n      var parts = this._parts,\n        i,\n        j,\n        k,\n        len,\n        len2,\n        segment,\n        points;\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n          if (!segment) {\n            continue;\n          }\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]);\n\n          // if segment goes out of screen, or it's the last one, it's the end of the line part\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function () {\n      var parts = this._parts,\n        tolerance = this.options.smoothFactor;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n      this._clipPoints();\n      this._simplifyPoints();\n      this._updatePath();\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p, closed) {\n      var i,\n        j,\n        k,\n        len,\n        len2,\n        part,\n        w = this._clickTolerance();\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      }\n\n      // hit detection for polylines\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  });\n\n  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  }\n\n  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n  Polyline._flat = _flat;\n\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function () {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n      return polygonCenter(this._defaultShape(), this._map.options.crs);\n    },\n    _convertLatLngs: function (latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n        len = result.length;\n\n      // remove last point if it equals first one\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n      return result;\n    },\n    _setLatLngs: function (latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function () {\n      // polygons need a different clipping algorithm so we redefine that\n\n      var bounds = this._renderer._bounds,\n        w = this.options.weight,\n        p = new Point(w, w);\n\n      // increase clip padding by stroke width to avoid stroke on clip edges\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      var inside = false,\n        part,\n        p1,\n        p2,\n        i,\n        j,\n        k,\n        len,\n        len2;\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      }\n\n      // ray casting algorithm for detecting if point is in polygon\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      }\n\n      // also check if it's on polygon stroke\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  });\n\n  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n\n    initialize: function (geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function (geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n        i,\n        len,\n        feature;\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n        return this;\n      }\n      var options = this.options;\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n      var layer = geometryToLayer(geojson, options);\n      if (!layer) {\n        return this;\n      }\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function (layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      }\n      // reset any custom styles\n      layer.options = extend({}, layer.defaultOptions);\n      this._setLayerStyle(layer, this.options.style);\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function (style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function (layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n        layer.setStyle(style);\n      }\n    }\n  });\n\n  // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n      coords = geometry ? geometry.coordinates : null,\n      layers = [],\n      pointToLayer = options && options.pointToLayer,\n      _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n      latlng,\n      latlngs,\n      i,\n      len;\n    if (!coords && !geometry) {\n      return null;\n    }\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n        return new FeatureGroup(layers);\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var geoLayer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n          if (geoLayer) {\n            layers.push(geoLayer);\n          }\n        }\n        return new FeatureGroup(layers);\n      case 'FeatureCollection':\n        for (i = 0, len = geometry.features.length; i < len; i++) {\n          var featureLayer = geometryToLayer(geometry.features[i], options);\n          if (featureLayer) {\n            layers.push(featureLayer);\n          }\n        }\n        return new FeatureGroup(layers);\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  }\n\n  // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  }\n\n  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n    return latlngs;\n  }\n\n  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n  function latLngToCoords(latlng, precision) {\n    latlng = toLatLng(latlng);\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  }\n\n  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      // Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n    if (!levelsDeep && closed && coords.length > 0) {\n      coords.push(coords[0].slice());\n    }\n    return coords;\n  }\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  }\n\n  // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n  var PointToGeoJSON = {\n    toGeoJSON: function (precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  };\n\n  // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n  Marker.include(PointToGeoJSON);\n\n  // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON);\n\n  // @namespace Polyline\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n  Polyline.include({\n    toGeoJSON: function (precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  });\n\n  // @namespace Polygon\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n  Polygon.include({\n    toGeoJSON: function (precision) {\n      var holes = !isFlat(this._latlngs),\n        multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n      if (!holes) {\n        coords = [coords];\n      }\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  });\n\n  // @namespace LayerGroup\n  LayerGroup.include({\n    toMultiPoint: function (precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function (precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n      var isGeometryCollection = type === 'GeometryCollection',\n        jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json);\n            // Squash nested feature collections\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  });\n\n  // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  }\n\n  // Backward compatibility.\n  var geoJson = geoJSON;\n\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function (url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      if (!this._image) {\n        this._initImage();\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n      this.getPane().appendChild(this._image);\n      this._reset();\n    },\n    onRemove: function () {\n      remove(this._image);\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n      if (this._image) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    setStyle: function (styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._image);\n      }\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._image);\n      }\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function (url) {\n      this._url = url;\n      if (this._image) {\n        this._image.src = url;\n      }\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function (bounds) {\n      this._bounds = toLatLngBounds(bounds);\n      if (this._map) {\n        this._reset();\n      }\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function (value) {\n      this.options.zIndex = value;\n      this._updateZIndex();\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function () {\n      return this._image;\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn;\n\n      // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function (e) {\n      var scale = this._map.getZoomScale(e.zoom),\n        offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function () {\n      var image = this._image,\n        bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n        size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function () {\n      setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function () {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function () {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    },\n    // @method getCenter(): LatLng\n    // Returns the center of the ImageOverlay.\n    getCenter: function () {\n      return this._bounds.getCenter();\n    }\n  });\n\n  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n  var imageOverlay = function (url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      // On some browsers autoplay will only work with `muted: true`\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\n      keepAspectRatio: true,\n      // @option muted: Boolean = false\n      // Whether the video starts on mute when loaded.\n      muted: false,\n      // @option playsInline: Boolean = true\n      // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\n      playsInline: true\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn;\n\n      // @event load: Event\n      // Fired when the video has finished loading the first frame\n      vid.onloadeddata = bind(this.fire, this, 'load');\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n      vid.muted = !!this.options.muted;\n      vid.playsInline = !!this.options.playsInline;\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    }\n\n    // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n  });\n\n  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function () {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    }\n\n    // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n  });\n\n  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */\n\n  // @namespace DivOverlay\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option interactive: Boolean = false\n      // If true, the popup/tooltip will listen to the mouse events.\n      interactive: false,\n      // @option offset: Point = Point(0, 0)\n      // The offset of the overlay position.\n      offset: [0, 0],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the overlay.\n      className: '',\n      // @option pane: String = undefined\n      // `Map pane` where the overlay will be added.\n      pane: undefined,\n      // @option content: String|HTMLElement|Function = ''\n      // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be\n      // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.\n      content: ''\n    },\n    initialize: function (options, source) {\n      if (options && (options instanceof LatLng || isArray(options))) {\n        this._latlng = toLatLng(options);\n        setOptions(this, source);\n      } else {\n        setOptions(this, options);\n        this._source = source;\n      }\n      if (this.options.content) {\n        this._content = this.options.content;\n      }\n    },\n    // @method openOn(map: Map): this\n    // Adds the overlay to the map.\n    // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\n    openOn: function (map) {\n      map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n      if (!map.hasLayer(this)) {\n        map.addLayer(this);\n      }\n      return this;\n    },\n    // @method close(): this\n    // Closes the overlay.\n    // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\n    // and `layer.closePopup()`/`.closeTooltip()`.\n    close: function () {\n      if (this._map) {\n        this._map.removeLayer(this);\n      }\n      return this;\n    },\n    // @method toggle(layer?: Layer): this\n    // Opens or closes the overlay bound to layer depending on its current state.\n    // Argument may be omitted only for overlay bound to layer.\n    // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\n    toggle: function (layer) {\n      if (this._map) {\n        this.close();\n      } else {\n        if (arguments.length) {\n          this._source = layer;\n        } else {\n          layer = this._source;\n        }\n        this._prepareOpen();\n\n        // open the overlay on the map\n        this.openOn(layer._map);\n      }\n      return this;\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = map._zoomAnimated;\n      if (!this._container) {\n        this._initLayout();\n      }\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n      }\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 1);\n      }\n      this.bringToFront();\n      if (this.options.interactive) {\n        addClass(this._container, 'leaflet-interactive');\n        this.addInteractiveTarget(this._container);\n      }\n    },\n    onRemove: function (map) {\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n      } else {\n        remove(this._container);\n      }\n      if (this.options.interactive) {\n        removeClass(this._container, 'leaflet-interactive');\n        this.removeInteractiveTarget(this._container);\n      }\n    },\n    // @namespace DivOverlay\n    // @method getLatLng: LatLng\n    // Returns the geographical point of the overlay.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the overlay will open.\n    setLatLng: function (latlng) {\n      this._latlng = toLatLng(latlng);\n      if (this._map) {\n        this._updatePosition();\n        this._adjustPan();\n      }\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the overlay.\n    getContent: function () {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\n    // The function should return a `String` or `HTMLElement` to be used in the overlay.\n    setContent: function (content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Returns the HTML container of the overlay.\n    getElement: function () {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\n    update: function () {\n      if (!this._map) {\n        return;\n      }\n      this._container.style.visibility = 'hidden';\n      this._updateContent();\n      this._updateLayout();\n      this._updatePosition();\n      this._container.style.visibility = '';\n      this._adjustPan();\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the overlay is visible on the map.\n    isOpen: function () {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this overlay in front of other overlays (in the same map pane).\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n      }\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this overlay to the back of other overlays (in the same map pane).\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n      }\n      return this;\n    },\n    // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\n    _prepareOpen: function (latlng) {\n      var source = this._source;\n      if (!source._map) {\n        return false;\n      }\n      if (source instanceof FeatureGroup) {\n        source = null;\n        var layers = this._source._layers;\n        for (var id in layers) {\n          if (layers[id]._map) {\n            source = layers[id];\n            break;\n          }\n        }\n        if (!source) {\n          return false;\n        } // Unable to get source layer.\n\n        // set overlay source to this layer\n        this._source = source;\n      }\n      if (!latlng) {\n        if (source.getCenter) {\n          latlng = source.getCenter();\n        } else if (source.getLatLng) {\n          latlng = source.getLatLng();\n        } else if (source.getBounds) {\n          latlng = source.getBounds().getCenter();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      }\n      this.setLatLng(latlng);\n      if (this._map) {\n        // update the overlay (content, layout, etc...)\n        this.update();\n      }\n      return true;\n    },\n    _updateContent: function () {\n      if (!this._content) {\n        return;\n      }\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n        node.appendChild(content);\n      }\n\n      // @namespace DivOverlay\n      // @section DivOverlay events\n      // @event contentupdate: Event\n      // Fired when the content of the overlay is updated\n      this.fire('contentupdate');\n    },\n    _updatePosition: function () {\n      if (!this._map) {\n        return;\n      }\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n        offset = toPoint(this.options.offset),\n        anchor = this._getAnchor();\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n      var bottom = this._containerBottom = -offset.y,\n        left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\n\n      // bottom position the overlay in case the height of the overlay changes (images loading etc)\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function () {\n      return [0, 0];\n    }\n  });\n  Map.include({\n    _initOverlay: function (OverlayClass, content, latlng, options) {\n      var overlay = content;\n      if (!(overlay instanceof OverlayClass)) {\n        overlay = new OverlayClass(options).setContent(content);\n      }\n      if (latlng) {\n        overlay.setLatLng(latlng);\n      }\n      return overlay;\n    }\n  });\n  Layer.include({\n    _initOverlay: function (OverlayClass, old, content, options) {\n      var overlay = content;\n      if (overlay instanceof OverlayClass) {\n        setOptions(overlay, options);\n        overlay._source = this;\n      } else {\n        overlay = old && !options ? old : new OverlayClass(options, this);\n        overlay.setContent(content);\n      }\n      return overlay;\n    }\n  });\n\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   *\r\n   * A popup can be also standalone:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   * or\r\n   * ```js\r\n   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n\n  // @namespace Popup\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane',\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position.\n      offset: [0, 7],\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      // The scrollable container can be styled using the\n      // `leaflet-popup-scrolled` CSS class selector.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Alternative to `map.openPopup(popup)`.\n    // Adds the popup to the map and closes the previous one.\n    openOn: function (map) {\n      map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n\n      if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\n        map.removeLayer(map._popup);\n      }\n      map._popup = this;\n      return DivOverlay.prototype.openOn.call(this, map);\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n\n      // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n      map.fire('popupopen', {\n        popup: this\n      });\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true);\n        // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map);\n\n      // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n      map.fire('popupclose', {\n        popup: this\n      });\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this.close;\n      }\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n      return events;\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-popup',\n        container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(container);\n      disableScrollPropagation(this._contentNode);\n      on(container, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399\n        closeButton.setAttribute('aria-label', 'Close popup');\n        closeButton.href = '#close';\n        closeButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\n        on(closeButton, 'click', function (ev) {\n          preventDefault(ev);\n          this.close();\n        }, this);\n      }\n    },\n    _updateLayout: function () {\n      var container = this._contentNode,\n        style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n        maxHeight = this.options.maxHeight,\n        scrolledClass = 'leaflet-popup-scrolled';\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n        anchor = this._getAnchor();\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function () {\n      if (!this.options.autoPan) {\n        return;\n      }\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      // We can endlessly recurse if keepInView is set and the view resets.\n      // Let's guard against that by exiting early if we're responding to our own autopan.\n      if (this._autopanning) {\n        this._autopanning = false;\n        return;\n      }\n      var map = this._map,\n        marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n        containerHeight = this._container.offsetHeight + marginBottom,\n        containerWidth = this._containerWidth,\n        layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n      layerPos._add(getPosition(this._container));\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n        padding = toPoint(this.options.autoPanPadding),\n        paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n        paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n        size = map.getSize(),\n        dx = 0,\n        dy = 0;\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      }\n\n      // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n      if (dx || dy) {\n        // Track that we're autopanning, as this function will be re-ran on moveend\n        if (this.options.keepInView) {\n          this._autopanning = true;\n        }\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _getAnchor: function () {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  });\n\n  // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.popup(latlng: LatLng, options?: Popup options)\n  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.\n  var popup = function (options, source) {\n    return new Popup(options, source);\n  };\n\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n  Map.mergeOptions({\n    closePopupOnClick: true\n  });\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function (popup, latlng, options) {\n      this._initOverlay(Popup, popup, latlng, options).openOn(this);\n      return this;\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function (popup) {\n      popup = arguments.length ? popup : this._popup;\n      if (popup) {\n        popup.close();\n      }\n      return this;\n    }\n  });\n\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n\n  // @section Popup methods\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function (content, options) {\n      this._popup = this._initOverlay(Popup, this._popup, content, options);\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function () {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function (latlng) {\n      if (this._popup) {\n        if (!(this instanceof FeatureGroup)) {\n          this._popup._source = this;\n        }\n        if (this._popup._prepareOpen(latlng || this._latlng)) {\n          // open the popup on the map\n          this._popup.openOn(this._map);\n        }\n      }\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function () {\n      if (this._popup) {\n        this._popup.close();\n      }\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function () {\n      if (this._popup) {\n        this._popup.toggle(this);\n      }\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function () {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function (content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function () {\n      return this._popup;\n    },\n    _openPopup: function (e) {\n      if (!this._popup || !this._map) {\n        return;\n      }\n      // prevent map click\n      stop(e);\n      var target = e.layer || e.target;\n      if (this._popup._source === target && !(target instanceof Path)) {\n        // treat it like a marker and figure out\n        // if we should toggle it open/closed\n        if (this._map.hasLayer(this._popup)) {\n          this.closePopup();\n        } else {\n          this.openPopup(e.latlng);\n        }\n        return;\n      }\n      this._popup._source = target;\n      this.openPopup(e.latlng);\n    },\n    _movePopup: function (e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function (e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   * If you want to just bind a tooltip to marker:\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Path overlays like polylines also have a `bindTooltip` method.\n   *\n   * A tooltip can be also standalone:\n   *\n   * ```js\n   * var tooltip = L.tooltip()\n   * \t.setLatLng(latlng)\n   * \t.setContent('Hello world!<br />This is a nice tooltip.')\n   * \t.addTo(map);\n   * ```\n   * or\n   * ```js\n   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})\n   * \t.addTo(map);\n   * ```\n   *\n   *\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n\n  // @namespace Tooltip\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity);\n\n      // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n      if (this._source) {\n        this.addEventParent(this._source);\n\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map);\n\n      // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n      if (this._source) {\n        this.removeEventParent(this._source);\n\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n      if (!this.options.permanent) {\n        events.preclick = this.close;\n      }\n      return events;\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-tooltip',\n        className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n      this._container.setAttribute('role', 'tooltip');\n      this._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));\n    },\n    _updateLayout: function () {},\n    _adjustPan: function () {},\n    _setPosition: function (pos) {\n      var subX,\n        subY,\n        map = this._map,\n        container = this._container,\n        centerPoint = map.latLngToContainerPoint(map.getCenter()),\n        tooltipPoint = map.layerPointToContainerPoint(pos),\n        direction = this.options.direction,\n        tooltipWidth = container.offsetWidth,\n        tooltipHeight = container.offsetHeight,\n        offset = toPoint(this.options.offset),\n        anchor = this._getAnchor();\n      if (direction === 'top') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight;\n      } else if (direction === 'bottom') {\n        subX = tooltipWidth / 2;\n        subY = 0;\n      } else if (direction === 'center') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'right') {\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'left') {\n        subX = tooltipWidth;\n        subY = tooltipHeight / 2;\n      } else if (tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else {\n        direction = 'left';\n        subX = tooltipWidth + (offset.x + anchor.x) * 2;\n        subY = tooltipHeight / 2;\n      }\n      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function () {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n      this._setPosition(pos);\n    },\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n      if (this._container) {\n        setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n      this._setPosition(pos);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  });\n\n  // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)\n  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.\n  var tooltip = function (options, source) {\n    return new Tooltip(options, source);\n  };\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function (tooltip, latlng, options) {\n      this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);\n      return this;\n    },\n    // @method closeTooltip(tooltip: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function (tooltip) {\n      tooltip.close();\n      return this;\n    }\n  });\n\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n\n  // @section Tooltip methods\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function (content, options) {\n      if (this._tooltip && this.isTooltipOpen()) {\n        this.unbindTooltip();\n      }\n      this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n      this._initTooltipInteractions();\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function () {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n      return this;\n    },\n    _initTooltipInteractions: function (remove) {\n      if (!remove && this._tooltipHandlersAdded) {\n        return;\n      }\n      var onOff = remove ? 'off' : 'on',\n        events = {\n          remove: this.closeTooltip,\n          move: this._moveTooltip\n        };\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n        events.click = this._openTooltip;\n        if (this._map) {\n          this._addFocusListeners();\n        } else {\n          events.add = this._addFocusListeners;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n      if (this._tooltip.options.sticky) {\n        events.mousemove = this._moveTooltip;\n      }\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function (latlng) {\n      if (this._tooltip) {\n        if (!(this instanceof FeatureGroup)) {\n          this._tooltip._source = this;\n        }\n        if (this._tooltip._prepareOpen(latlng)) {\n          // open the tooltip on the map\n          this._tooltip.openOn(this._map);\n          if (this.getElement) {\n            this._setAriaDescribedByOnLayer(this);\n          } else if (this.eachLayer) {\n            this.eachLayer(this._setAriaDescribedByOnLayer, this);\n          }\n        }\n      }\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function () {\n      if (this._tooltip) {\n        return this._tooltip.close();\n      }\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function () {\n      if (this._tooltip) {\n        this._tooltip.toggle(this);\n      }\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function () {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function (content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function () {\n      return this._tooltip;\n    },\n    _addFocusListeners: function () {\n      if (this.getElement) {\n        this._addFocusListenersOnLayer(this);\n      } else if (this.eachLayer) {\n        this.eachLayer(this._addFocusListenersOnLayer, this);\n      }\n    },\n    _addFocusListenersOnLayer: function (layer) {\n      var el = typeof layer.getElement === 'function' && layer.getElement();\n      if (el) {\n        on(el, 'focus', function () {\n          this._tooltip._source = layer;\n          this.openTooltip();\n        }, this);\n        on(el, 'blur', this.closeTooltip, this);\n      }\n    },\n    _setAriaDescribedByOnLayer: function (layer) {\n      var el = typeof layer.getElement === 'function' && layer.getElement();\n      if (el) {\n        el.setAttribute('aria-describedby', this._tooltip._container.id);\n      }\n    },\n    _openTooltip: function (e) {\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      // If the map is moving, we will show the tooltip after it's done.\n      if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {\n        this._openOnceFlag = true;\n        var that = this;\n        this._map.once('moveend', function () {\n          that._openOnceFlag = false;\n          that._openTooltip(e);\n        });\n        return;\n      }\n      this._tooltip._source = e.layer || e.target;\n      this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function (e) {\n      var latlng = e.latlng,\n        containerPoint,\n        layerPoint;\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function (oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n        options = this.options;\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n      this._setIconStyles(div, 'icon');\n      return div;\n    },\n    createShadow: function () {\n      return null;\n    }\n  });\n\n  // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n  Icon.Default = IconDefault;\n\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: Browser.mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      this._initContainer();\n      this._levels = {};\n      this._tiles = {};\n      this._resetView(); // implicit _update() call\n    },\n    beforeAdd: function (map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function (map) {\n      this._removeAllTiles();\n      remove(this._container);\n      map._removeZoomLimit(this);\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n        this._setAutoZIndex(Math.max);\n      }\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n        this._setAutoZIndex(Math.min);\n      }\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n      this._updateOpacity();\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function (zIndex) {\n      this.options.zIndex = zIndex;\n      this._updateZIndex();\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function () {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function () {\n      if (this._map) {\n        this._removeAllTiles();\n        var tileZoom = this._clampZoom(this._map.getZoom());\n        if (tileZoom !== this._tileZoom) {\n          this._tileZoom = tileZoom;\n          this._updateLevels();\n        }\n        this._update();\n      }\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n        events.move = this._onMove;\n      }\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function () {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function () {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function () {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function (compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n      var layers = this.getPane().children,\n        edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function () {\n      if (!this._map) {\n        return;\n      }\n\n      // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n      if (Browser.ielt9) {\n        return;\n      }\n      setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n        nextFrame = false,\n        willPrune = false;\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        setOpacity(tile.el, fade);\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n          tile.active = true;\n        }\n      }\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function () {\n      if (this._container) {\n        return;\n      }\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n      this._updateZIndex();\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function () {\n      var zoom = this._tileZoom,\n        maxZoom = this.options.maxZoom;\n      if (zoom === undefined) {\n        return undefined;\n      }\n      for (var z in this._levels) {\n        z = Number(z);\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n          this._onUpdateLevel(z);\n        } else {\n          remove(this._levels[z].el);\n          this._removeTilesAtZoom(z);\n          this._onRemoveLevel(z);\n          delete this._levels[z];\n        }\n      }\n      var level = this._levels[zoom],\n        map = this._map;\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n        this._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n        // force the browser to consider the newly added element for transition\n        falseFn(level.el.offsetWidth);\n        this._onCreateLevel(level);\n      }\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function () {\n      if (!this._map) {\n        return;\n      }\n      var key, tile;\n      var zoom = this._map.getZoom();\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n        return;\n      }\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function (zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function () {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function () {\n      for (var z in this._levels) {\n        remove(this._levels[z].el);\n        this._onRemoveLevel(Number(z));\n        delete this._levels[z];\n      }\n      this._removeAllTiles();\n      this._tileZoom = undefined;\n    },\n    _retainParent: function (x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n        y2 = Math.floor(y / 2),\n        z2 = z - 1,\n        coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n      var key = this._tileCoordsToKey(coords2),\n        tile = this._tiles[key];\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n      return false;\n    },\n    _retainChildren: function (x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n          var key = this._tileCoordsToKey(coords),\n            tile = this._tiles[key];\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function (e) {\n      var animating = e && (e.pinch || e.flyTo);\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function (e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function (zoom) {\n      var options = this.options;\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n      return zoom;\n    },\n    _setView: function (center, zoom, noPrune, noUpdate) {\n      var tileZoom = Math.round(zoom);\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      } else {\n        tileZoom = this._clampZoom(tileZoom);\n      }\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n        this._updateLevels();\n        this._resetGrid();\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n        if (!noPrune) {\n          this._pruneTiles();\n        }\n\n        // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n        this._noPrune = !!noPrune;\n      }\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function (center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function (level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n        translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n      if (Browser.any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function () {\n      var map = this._map,\n        crs = map.options.crs,\n        tileSize = this._tileSize = this.getTileSize(),\n        tileZoom = this._tileZoom;\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function () {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n      this._update();\n    },\n    _getTiledPixelBounds: function (center) {\n      var map = this._map,\n        mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n        scale = map.getZoomScale(mapZoom, this._tileZoom),\n        pixelCenter = map.project(center, this._tileZoom).floor(),\n        halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function (center) {\n      var map = this._map;\n      if (!map) {\n        return;\n      }\n      var zoom = this._clampZoom(map.getZoom());\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n        tileRange = this._pxBoundsToTileRange(pixelBounds),\n        tileCenter = tileRange.getCenter(),\n        queue = [],\n        margin = this.options.keepBuffer,\n        noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));\n\n      // Sanity check: panic if the tile range contains Infinity somewhere.\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      }\n\n      // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n        return;\n      }\n\n      // create a queue of coordinates to load tiles from\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      }\n\n      // sort tile queue to load tiles in order of their distance to center\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true;\n          // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n          this.fire('loading');\n        }\n\n        // create DOM fragment to append tiles in one batch\n        var fragment = document.createDocumentFragment();\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function (coords) {\n      var crs = this._map.options.crs;\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n      if (!this.options.bounds) {\n        return true;\n      }\n\n      // don't load tile if it doesn't intersect the bounds in options\n      var tileBounds = this._tileCoordsToBounds(coords);\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function (key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function (coords) {\n      var map = this._map,\n        tileSize = this.getTileSize(),\n        nwPoint = coords.scaleBy(tileSize),\n        sePoint = nwPoint.add(tileSize),\n        nw = map.unproject(nwPoint, coords.z),\n        se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function (coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n        bounds = new LatLngBounds(bp[0], bp[1]);\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function (coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function (key) {\n      var k = key.split(':'),\n        coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      remove(tile.el);\n      delete this._tiles[key];\n\n      // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function (tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn;\n\n      // update opacity on tiles in IE7-8 because of filter inheritance problems\n      if (Browser.ielt9 && this.options.opacity < 1) {\n        setOpacity(tile, this.options.opacity);\n      }\n    },\n    _addTile: function (coords, container) {\n      var tilePos = this._getTilePos(coords),\n        key = this._tileCoordsToKey(coords);\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n      this._initTile(tile);\n\n      // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n      setPosition(tile, tilePos);\n\n      // save tile in cache\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile);\n      // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function (coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n      var key = this._tileCoordsToKey(coords);\n      tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      tile.loaded = +new Date();\n      if (this._map._fadeAnimated) {\n        setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n        this._pruneTiles();\n      }\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded');\n\n        // @event tileload: TileEvent\n        // Fired when a tile loads.\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n      if (this._noTilesToLoad()) {\n        this._loading = false;\n        // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n        this.fire('load');\n        if (Browser.ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function (coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function (coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function (bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function () {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n\n  // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option referrerPolicy: Boolean|String = false\n      // Whether the referrerPolicy attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\n      // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\n      // (e.g. to validate an API token).\n      // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\n      referrerPolicy: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      options = setOptions(this, options);\n\n      // detecting retina displays, adjusting tileSize and zoom levels\n      if (options.detectRetina && Browser.retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);\n        } else {\n          options.zoomOffset--;\n          options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);\n        }\n        options.minZoom = Math.max(0, options.minZoom);\n      } else if (!options.zoomReverse) {\n        // make sure maxZoom is gte minZoom\n        options.maxZoom = Math.max(options.minZoom, options.maxZoom);\n      } else {\n        // make sure minZoom is lte maxZoom\n        options.minZoom = Math.min(options.maxZoom, options.minZoom);\n      }\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      }\n      this.on('tileunload', this._onTileRemove);\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function (url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n      this._url = url;\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function (coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      // for this new option we follow the documented behavior\n      // more closely by only setting the property when string\n      if (typeof this.options.referrerPolicy === 'string') {\n        tile.referrerPolicy = this.options.referrerPolicy;\n      }\n\n      // The alt attribute is set to the empty string,\n      // allowing screen readers to ignore the decorative image tiles.\n      // https://www.w3.org/WAI/tutorials/images/decorative/\n      // https://www.w3.org/TR/html-aria/#el-img-empty-alt\n      tile.alt = '';\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function (coords) {\n      var data = {\n        r: Browser.retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n        data['-y'] = invertedY;\n      }\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function (done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (Browser.ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function (done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n      done(e, tile);\n    },\n    _onTileRemove: function (e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function () {\n      var zoom = this._tileZoom,\n        maxZoom = this.options.maxZoom,\n        zoomReverse = this.options.zoomReverse,\n        zoomOffset = this.options.zoomOffset;\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function (tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function () {\n      var i, tile;\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            var coords = this._tiles[i].coords;\n            remove(tile);\n            delete this._tiles[i];\n            // @event tileabort: TileEvent\n            // Fired when a tile was loading but is now not wanted.\n            this.fire('tileabort', {\n              tile: tile,\n              coords: coords\n            });\n          }\n        }\n      }\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n\n      // Cancels any pending http requests associated with the tile\n      tile.el.setAttribute('src', emptyImageUrl);\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function (coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  });\n\n  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data © 2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams);\n\n      // all keys that are not TileLayer options go to WMS params\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && Browser.retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function (map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function (coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n        crs = this._crs,\n        bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n        min = bounds.min,\n        max = bounds.max,\n        bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n        url = TileLayer.prototype.getTileUrl.call(this, coords);\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function (params, noRedraw) {\n      extend(this.wmsParams, params);\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    }\n  });\n\n  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function () {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n        // always keep transform-origin as 0 0\n        addClass(this._container, 'leaflet-zoom-animated');\n      }\n      this.getPane().appendChild(this._container);\n      this._update();\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function () {\n      this.off('update', this._updatePaths, this);\n      this._destroyContainer();\n    },\n    getEvents: function () {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n      return events;\n    },\n    _onAnimZoom: function (ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function () {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function (center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n        viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n        currentCenterPoint = this._map.project(this._center, zoom),\n        topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));\n      if (Browser.any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function () {\n      this._update();\n      this._updateTransform(this._center, this._zoom);\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function () {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function () {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function () {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n        size = this._map.getSize(),\n        min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    // @section\n    // @aka Canvas options\n    options: {\n      // @option tolerance: Number = 0\n      // How much to extend the click tolerance around a path/object on the map.\n      tolerance: 0\n    },\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function () {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function () {\n      Renderer.prototype.onAdd.call(this);\n\n      // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n      this._draw();\n    },\n    _initContainer: function () {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      container['_leaflet_disable_events'] = true;\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function () {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function () {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n      var layer;\n      this._redrawBounds = null;\n      for (var id in this._layers) {\n        layer = this._layers[id];\n        layer._update();\n      }\n      this._redraw();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      var b = this._bounds,\n        container = this._container,\n        size = b.getSize(),\n        m = Browser.retina ? 2 : 1;\n      setPosition(container, b.min);\n\n      // set canvas size (also clearing it); use double size on retina\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n      if (Browser.retina) {\n        this._ctx.scale(2, 2);\n      }\n\n      // translate so we use the same path coordinates after canvas element moves\n      this._ctx.translate(-b.min.x, -b.min.y);\n\n      // Tell paths to redraw themselves\n      this.fire('update');\n    },\n    _reset: function () {\n      Renderer.prototype._reset.call(this);\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n        this._updatePaths();\n      }\n    },\n    _initPath: function (layer) {\n      this._updateDashArray(layer);\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function (layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function (layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n      this._requestRedraw(layer);\n    },\n    _updatePath: function (layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n      layer._project();\n      layer._update();\n      // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function (layer) {\n      this._updateDashArray(layer);\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function (layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n          dashArray = [],\n          dashValue,\n          i;\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]);\n          // Ignore dash array containing invalid lengths\n          if (isNaN(dashValue)) {\n            return;\n          }\n          dashArray.push(dashValue);\n        }\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function (layer) {\n      if (!this._map) {\n        return;\n      }\n      this._extendRedrawBounds(layer);\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function (layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function () {\n      this._redrawRequest = null;\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n        this._redrawBounds.max._ceil();\n      }\n      this._clear(); // clear layers in redraw bounds\n      this._draw(); // draw layers\n\n      this._redrawBounds = null;\n    },\n    _clear: function () {\n      var bounds = this._redrawBounds;\n      if (bounds) {\n        var size = bounds.getSize();\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.save();\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n        this._ctx.restore();\n      }\n    },\n    _draw: function () {\n      var layer,\n        bounds = this._redrawBounds;\n      this._ctx.save();\n      if (bounds) {\n        var size = bounds.getSize();\n        this._ctx.beginPath();\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n        this._ctx.clip();\n      }\n      this._drawing = true;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n      this._drawing = false;\n      this._ctx.restore(); // Restore state before clipping.\n    },\n    _updatePoly: function (layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n      var i,\n        j,\n        len2,\n        p,\n        parts = layer._parts,\n        len = parts.length,\n        ctx = this._ctx;\n      if (!len) {\n        return;\n      }\n      ctx.beginPath();\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n      this._fillStroke(ctx, layer);\n\n      // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n    },\n    _updateCircle: function (layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n      var p = layer._point,\n        ctx = this._ctx,\n        r = Math.max(Math.round(layer._radius), 1),\n        s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n      if (s !== 1) {\n        ctx.restore();\n      }\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function (ctx, layer) {\n      var options = layer.options;\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n    _onClick: function (e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n        layer,\n        clickedLayer;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          if (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {\n            clickedLayer = layer;\n          }\n        }\n      }\n      this._fireEvent(clickedLayer ? [clickedLayer] : false, e);\n    },\n    _onMouseMove: function (e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n      var point = this._map.mouseEventToLayerPoint(e);\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function (e) {\n      var layer = this._hoveredLayer;\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n        this._fireEvent([layer], e, 'mouseout');\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function (e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n      var layer, candidateHoveredLayer;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n      this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);\n      this._mouseHoverThrottled = true;\n      setTimeout(bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function (layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function (layer) {\n      var order = layer._order;\n      if (!order) {\n        return;\n      }\n      var next = order.next;\n      var prev = order.prev;\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function (layer) {\n      var order = layer._order;\n      if (!order) {\n        return;\n      }\n      var next = order.next;\n      var prev = order.prev;\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n      this._requestRedraw(layer);\n    }\n  });\n\n  // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n  function canvas(options) {\n    return Browser.canvas ? new Canvas(options) : null;\n  }\n\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      // Do not return fn from catch block so `e` can be garbage collected\n      // See https://github.com/Leaflet/Leaflet/pull/7279\n    }\n    return function (name) {\n      return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n    };\n  }();\n\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n  var vmlMixin = {\n    _initContainer: function () {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function () {\n      if (this._map._animatingZoom) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      this.fire('update');\n    },\n    _initPath: function (layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n      this._updateStyle(layer);\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      var container = layer._container;\n      this._container.appendChild(container);\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function (layer) {\n      var container = layer._container;\n      remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function (layer) {\n      var stroke = layer._stroke,\n        fill = layer._fill,\n        options = layer.options,\n        container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point.round(),\n        r = Math.round(layer._radius),\n        r2 = Math.round(layer._radiusY || r);\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function (layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function (layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._container);\n    }\n  };\n  var create = Browser.vml ? vmlCreate : svgCreate;\n\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    _initContainer: function () {\n      this._container = create('svg');\n\n      // makes it possible to click through svg root; we'll reset it back in individual paths\n      this._container.setAttribute('pointer-events', 'none');\n      this._rootGroup = create('g');\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function () {\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      var b = this._bounds,\n        size = b.getSize(),\n        container = this._container;\n\n      // set size of svg-container if changed\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      }\n\n      // movement: update container viewBox so that we don't have to change coordinates of individual layers\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n\n    _initPath: function (layer) {\n      var path = layer._path = create('path');\n\n      // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n      this._updateStyle(layer);\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n      this._rootGroup.appendChild(layer._path);\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function (layer) {\n      remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function (layer) {\n      layer._project();\n      layer._update();\n    },\n    _updateStyle: function (layer) {\n      var path = layer._path,\n        options = layer.options;\n      if (!path) {\n        return;\n      }\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function (layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point,\n        r = Math.max(Math.round(layer._radius), 1),\n        r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n        arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n      // drawing a circle with two half-arcs\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n      this._setPath(layer, d);\n    },\n    _setPath: function (layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function (layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._path);\n    }\n  });\n  if (Browser.vml) {\n    SVG.include(vmlMixin);\n  }\n\n  // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n  function svg(options) {\n    return Browser.svg || Browser.vml ? new SVG(options) : null;\n  }\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function (layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n      return renderer;\n    },\n    _getPaneRenderer: function (name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n      var renderer = this._paneRenderers[name];\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n      return renderer;\n    },\n    _createRenderer: function (options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas(options) || svg(options);\n    }\n  });\n\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function (latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function (latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function (latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  });\n\n  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n  SVG.create = create;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function (map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function () {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function () {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function () {\n      return this._moved;\n    },\n    _destroy: function () {\n      remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function () {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function () {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function (e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      }\n\n      // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n      this._clearDeferredResetState();\n      this._resetState();\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function (e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n        this._map.fire('boxzoomstart');\n      }\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n        size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function () {\n      if (this._moved) {\n        remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function (e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n      this._finish();\n      if (!this._moved) {\n        return;\n      }\n      // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n      this._clearDeferredResetState();\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function (e) {\n      if (e.keyCode === 27) {\n        this._finish();\n        this._clearDeferredResetState();\n        this._resetState();\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function () {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function () {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function (e) {\n      var map = this._map,\n        oldZoom = map.getZoom(),\n        delta = map.options.zoomDelta,\n        zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  });\n\n  // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map is draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default.\n    inertia: true,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second².\n    inertiaDeceleration: 3400,\n    // px/s^2\n\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function () {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n      this._draggable.enable();\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n      this._draggable.disable();\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function () {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function () {\n      var map = this._map;\n      map._stop();\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n      map.fire('movestart').fire('dragstart');\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function (e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n          pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n        this._positions.push(pos);\n        this._times.push(time);\n        this._prunePositions(time);\n      }\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function (time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function () {\n      var pxCenter = this._map.getSize().divideBy(2),\n        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function (value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function () {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n      var limit = this._offsetLimit;\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function () {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n        halfWidth = Math.round(worldWidth / 2),\n        dx = this._initialWorldOffset,\n        x = this._draggable._newPos.x,\n        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function (e) {\n      var map = this._map,\n        options = map.options,\n        noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n      map.fire('dragend', e);\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n        var direction = this._lastPos.subtract(this._positions[0]),\n          duration = (this._lastTime - this._times[0]) / 1000,\n          ease = options.easeLinearity,\n          speedVector = direction.multiplyBy(ease / duration),\n          speed = speedVector.distanceTo([0, 0]),\n          limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n          limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n          decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n          offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n  Map.addInitHook('addHandler', 'dragging', Drag);\n\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Keyboard Navigation Options\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function (map) {\n      this._map = map;\n      this._setPanDelta(map.options.keyboardPanDelta);\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function () {\n      var container = this._map._container;\n\n      // make the container focusable by tabbing\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function () {\n      this._removeHooks();\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function () {\n      if (this._focused) {\n        return;\n      }\n      var body = document.body,\n        docEl = document.documentElement,\n        top = body.scrollTop || docEl.scrollTop,\n        left = body.scrollLeft || docEl.scrollLeft;\n      this._map._container.focus();\n      window.scrollTo(left, top);\n    },\n    _onFocus: function () {\n      this._focused = true;\n      this._map.fire('focus');\n    },\n    _onBlur: function () {\n      this._focused = false;\n      this._map.fire('blur');\n    },\n    _setPanDelta: function (panDelta) {\n      var keys = this._panKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function (zoomDelta) {\n      var keys = this._zoomKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function () {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function () {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function (e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n      var key = e.keyCode,\n        map = this._map,\n        offset;\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n          if (map.options.maxBounds) {\n            offset = map._limitOffset(toPoint(offset), map.options.maxBounds);\n          }\n          if (map.options.worldCopyJump) {\n            var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));\n            map.panTo(newLatLng);\n          } else {\n            map.panBy(offset);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n      stop(e);\n    }\n  });\n\n  // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Mouse wheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'wheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function () {\n      off(this._map._container, 'wheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function (e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function () {\n      var map = this._map,\n        zoom = map.getZoom(),\n        snap = this._map.options.zoomSnap || 0;\n      map._stop(); // stop panning and fly animations if any\n\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n        d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n        d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n        delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n      if (!delta) {\n        return;\n      }\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n\n  /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */\n\n  var tapHoldDelay = 600;\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tapHold: Boolean\n    // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n    tapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var TapHold = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function () {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function (e) {\n      clearTimeout(this._holdTimeout);\n      if (e.touches.length !== 1) {\n        return;\n      }\n      var first = e.touches[0];\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY);\n      this._holdTimeout = setTimeout(bind(function () {\n        this._cancel();\n        if (!this._isTapValid()) {\n          return;\n        }\n\n        // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n        on(document, 'touchend', preventDefault);\n        on(document, 'touchend touchcancel', this._cancelClickPrevent);\n        this._simulateEvent('contextmenu', first);\n      }, this), tapHoldDelay);\n      on(document, 'touchend touchcancel contextmenu', this._cancel, this);\n      on(document, 'touchmove', this._onMove, this);\n    },\n    _cancelClickPrevent: function cancelClickPrevent() {\n      off(document, 'touchend', preventDefault);\n      off(document, 'touchend touchcancel', cancelClickPrevent);\n    },\n    _cancel: function () {\n      clearTimeout(this._holdTimeout);\n      off(document, 'touchend touchcancel contextmenu', this._cancel, this);\n      off(document, 'touchmove', this._onMove, this);\n    },\n    _onMove: function (e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n    },\n    _isTapValid: function () {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _simulateEvent: function (type, e) {\n      var simulatedEvent = new MouseEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        view: window,\n        // detail: 1,\n        screenX: e.screenX,\n        screenY: e.screenY,\n        clientX: e.clientX,\n        clientY: e.clientY\n        // button: 2,\n        // buttons: 2\n      });\n      simulatedEvent._simulated = true;\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  });\n\n  // @section Handlers\n  // @property tapHold: Handler\n  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n  Map.addInitHook('addHandler', 'tapHold', TapHold);\n\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers.\n    touchZoom: Browser.touch,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function () {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function (e) {\n      var map = this._map;\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n        p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n      map._stop();\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend touchcancel', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function (e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n      var map = this._map,\n        p1 = map.mouseEventToContainerPoint(e.touches[0]),\n        p2 = map.mouseEventToContainerPoint(e.touches[1]),\n        scale = p1.distanceTo(p2) / this._startDist;\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n      if (!this._moved) {\n        map._moveStart(true, false);\n        this._moved = true;\n      }\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      }, undefined);\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function () {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove, this);\n      off(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n      // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.TapHold = TapHold;\n  Map.TouchZoom = TouchZoom;\n  exports.Bounds = Bounds;\n  exports.Browser = Browser;\n  exports.CRS = CRS;\n  exports.Canvas = Canvas;\n  exports.Circle = Circle;\n  exports.CircleMarker = CircleMarker;\n  exports.Class = Class;\n  exports.Control = Control;\n  exports.DivIcon = DivIcon;\n  exports.DivOverlay = DivOverlay;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.Draggable = Draggable;\n  exports.Evented = Evented;\n  exports.FeatureGroup = FeatureGroup;\n  exports.GeoJSON = GeoJSON;\n  exports.GridLayer = GridLayer;\n  exports.Handler = Handler;\n  exports.Icon = Icon;\n  exports.ImageOverlay = ImageOverlay;\n  exports.LatLng = LatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.LineUtil = LineUtil;\n  exports.Map = Map;\n  exports.Marker = Marker;\n  exports.Mixin = Mixin;\n  exports.Path = Path;\n  exports.Point = Point;\n  exports.PolyUtil = PolyUtil;\n  exports.Polygon = Polygon;\n  exports.Polyline = Polyline;\n  exports.Popup = Popup;\n  exports.PosAnimation = PosAnimation;\n  exports.Projection = index;\n  exports.Rectangle = Rectangle;\n  exports.Renderer = Renderer;\n  exports.SVG = SVG;\n  exports.SVGOverlay = SVGOverlay;\n  exports.TileLayer = TileLayer;\n  exports.Tooltip = Tooltip;\n  exports.Transformation = Transformation;\n  exports.Util = Util;\n  exports.VideoOverlay = VideoOverlay;\n  exports.bind = bind;\n  exports.bounds = toBounds;\n  exports.canvas = canvas;\n  exports.circle = circle;\n  exports.circleMarker = circleMarker;\n  exports.control = control;\n  exports.divIcon = divIcon;\n  exports.extend = extend;\n  exports.featureGroup = featureGroup;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.gridLayer = gridLayer;\n  exports.icon = icon;\n  exports.imageOverlay = imageOverlay;\n  exports.latLng = toLatLng;\n  exports.latLngBounds = toLatLngBounds;\n  exports.layerGroup = layerGroup;\n  exports.map = createMap;\n  exports.marker = marker;\n  exports.point = toPoint;\n  exports.polygon = polygon;\n  exports.polyline = polyline;\n  exports.popup = popup;\n  exports.rectangle = rectangle;\n  exports.setOptions = setOptions;\n  exports.stamp = stamp;\n  exports.svg = svg;\n  exports.svgOverlay = svgOverlay;\n  exports.tileLayer = tileLayer;\n  exports.tooltip = tooltip;\n  exports.transformation = toTransformation;\n  exports.version = version;\n  exports.videoOverlay = videoOverlay;\n  var oldL = window.L;\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  };\n  // Always export us to window global (see #2364)\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxlQUFlO0VBRXJDcG1DLEdBQUcsQ0FBQzJtQyxJQUFJLEdBQUdBLElBQUk7RUFFZjNtQyxHQUFHLENBQUN5b0MsUUFBUSxHQUFHQSxRQUFRO0VBRXZCem9DLEdBQUcsQ0FBQ29xQyxlQUFlLEdBQUdBLGVBQWU7RUFFckNwcUMsR0FBRyxDQUFDaXJDLE9BQU8sR0FBR0EsT0FBTztFQUVyQmpyQyxHQUFHLENBQUNnc0MsU0FBUyxHQUFHQSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9jb3JlL1V0aWwuanM/MmU2NCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvcmUvQ2xhc3MuanM/MDFhYyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvcmUvRXZlbnRzLmpzPzEzNmYiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW9tZXRyeS9Qb2ludC5qcz8xNTQwIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvbWV0cnkvQm91bmRzLmpzPzFjNzkiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vTGF0TG5nQm91bmRzLmpzP2I1N2MiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vTGF0TG5nLmpzPzViNjQiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vY3JzL0NSUy5qcz9iMmNkIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanM/MTAxOSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IuanM/MWU1ZSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uLmpzP2MyNTMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzg1Ny5qcz9mMjJlIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5VdGlsLmpzPzkwYzEiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9jb3JlL0Jyb3dzZXIuanM/N2RlMyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2RvbS9Eb21FdmVudC5Qb2ludGVyLmpzPzg2NDQiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9kb20vRG9tRXZlbnQuRG91YmxlVGFwLmpzP2U3NmQiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9kb20vRG9tVXRpbC5qcz83YzkzIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZG9tL0RvbUV2ZW50LmpzPzFlYWMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9kb20vUG9zQW5pbWF0aW9uLmpzP2I2YjEiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9tYXAvTWFwLmpzPzczZWEiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9jb250cm9sL0NvbnRyb2wuanM/NTI5MSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5MYXllcnMuanM/NjRkNCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5ab29tLmpzPzE1NTAiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9jb250cm9sL0NvbnRyb2wuU2NhbGUuanM/OGM2NCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5BdHRyaWJ1dGlvbi5qcz8yY2Q3Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvY29udHJvbC9pbmRleC5qcz8wY2E4Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvY29yZS9IYW5kbGVyLmpzPzRlNWUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9jb3JlL2luZGV4LmpzP2UwZTAiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9kb20vRHJhZ2dhYmxlLmpzP2NjZWMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcz9kNTdlIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvbWV0cnkvTGluZVV0aWwuanM/MTg3YSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0LmpzPzlkODUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yLmpzP2IyYmMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vcHJvamVjdGlvbi9pbmRleC5qcz9mZGE4Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzMzOTUuanM/MGMzYiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0c0MzI2LmpzP2Q5ODMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vY3JzL0NSUy5TaW1wbGUuanM/OWJlOCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9jcnMvaW5kZXguanM/NjZkOSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL0xheWVyLmpzPzY3MDMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9MYXllckdyb3VwLmpzPzdmNjQiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9GZWF0dXJlR3JvdXAuanM/MjQ0YSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL21hcmtlci9JY29uLmpzPzA1ODgiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9tYXJrZXIvSWNvbi5EZWZhdWx0LmpzPzI3ZTciLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9tYXJrZXIvTWFya2VyLkRyYWcuanM/MmZiNSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanM/M2RkMiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9QYXRoLmpzP2Y2NmEiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlTWFya2VyLmpzPzI0OGYiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlLmpzPzlkMWEiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci92ZWN0b3IvUG9seWxpbmUuanM/OWMzNyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5Z29uLmpzPzI3MjciLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9HZW9KU09OLmpzP2FhZWEiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9JbWFnZU92ZXJsYXkuanM/MDE4OSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL1ZpZGVvT3ZlcmxheS5qcz8wM2U4Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvU1ZHT3ZlcmxheS5qcz8zY2YzIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvRGl2T3ZlcmxheS5qcz8wMDIzIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvUG9wdXAuanM/OGUxMSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL1Rvb2x0aXAuanM/MGRiMiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL21hcmtlci9EaXZJY29uLmpzP2UwZGUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9tYXJrZXIvaW5kZXguanM/OGYzOCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3RpbGUvR3JpZExheWVyLmpzPzM4OGUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5qcz8yNjIwIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzP2Y5ZTYiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci90aWxlL2luZGV4LmpzPzQyOGMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci92ZWN0b3IvUmVuZGVyZXIuanM/MTBlZSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9DYW52YXMuanM/YjllYiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuVk1MLmpzP2M5MzQiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLmpzP2Y4NGIiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci92ZWN0b3IvUmVuZGVyZXIuZ2V0UmVuZGVyZXIuanM/NWZhNyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9SZWN0YW5nbGUuanM/MGQ3YSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9pbmRleC5qcz8xZTEzIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvaW5kZXguanM/MTIyMiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Cb3hab29tLmpzP2U5Y2MiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuRG91YmxlQ2xpY2tab29tLmpzPzAyZDUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuRHJhZy5qcz9iY2QwIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLktleWJvYXJkLmpzPzNmM2IiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tLmpzPzFmMTQiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuVGFwSG9sZC5qcz9jMGJmIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLlRvdWNoWm9vbS5qcz9mNjZhIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbWFwL2luZGV4LmpzPzIwNTIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuZXhwb3J0IHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5leHBvcnQgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHRpZiAoISgnX2xlYWZsZXRfaWQnIGluIG9iaikpIHtcclxuXHRcdG9ialsnX2xlYWZsZXRfaWQnXSA9ICsrbGFzdElkO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHdpdGggc3BlY2lmaWVkIGBwcmVjaXNpb25gLlxyXG4vLyBUaGUgZGVmYXVsdCBgcHJlY2lzaW9uYCB2YWx1ZSBpcyA2IGRlY2ltYWwgcGxhY2VzLlxyXG4vLyBgZmFsc2VgIGNhbiBiZSBwYXNzZWQgdG8gc2tpcCBhbnkgcHJvY2Vzc2luZyAoY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCByb3VuZC1vZmYgZXJyb3JzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIHByZWNpc2lvbikge1xyXG5cdGlmIChwcmVjaXNpb24gPT09IGZhbHNlKSB7IHJldHVybiBudW07IH1cclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNiA6IHByZWNpc2lvbik7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKHN0cikge1xyXG5cdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbi8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcblx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcblx0aWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfIC1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5leHBvcnQgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwczovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbmZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxufVxyXG5cclxudmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG5leHBvcnQgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuLy8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG4vLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbi8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbi8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcblx0aWYgKGlkKSB7XHJcblx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vLyBAY2xhc3MgQ2xhc3NcclxuLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcblx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcblx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzKTtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpICYmIGkgIT09ICdwcm90b3R5cGUnICYmIGkgIT09ICdfX3N1cGVyX18nKSB7XHJcblx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcblx0XHRVdGlsLmV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRVdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0VXRpbC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHRkZWxldGUgcHJvdG8uc3RhdGljcztcclxuXHRkZWxldGUgcHJvdG8uaW5jbHVkZXM7XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvdG8ub3B0aW9ucyA9IHBhcmVudFByb3RvLm9wdGlvbnMgPyBVdGlsLmNyZWF0ZShwYXJlbnRQcm90by5vcHRpb25zKSA6IHt9O1xyXG5cdFx0VXRpbC5leHRlbmQocHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcblx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4vLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0dmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLnByb3RvdHlwZS5vcHRpb25zO1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0aWYgKHByb3BzLm9wdGlvbnMpIHtcclxuXHRcdHRoaXMucHJvdG90eXBlLm9wdGlvbnMgPSBwYXJlbnRPcHRpb25zO1xyXG5cdFx0dGhpcy5tZXJnZU9wdGlvbnMocHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0LyogZ2xvYmFsIEw6IHRydWUgKi9cclxuXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IFV0aWwuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFdmVudHMgPSB7XHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHR2YXIgcmVtb3ZlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHJlbW92ZUFsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQsIF9vbmNlKSB7XHJcblx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRpZiAodGhpcy5fbGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCkgIT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fTtcclxuXHRcdGlmIChfb25jZSkge1xyXG5cdFx0XHRuZXdMaXN0ZW5lci5vbmNlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcblx0XHR0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgLy8gcmVtb3ZlIGFsbFxyXG5cdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3BcclxuXHRcdFx0XHQvLyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0KTtcclxuXHRcdGlmIChpbmRleCAhPT0gZmFsc2UpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2luZGV4XTtcclxuXHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcblx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdGxpc3RlbmVyLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhIGRhdGFcclxuXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG5cdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudCA9IFV0aWwuZXh0ZW5kKHt9LCBkYXRhLCB7XHJcblx0XHRcdHR5cGU6IHR5cGUsXHJcblx0XHRcdHRhcmdldDogdGhpcyxcclxuXHRcdFx0c291cmNlVGFyZ2V0OiBkYXRhICYmIGRhdGEuc291cmNlVGFyZ2V0IHx8IHRoaXNcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdC8vIG9mZiBvdmVyd3JpdGVzIGwuZm4sIHNvIHdlIG5lZWQgdG8gY29weSBmbiB0byBhIHZhclxyXG5cdFx0XHRcdFx0dmFyIGZuID0gbC5mbjtcclxuXHRcdFx0XHRcdGlmIChsLm9uY2UpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5vZmYodHlwZSwgZm4sIGwuY3R4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdC8vIFRoZSB2ZXJpZmljYXRpb24gY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCwgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHBhcmVudHMgaGF2ZSB0aGUgbGlzdGVuZXIgYXR0YWNoZWQgdG8gaXQuXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdcInN0cmluZ1wiIHR5cGUgYXJndW1lbnQgZXhwZWN0ZWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB3ZSBkb24ndCBvdmVyd3JpdGUgdGhlIGlucHV0IGBmbmAgdmFsdWUsIGJlY2F1c2Ugd2UgbmVlZCB0byB1c2UgaXQgZm9yIHByb3BhZ2F0aW9uXHJcblx0XHR2YXIgX2ZuID0gZm47XHJcblx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHByb3BhZ2F0ZSA9ICEhZm47XHJcblx0XHRcdF9mbiA9IHVuZGVmaW5lZDtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAodGhpcy5fbGlzdGVucyh0eXBlLCBfZm4sIGNvbnRleHQpICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgdGhlIGluZGV4IChudW1iZXIpIG9yIGZhbHNlXHJcblx0X2xpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcblx0XHRpZiAoIWZuKSB7XHJcblx0XHRcdHJldHVybiAhIWxpc3RlbmVycy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4sIHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV0gPSBvYmo7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG5cdFx0XHRcdHByb3BhZ2F0ZWRGcm9tOiBlLnRhcmdldFxyXG5cdFx0XHR9LCBlKSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbi8vIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKVxyXG5FdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbi8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4vLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5FdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gRXZlbnRzLm9mZjtcclxuXHJcbi8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbkV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbmNlO1xyXG5cclxuLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbkV2ZW50cy5maXJlRXZlbnQgPSBFdmVudHMuZmlyZTtcclxuXHJcbi8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4vLyBBbGlhcyB0byBbYGxpc3RlbnMo4oCmKWBdKCNldmVudGVkLWxpc3RlbnMpXHJcbkV2ZW50cy5oYXNFdmVudExpc3RlbmVycyA9IEV2ZW50cy5saXN0ZW5zO1xyXG5cclxuZXhwb3J0IHZhciBFdmVudGVkID0gQ2xhc3MuZXh0ZW5kKEV2ZW50cyk7XHJcbiIsImltcG9ydCB7aXNBcnJheSwgZm9ybWF0TnVtfSBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvaW50XHJcbiAqIEBha2EgTC5Qb2ludFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcbnZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcblx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcblx0fSxcclxuXHJcblx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluMiwgbWF4MjtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIFBvaW50IHx8IHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8ICd4JyBpbiBvYmopIHtcclxuXHRcdFx0bWluMiA9IG1heDIgPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0XHRtaW4yID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4MiA9IG9iai5tYXg7XHJcblxyXG5cdFx0XHRpZiAoIW1pbjIgfHwgIW1heDIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IG1pbjIuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBtYXgyLmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4obWluMi54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KG1heDIueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihtaW4yLnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgobWF4Mi55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiB0b1BvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdG1heCA9IHRoaXMubWF4LFxyXG5cdFx0aGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMobWluLnggLSBtYXgueCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdHdpZHRoQnVmZmVyID0gTWF0aC5hYnMobWluLnkgLSBtYXgueSkgKiBidWZmZXJSYXRpbztcclxuXHJcblxyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFxyXG5cdFx0XHR0b1BvaW50KG1pbi54IC0gaGVpZ2h0QnVmZmVyLCBtaW4ueSAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdFx0dG9Qb2ludChtYXgueCArIGhlaWdodEJ1ZmZlciwgbWF4LnkgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5taW4uZXF1YWxzKGJvdW5kcy5nZXRUb3BMZWZ0KCkpICYmXHJcblx0XHRcdHRoaXMubWF4LmVxdWFscyhib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKSk7XHJcblx0fSxcclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuL0xhdExuZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vY3JzL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwYXRpYWxfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IFV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbmV4cG9ydCB2YXIgRWFydGggPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwczovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcblx0XHQgICAgc2luRExvbiA9IE1hdGguc2luKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCAvIDIpLFxuXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG5cdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuXHRcdHJldHVybiB0aGlzLlIgKiBjO1xuXHR9XG59KTtcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxudmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbmV4cG9ydCB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IGVhcnRoUmFkaXVzLFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzM4NTcgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIFNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5leHBvcnQgdmFyIEVQU0c5MDA5MTMgPSBVdGlsLmV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG4iLCJpbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbi8vIEBmdW5jdGlvbiBjcmVhdGUobmFtZTogU3RyaW5nKTogU1ZHRWxlbWVudFxuLy8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG4vLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuLy8gYW4gaW5zdGFuY2Ugb2YgW1NWR0xpbmVFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHTGluZUVsZW1lbnQpLlxuZXhwb3J0IGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuLy8gR2VuZXJhdGVzIGEgU1ZHIHBhdGggc3RyaW5nIGZvciBtdWx0aXBsZSByaW5ncywgd2l0aCBlYWNoIHJpbmcgdHVybmluZ1xuLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG5cdHZhciBzdHIgPSAnJyxcblx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRwID0gcG9pbnRzW2pdO1xuXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHR9XG5cblx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG5cdFx0c3RyICs9IGNsb3NlZCA/IChCcm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0fVxuXG5cdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdHJldHVybiBzdHIgfHwgJ00wIDAnO1xufVxuXG5cblxuXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcbmltcG9ydCB7c3ZnQ3JlYXRlfSBmcm9tICcuLi9sYXllci92ZWN0b3IvU1ZHLlV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG52YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuLy8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG52YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG52YXIgZWRnZSA9ICdtc0xhdW5jaFVyaScgaW4gbmF2aWdhdG9yICYmICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbnZhciB3ZWJraXQgPSB1c2VyQWdlbnRDb250YWlucygnd2Via2l0Jyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4vLyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbnZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxudmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG52YXIgYW5kcm9pZFN0b2NrID0gYW5kcm9pZCAmJiB1c2VyQWdlbnRDb250YWlucygnR29vZ2xlJykgJiYgd2Via2l0VmVyIDwgNTM3ICYmICEoJ0F1ZGlvTm9kZScgaW4gd2luZG93KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG52YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG52YXIgY2hyb21lID0gIWVkZ2UgJiYgdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxudmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbnZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbnZhciBwaGFudG9tID0gdXNlckFnZW50Q29udGFpbnMoJ3BoYW50b20nKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbnZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbnZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIHN0eWxlKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgbW9iaWxlV2Via2l0M2QgPSBtb2JpbGUgJiYgd2Via2l0M2Q7XHJcblxyXG4vLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG52YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG52YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaE5hdGl2ZTogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyAqKlRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbioqIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4vLyB0b3VjaCBldmVudHMuXHJcbnZhciB0b3VjaE5hdGl2ZSA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCAhIXdpbmRvdy5Ub3VjaEV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgZWl0aGVyIFt0b3VjaF0oI2Jyb3dzZXItdG91Y2gpIG9yIFtwb2ludGVyXSgjYnJvd3Nlci1wb2ludGVyKSBldmVudHMuXHJcbi8vIE5vdGU6IHBvaW50ZXIgZXZlbnRzIHdpbGwgYmUgcHJlZmVycmVkIChpZiBhdmFpbGFibGUpLCBhbmQgcHJvY2Vzc2VkIGZvciBhbGwgYHRvdWNoKmAgbGlzdGVuZXJzLlxyXG52YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHRvdWNoTmF0aXZlIHx8IHBvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbi8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxudmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwYXNzaXZlRXZlbnRzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG52YXIgcGFzc2l2ZUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdldHRlci1yZXR1cm5cclxuXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIEVycm9ycyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgc2luY2UgdGhpcyBpcyBvbmx5IGEgYnJvd3NlciBzdXBwb3J0IHRlc3QuXHJcblx0fVxyXG5cdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbnZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbnZhciBzdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbnZhciBpbmxpbmVTdmcgPSAhIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRkaXYuaW5uZXJIVE1MID0gJzxzdmcvPic7XHJcblx0cmV0dXJuIChkaXYuZmlyc3RDaGlsZCAmJiBkaXYuZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkkpID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG59KSgpO1xyXG5cclxuLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbnZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBNYWMgcGxhdGZvcm1cclxudmFyIG1hYyA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdNYWMnKSA9PT0gMDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBMaW51eCBwbGF0Zm9ybVxyXG52YXIgbGludXggPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTGludXgnKSA9PT0gMDtcclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aWU6IGllLFxyXG5cdGllbHQ5OiBpZWx0OSxcclxuXHRlZGdlOiBlZGdlLFxyXG5cdHdlYmtpdDogd2Via2l0LFxyXG5cdGFuZHJvaWQ6IGFuZHJvaWQsXHJcblx0YW5kcm9pZDIzOiBhbmRyb2lkMjMsXHJcblx0YW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXHJcblx0b3BlcmE6IG9wZXJhLFxyXG5cdGNocm9tZTogY2hyb21lLFxyXG5cdGdlY2tvOiBnZWNrbyxcclxuXHRzYWZhcmk6IHNhZmFyaSxcclxuXHRwaGFudG9tOiBwaGFudG9tLFxyXG5cdG9wZXJhMTI6IG9wZXJhMTIsXHJcblx0d2luOiB3aW4sXHJcblx0aWUzZDogaWUzZCxcclxuXHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblx0Z2Vja28zZDogZ2Vja28zZCxcclxuXHRhbnkzZDogYW55M2QsXHJcblx0bW9iaWxlOiBtb2JpbGUsXHJcblx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXHJcblx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZVdlYmtpdDNkLFxyXG5cdG1zUG9pbnRlcjogbXNQb2ludGVyLFxyXG5cdHBvaW50ZXI6IHBvaW50ZXIsXHJcblx0dG91Y2g6IHRvdWNoLFxyXG5cdHRvdWNoTmF0aXZlOiB0b3VjaE5hdGl2ZSxcclxuXHRtb2JpbGVPcGVyYTogbW9iaWxlT3BlcmEsXHJcblx0bW9iaWxlR2Vja286IG1vYmlsZUdlY2tvLFxyXG5cdHJldGluYTogcmV0aW5hLFxyXG5cdHBhc3NpdmVFdmVudHM6IHBhc3NpdmVFdmVudHMsXHJcblx0Y2FudmFzOiBjYW52YXMsXHJcblx0c3ZnOiBzdmcsXHJcblx0dm1sOiB2bWwsXHJcblx0aW5saW5lU3ZnOiBpbmxpbmVTdmcsXHJcblx0bWFjOiBtYWMsXHJcblx0bGludXg6IGxpbnV4XHJcbn07XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7ZmFsc2VGbn0gZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbnZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbnZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG52YXIgcEV2ZW50ID0ge1xuXHR0b3VjaHN0YXJ0ICA6IFBPSU5URVJfRE9XTixcblx0dG91Y2htb3ZlICAgOiBQT0lOVEVSX01PVkUsXG5cdHRvdWNoZW5kICAgIDogUE9JTlRFUl9VUCxcblx0dG91Y2hjYW5jZWwgOiBQT0lOVEVSX0NBTkNFTFxufTtcbnZhciBoYW5kbGUgPSB7XG5cdHRvdWNoc3RhcnQgIDogX29uUG9pbnRlclN0YXJ0LFxuXHR0b3VjaG1vdmUgICA6IF9oYW5kbGVQb2ludGVyLFxuXHR0b3VjaGVuZCAgICA6IF9oYW5kbGVQb2ludGVyLFxuXHR0b3VjaGNhbmNlbCA6IF9oYW5kbGVQb2ludGVyXG59O1xudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuLy8gcmVmIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCk7XG5cdH1cblx0aWYgKCFoYW5kbGVbdHlwZV0pIHtcblx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcblx0XHRyZXR1cm4gZmFsc2VGbjtcblx0fVxuXHRoYW5kbGVyID0gaGFuZGxlW3R5cGVdLmJpbmQodGhpcywgaGFuZGxlcik7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKHBFdmVudFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xuXHRyZXR1cm4gaGFuZGxlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpIHtcblx0aWYgKCFwRXZlbnRbdHlwZV0pIHtcblx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcblx0XHRyZXR1cm47XG5cdH1cblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG5cdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJEb2NMaXN0ZW5lcigpIHtcblx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG5cdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSkge1xuXHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gKGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgJ21vdXNlJykpIHsgcmV0dXJuOyB9XG5cblx0ZS50b3VjaGVzID0gW107XG5cdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG5cdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcblx0fVxuXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdGhhbmRsZXIoZSk7XG59XG5cbmZ1bmN0aW9uIF9vblBvaW50ZXJTdGFydChoYW5kbGVyLCBlKSB7XG5cdC8vIElFMTAgc3BlY2lmaWM6IE1zVG91Y2ggbmVlZHMgcHJldmVudERlZmF1bHQuIFNlZSAjMjAwMFxuXHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH1cblx0X2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSk7XG59XG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICpcclxuICogTm90ZTogY3VycmVudGx5IG1vc3QgYnJvd3NlcnMgZmlyZSBuYXRpdmUgZGJsY2xpY2ssIHdpdGggb25seSBhIGZldyBleGNlcHRpb25zXHJcbiAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNzAxMiNpc3N1ZWNvbW1lbnQtNTk1MDg3Mzg2KVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1ha2VEYmxjbGljayhldmVudCkge1xyXG5cdC8vIGluIG1vZGVybiBicm93c2VycyBgdHlwZWAgY2Fubm90IGJlIGp1c3Qgb3ZlcnJpZGRlbjpcclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHlcclxuXHR2YXIgbmV3RXZlbnQgPSB7fSxcclxuXHQgICAgcHJvcCwgaTtcclxuXHRmb3IgKGkgaW4gZXZlbnQpIHtcclxuXHRcdHByb3AgPSBldmVudFtpXTtcclxuXHRcdG5ld0V2ZW50W2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQoZXZlbnQpIDogcHJvcDtcclxuXHR9XHJcblx0ZXZlbnQgPSBuZXdFdmVudDtcclxuXHRuZXdFdmVudC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRuZXdFdmVudC5kZXRhaWwgPSAyO1xyXG5cdG5ld0V2ZW50LmlzVHJ1c3RlZCA9IGZhbHNlO1xyXG5cdG5ld0V2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlOyAvLyBmb3IgZGVidWcgcHVycG9zZXNcclxuXHRyZXR1cm4gbmV3RXZlbnQ7XHJcbn1cclxuXHJcbnZhciBkZWxheSA9IDIwMDtcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcikge1xyXG5cdC8vIE1vc3QgYnJvd3NlcnMgaGFuZGxlIGRvdWJsZSB0YXAgbmF0aXZlbHlcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIG5hdGl2ZSBkYmxjbGlja3MgZm9yIHRvdWNoIGV2ZW50cy5cclxuXHQvLyBJdCBzZWVtcyB0aGF0IGluIGFsbCBzdWNoIGNhc2VzIGBkZXRhaWxgIHByb3BlcnR5IG9mIGBjbGlja2AgZXZlbnQgaXMgYWx3YXlzIGAxYC5cclxuXHQvLyBTbyBoZXJlIHdlIHJlbHkgb24gdGhhdCBmYWN0IHRvIGF2b2lkIGV4Y2Vzc2l2ZSAnZGJsY2xpY2snIHNpbXVsYXRpb24gd2hlbiBub3QgbmVlZGVkLlxyXG5cdHZhciBsYXN0ID0gMCxcclxuXHQgICAgZGV0YWlsO1xyXG5cdGZ1bmN0aW9uIHNpbURibGNsaWNrKGUpIHtcclxuXHRcdGlmIChlLmRldGFpbCAhPT0gMSkge1xyXG5cdFx0XHRkZXRhaWwgPSBlLmRldGFpbDsgLy8ga2VlcCBpbiBzeW5jIHRvIGF2b2lkIGZhbHNlIGRibGNsaWNrIGluIHNvbWUgY2FzZXNcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XHJcblx0XHRcdChlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiAhZS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykpIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXaGVuIGNsaWNraW5nIG9uIGFuIDxpbnB1dD4sIHRoZSBicm93c2VyIGdlbmVyYXRlcyBhIGNsaWNrIG9uIGl0c1xyXG5cdFx0Ly8gPGxhYmVsPiAoYW5kIHZpY2UgdmVyc2EpIHRyaWdnZXJpbmcgdHdvIGNsaWNrcyBpbiBxdWljayBzdWNjZXNzaW9uLlxyXG5cdFx0Ly8gVGhpcyBpZ25vcmVzIGNsaWNrcyBvbiBlbGVtZW50cyB3aGljaCBhcmUgYSBsYWJlbCB3aXRoIGEgJ2ZvcidcclxuXHRcdC8vIGF0dHJpYnV0ZSAob3IgY2hpbGRyZW4gb2Ygc3VjaCBhIGxhYmVsKSwgYnV0IG5vdCBjaGlsZHJlbiBvZlxyXG5cdFx0Ly8gYSA8aW5wdXQ+LlxyXG5cdFx0dmFyIHBhdGggPSBEb21FdmVudC5nZXRQcm9wYWdhdGlvblBhdGgoZSk7XHJcblx0XHRpZiAocGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0XHRyZXR1cm4gZWwgaW5zdGFuY2VvZiBIVE1MTGFiZWxFbGVtZW50ICYmIGVsLmF0dHJpYnV0ZXMuZm9yO1xyXG5cdFx0fSkgJiZcclxuXHRcdFx0IXBhdGguc29tZShmdW5jdGlvbiAoZWwpIHtcclxuXHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0ZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8XHJcblx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50XHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSlcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCk7XHJcblx0XHRpZiAobm93IC0gbGFzdCA8PSBkZWxheSkge1xyXG5cdFx0XHRkZXRhaWwrKztcclxuXHRcdFx0aWYgKGRldGFpbCA9PT0gMikge1xyXG5cdFx0XHRcdGhhbmRsZXIobWFrZURibGNsaWNrKGUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGV0YWlsID0gMTtcclxuXHRcdH1cclxuXHRcdGxhc3QgPSBub3c7XHJcblx0fVxyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaW1EYmxjbGljayk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRkYmxjbGljazogaGFuZGxlcixcclxuXHRcdHNpbURibGNsaWNrOiBzaW1EYmxjbGlja1xyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXJzKSB7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcnMuZGJsY2xpY2spO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXJzLnNpbURibGNsaWNrKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5leHBvcnQgdmFyIFRSQU5TRk9STSA9IHRlc3RQcm9wKFxyXG5cdFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbi8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG5cdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OX0VORCA9XHJcblx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbi8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXQoaWQpIHtcclxuXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbi8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG5cdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0aWYgKGNvbnRhaW5lcikge1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcblx0cmV0dXJuIGVsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50KSB7XHJcblx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHR9XHJcblx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHZhciBjbGFzc2VzID0gVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHNldENsYXNzKGVsLCBVdGlsLnRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG5cdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuXHRpZiAoZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcclxuXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcblx0fVxyXG5cdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4vLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHR0cnkge1xyXG5cdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHR9XHJcblxyXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdGlmIChmaWx0ZXIpIHtcclxuXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4vLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4vLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4vLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuXHRcdChCcm93c2VyLmllM2QgP1xyXG5cdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcblx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdGlmIChCcm93c2VyLmFueTNkKSB7XHJcblx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG5cdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcblx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcblx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbi8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcbi8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IHZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcclxuZXhwb3J0IHZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG52YXIgX3VzZXJTZWxlY3Q7XHJcbmlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG59IGVsc2Uge1xyXG5cdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChcclxuXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcblx0XHR9XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbi8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuLy8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbnZhciBfb3V0bGluZUVsZW1lbnQsIF9vdXRsaW5lU3R5bGU7XHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbi8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbi8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xyXG5cdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdHJlc3RvcmVPdXRsaW5lKCk7XHJcblx0X291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSBfb3V0bGluZVN0eWxlO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuXHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsZW1lbnQpIHtcclxuXHRkbyB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH0gd2hpbGUgKCghZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZWxlbWVudC5vZmZzZXRIZWlnaHQpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpO1xyXG5cdHJldHVybiBlbGVtZW50O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2NhbGUoZWw6IEhUTUxFbGVtZW50KTogT2JqZWN0XHJcbi8vIENvbXB1dGVzIHRoZSBDU1Mgc2NhbGUgY3VycmVudGx5IGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxyXG4vLyBhbmQgYGJvdW5kaW5nQ2xpZW50UmVjdGAgYXMgdGhlIHJlc3VsdCBvZiBbYGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0KS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuXHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFJlYWQtb25seSBpbiBvbGQgYnJvd3NlcnMuXHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG5cdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxyXG5cdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcblx0fTtcclxufVxyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHthZGRQb2ludGVyTGlzdGVuZXIsIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuaW1wb3J0IHthZGREb3VibGVUYXBMaXN0ZW5lciwgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuRG91YmxlVGFwJztcclxuaW1wb3J0IHtnZXRTY2FsZX0gZnJvbSAnLi9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4vLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbi8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nKTogdGhpc1xyXG4vLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBvZiBnaXZlbiB0eXBlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgZnJvbSBnaXZlbiBIVE1MRWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRiYXRjaFJlbW92ZShvYmopO1xyXG5cdFx0ZGVsZXRlIG9ialtldmVudHNLZXldO1xyXG5cclxuXHR9IGVsc2UgaWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRiYXRjaFJlbW92ZShvYmosIGZ1bmN0aW9uICh0eXBlKSB7XHJcblx0XHRcdFx0cmV0dXJuIFV0aWwuaW5kZXhPZih0eXBlcywgdHlwZSkgIT09IC0xO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiYXRjaFJlbW92ZShvYmosIGZpbHRlckZuKSB7XHJcblx0Zm9yICh2YXIgaWQgaW4gb2JqW2V2ZW50c0tleV0pIHtcclxuXHRcdHZhciB0eXBlID0gaWQuc3BsaXQoL1xcZC8pWzBdO1xyXG5cdFx0aWYgKCFmaWx0ZXJGbiB8fCBmaWx0ZXJGbih0eXBlKSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCBudWxsLCBudWxsLCBpZCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG52YXIgbW91c2VTdWJzdCA9IHtcclxuXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcclxuXHRtb3VzZWxlYXZlOiAnbW91c2VvdXQnLFxyXG5cdHdoZWVsOiAhKCdvbndoZWVsJyBpbiB3aW5kb3cpICYmICdtb3VzZXdoZWVsJ1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGhhbmRsZXIgPSBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG5cdFx0aGFuZGxlciA9IGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3doZWVsJyB8fCAgdHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvcmlnaW5hbEhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0LCBpZCkge1xyXG5cdGlkID0gaWQgfHwgdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cdHZhciBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcblx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbi8vIGBgYGpzXHJcbi8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbi8vIH0pO1xyXG4vLyBgYGBcclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG5cdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCd3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG5cdGFkZE9uZShlbCwgJ3doZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkYmxjbGljaydgLCBgJ2NvbnRleHRtZW51J2AsXHJcbi8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcblx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljayBjb250ZXh0bWVudScsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0ZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSA9IHRydWU7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4vLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4vLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3AoZSkge1xyXG5cdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldjogRE9NRXZlbnQpOiBBcnJheVxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbYEV2ZW50LmNvbXBvc2VkUGF0aCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50L2NvbXBvc2VkUGF0aCkuXHJcbi8vIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYEhUTUxFbGVtZW50YHMgdGhhdCB0aGUgZ2l2ZW4gRE9NIGV2ZW50XHJcbi8vIHNob3VsZCBwcm9wYWdhdGUgdG8gKGlmIG5vdCBzdG9wcGVkKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldikge1xyXG5cdGlmIChldi5jb21wb3NlZFBhdGgpIHtcclxuXHRcdHJldHVybiBldi5jb21wb3NlZFBhdGgoKTtcclxuXHR9XHJcblxyXG5cdHZhciBwYXRoID0gW107XHJcblx0dmFyIGVsID0gZXYudGFyZ2V0O1xyXG5cclxuXHR3aGlsZSAoZWwpIHtcclxuXHRcdHBhdGgucHVzaChlbCk7XHJcblx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdHJldHVybiBwYXRoO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4vLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuXHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0fVxyXG5cclxuXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG5cdCAgICBvZmZzZXQgPSBzY2FsZS5ib3VuZGluZ0NsaWVudFJlY3Q7IC8vIGxlZnQgYW5kIHRvcCAgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIHRoZSBldmVudCBjbGllbnRYL1kpXHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcblx0XHQvLyB3aGVyZWFzIGNsaWVudExlZnQvVG9wIChib3JkZXIgd2lkdGgpIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyAoYmVmb3JlIENTUyBzY2FsZSBhcHBsaWVzKS5cclxuXHRcdChlLmNsaWVudFggLSBvZmZzZXQubGVmdCkgLyBzY2FsZS54IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG5cdCk7XHJcbn1cclxuXHJcblxyXG4vLyAgZXhjZXB0ICwgU2FmYXJpIGFuZFxyXG4vLyBXZSBuZWVkIGRvdWJsZSB0aGUgc2Nyb2xsIHBpeGVscyAoc2VlICM3NDAzIGFuZCAjNDUzOCkgZm9yIGFsbCBCcm93c2Vyc1xyXG4vLyBleGNlcHQgT1NYIChNYWMpIC0+IDN4LCBDaHJvbWUgcnVubmluZyBvbiBMaW51eCAxeFxyXG5cclxudmFyIHdoZWVsUHhGYWN0b3IgPVxyXG5cdChCcm93c2VyLmxpbnV4ICYmIEJyb3dzZXIuY2hyb21lKSA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRCcm93c2VyLm1hYyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogMyA6XHJcblx0d2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAwID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgd2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4vLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xyXG5cdHJldHVybiAoQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcblx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdCAgICAgICAwO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcclxuXHJcblx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHR0cnkge1xyXG5cdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9uYF0oI2RvbWV2ZW50LW9uKVxyXG5leHBvcnQge29uIGFzIGFkZExpc3RlbmVyfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vZmZgXSgjZG9tZXZlbnQtb2ZmKVxyXG5leHBvcnQge29mZiBhcyByZW1vdmVMaXN0ZW5lcn07XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlQb3NpdGlvbk1hcmtlciA9IEwubWFya2VyKFs0OC44NjQ3MTYsIDIuMjk0Njk0XSkuYWRkVG8obWFwKTtcbiAqXG4gKiBteVBvc2l0aW9uTWFya2VyLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gKiBcdHZhciBwb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KG15UG9zaXRpb25NYXJrZXIuZ2V0TGF0TG5nKCkpO1xuICogXHRwb3MueSAtPSAyNTtcbiAqIFx0dmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKlxuICogXHRmeC5vbmNlKCdlbmQnLGZ1bmN0aW9uKCkge1xuICogXHRcdHBvcy55ICs9IDI1O1xuICogXHRcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuOCk7XG4gKiBcdH0pO1xuICpcbiAqIFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC4zKTtcbiAqIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cHM6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IHtFUFNHMzg1N30gZnJvbSAnLi4vZ2VvL2Nycy9DUlMuRVBTRzM4NTcnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7Qm91bmRzLCB0b0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuLi9kb20vUG9zQW5pbWF0aW9uJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcblx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRvIGFzc2lnbiBpbnRlcm5hbCBmbGFncyBhdCB0aGUgYmVnaW5uaW5nLFxyXG5cdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gVXRpbC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcodG9MYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gRG9tVXRpbC5UUkFOU0lUSU9OICYmIEJyb3dzZXIuYW55M2QgJiYgIUJyb3dzZXIubW9iaWxlT3BlcmEgJiZcclxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuXHRcdFx0RG9tRXZlbnQub24odGhpcy5fcHJveHksIERvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuXHRcdFx0XHRvcHRpb25zLnBhbiA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXHJcblx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xyXG5cclxuXHRcdFx0aWYgKG1vdmVkKSB7XHJcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20sIG9wdGlvbnMucGFuICYmIG9wdGlvbnMucGFuLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG5cdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG5cdFx0ICAgIHJobyA9IDEuNDIsXHJcblx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcblx0XHRmdW5jdGlvbiByKGkpIHtcclxuXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcblx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvZztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG5cdFx0dmFyIHIwID0gcigwKTtcclxuXHJcblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG5cdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG5cdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcblx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcblx0XHRcdGlmICh0IDw9IDEpIHtcclxuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5saXN0ZW5zKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSkge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogcGFkZGluZyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcblx0Ly8gcGFkZGluZyBvcHRpb25zIHRvIGZpdCB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLlxyXG5cdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG5cdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG5cdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pLFxyXG5cdFx0ICAgIHBhZGRlZFNpemUgPSBwYWRkZWRCb3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHRcdHZhciBjZW50ZXJPZmZzZXQgPSBwaXhlbFBvaW50LnN1YnRyYWN0KHBhZGRlZEJvdW5kcy5nZXRDZW50ZXIoKSk7XHJcblx0XHRcdHZhciBvZmZzZXQgPSBwYWRkZWRCb3VuZHMuZXh0ZW5kKHBpeGVsUG9pbnQpLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkZWRTaXplKTtcclxuXHRcdFx0cGl4ZWxDZW50ZXIueCArPSBjZW50ZXJPZmZzZXQueCA8IDAgPyAtb2Zmc2V0LnggOiBvZmZzZXQueDtcclxuXHRcdFx0cGl4ZWxDZW50ZXIueSArPSBjZW50ZXJPZmZzZXQueSA8IDAgPyAtb2Zmc2V0LnkgOiBvZmZzZXQueTtcclxuXHRcdFx0dGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChwaXhlbENlbnRlciksIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHsgdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlci5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG5cdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcblx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcblx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG5cdFx0ICAgIGJvdW5kc1NpemUgPSB0b0JvdW5kcyh0aGlzLnByb2plY3Qoc2UsIHpvb20pLCB0aGlzLnByb2plY3QobncsIHpvb20pKS5nZXRTaXplKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG5cdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcblx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG5cdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG5cdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG5cdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcblx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcblx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmdldChpZCk7XHJcblxyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIG5vdCBmb3VuZC4nKTtcclxuXHRcdH0gZWxzZSBpZiAoY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gVXRpbC5zdGFtcChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5yZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBEb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnICYmIHBvc2l0aW9uICE9PSAnc3RpY2t5Jykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBub01vdmVTdGFydClcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEsIHN1cHJlc3NFdmVudCkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdGlmICghc3VwcmVzc0V2ZW50KSB7XHJcblx0XHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsXHJcblx0XHRcdC8vIGluY2x1ZGluZyB6b29tIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsXHJcblx0XHRcdC8vIGluY2x1ZGluZyBwYW4gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLnBpbmNoKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZ1xyXG5cdFx0Ly8gKGUuZy4gdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBtYXAgb3IgYWZ0ZXIgbm9uLWNlbnRlcmVkIHpvb20pLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyBEb21FdmVudC5vZmYgOiBEb21FdmVudC5vbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHRoYXQgcHJvZHVjZXMgYSBjaGFyYWN0ZXIgdmFsdWUgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0Ly8gQGV2ZW50IGtleWRvd246IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuXHRcdC8vIHRoZSBga2V5ZG93bmAgZXZlbnQgaXMgZmlyZWQgZm9yIGtleXMgdGhhdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlIGFuZCBmb3Iga2V5c1xyXG5cdFx0Ly8gdGhhdCBkbyBub3QgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZS5cclxuXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQocmVtb3ZlID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG5cdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHBzOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIURvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgdGhpcy5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaXNDbGlja0Rpc2FibGVkOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHdoaWxlIChlbCAmJiBlbCAhPT0gdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdGlmIChlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgZWwgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IGVsWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyAmJiB0aGlzLl9pc0NsaWNrRGlzYWJsZWQoZWwpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUoZWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCBjYW52YXNUYXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gVXRpbC5leHRlbmQoe30sIGUpO1xyXG5cdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCBjYW52YXNUYXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcblx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSk7XHJcblxyXG5cdFx0aWYgKGNhbnZhc1RhcmdldHMpIHtcclxuXHRcdFx0dmFyIGZpbHRlcmVkID0gW107IC8vIHBpY2sgb25seSB0YXJnZXRzIHdpdGggbGlzdGVuZXJzXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FudmFzVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChjYW52YXNUYXJnZXRzW2ldLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRcdGZpbHRlcmVkLnB1c2goY2FudmFzVGFyZ2V0c1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRhcmdldHMgPSBmaWx0ZXJlZC5jb25jYXQodGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIFV0aWwuaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuXHRcdF0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgPD0gMSAmJiBNYXRoLmFicyhvZmZzZXQueSkgPD0gMSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl90cnVuYygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG5cdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHByb3AgPSBEb21VdGlsLlRSQU5TRk9STSxcclxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XHJcblx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9kZXN0cm95QW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wcm94eSk7XHJcblx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3Byb3h5O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuXHR9LFxyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0IHx8IGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbSxcclxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50KSB7XHJcblx0XHRcdHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50ID0gdGhpcy5fem9vbSAhPT0gdGhpcy5fYW5pbWF0ZVRvWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLl90ZW1wRmlyZVpvb21FdmVudDtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gJy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBPcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAqIFx0XCJPcGVuU3RyZWV0TWFwXCI6IG9zbVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgb3ZlcmxheXMgPSB7XHJcbiAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gKiB9O1xyXG4gKlxyXG4gKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XHJcbiAqICAgICBcIjxzb21lTmFtZTE+XCI6IGxheWVyMSxcclxuICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVycyA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyLCB0b3VjaCwgb3Iga2V5Ym9hcmQgYWN0aXZhdGlvbi5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fcHJldmVudENsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdENvbnRyb2wucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcywgbWFwKTtcclxuXHRcdC8vIFRyaWdnZXIgZXhwYW5kIGFmdGVyIExheWVycyBDb250cm9sIGhhcyBiZWVuIGluc2VydGVkIGludG8gRE9NIHNvIHRoYXQgaXMgbm93IGhhcyBhbiBhY3R1YWwgaGVpZ2h0LlxyXG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChsYXllcikpO1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG5cdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuXHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fc2VjdGlvbi5jbGllbnRIZWlnaHQpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcblx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXHJcblx0XHQgICAgY29sbGFwc2VkID0gdGhpcy5vcHRpb25zLmNvbGxhcHNlZDtcclxuXHJcblx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cclxuXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IERvbVV0aWwuY3JlYXRlKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKGNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblxyXG5cdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLl9leHBhbmRTYWZlbHksXHJcblx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBEb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssIHtcclxuXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHRcdFx0dGhpcy5fZXhwYW5kU2FmZWx5KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBDZXJ0YWluIHNjcmVlbiByZWFkZXJzIGludGVyY2VwdCB0aGUga2V5IGV2ZW50IGFuZCBpbnN0ZWFkIHNlbmQgYSBjbGljayBldmVudFxyXG5cdFx0XHRjbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIFV0aWwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KFV0aWwuYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE5MDc5KVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIFV0aWwuc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuXHRcdGlucHV0LmxheWVySWQgPSBVdGlsLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGV4cGFuZGluZyB0aGUgY29udHJvbCBvbiBtb2JpbGUgd2l0aCBhIGNsaWNrIGNhbiBjYXVzZSBhZGRpbmcgYSBsYXllciAtIHdlIGRvbid0IHdhbnQgdGhpc1xyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRDbGljaykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kU2FmZWx5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb247XHJcblx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSB0cnVlO1xyXG5cdFx0RG9tRXZlbnQub24oc2VjdGlvbiwgJ2NsaWNrJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHREb21FdmVudC5vZmYoc2VjdGlvbiwgJ2NsaWNrJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0XHR0aGF0Ll9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgbGF5ZXJzIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG5leHBvcnQgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcclxuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPidcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcblx0XHQgKi9cclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBEb21FdmVudC5zdG9wKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcblx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbmV4cG9ydCB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuXHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cblx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuXHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG52YXIgdWtyYWluaWFuRmxhZyA9ICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiOFwiIHZpZXdCb3g9XCIwIDAgMTIgOFwiIGNsYXNzPVwibGVhZmxldC1hdHRyaWJ1dGlvbi1mbGFnXCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+JztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nfGZhbHNlID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+JyArIChCcm93c2VyLmlubGluZVN2ZyA/IHVrcmFpbmlhbkZsYWcgKyAnICcgOiAnJykgKyAnTGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRtYXAub24oJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKGV2KSB7XHJcblx0XHRpZiAoZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0ZXYubGF5ZXIub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nfGZhbHNlKTogdGhpc1xyXG5cdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnJmNvcHk7IE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj58PC9zcGFuPiAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5leHBvcnQgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NvbnRyb2wsIGNvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQge0xheWVycywgbGF5ZXJzfSBmcm9tICcuL0NvbnRyb2wuTGF5ZXJzJztcbmltcG9ydCB7Wm9vbSwgem9vbX0gZnJvbSAnLi9Db250cm9sLlpvb20nO1xuaW1wb3J0IHtTY2FsZSwgc2NhbGV9IGZyb20gJy4vQ29udHJvbC5TY2FsZSc7XG5pbXBvcnQge0F0dHJpYnV0aW9uLCBhdHRyaWJ1dGlvbn0gZnJvbSAnLi9Db250cm9sLkF0dHJpYnV0aW9uJztcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbmV4cG9ydCB7Q29udHJvbCwgY29udHJvbH07XG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuZXhwb3J0IHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4vLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG5cdHJldHVybiB0aGlzO1xufTtcbiIsImltcG9ydCBCcm93c2VyIGZyb20gJy4vQnJvd3Nlcic7XG5leHBvcnQge0Jyb3dzZXJ9O1xuXG5leHBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuL0V2ZW50cyc7XG5pbXBvcnQge0V2ZW50c30gZnJvbSAnLi9FdmVudHMnO1xuZXhwb3J0IHtFdmVudGVkfTtcbmV4cG9ydCB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG5leHBvcnQge0hhbmRsZXJ9IGZyb20gJy4vSGFuZGxlcic7XG5cbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcbmV4cG9ydCB7VXRpbH07XG5leHBvcnQge2V4dGVuZCwgYmluZCwgc3RhbXAsIHNldE9wdGlvbnN9IGZyb20gJy4vVXRpbCc7XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG5cclxuZXhwb3J0IHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcblx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG5cdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG5cdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG5cdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcblx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdHRoaXMuZmluaXNoRHJhZyh0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcclxuXHRcdFx0Ly8gRmluaXNoIGRyYWdnaW5nIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggdG91Y2hab29tXHJcblx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG5cdFx0ICAgIHNpemVkUGFyZW50ID0gRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IERvbVV0aWwuZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuXHRcdHZhciBtb3VzZWV2ZW50ID0gZS50eXBlID09PSAnbW91c2Vkb3duJztcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNlbW92ZScgOiAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxyXG5cdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG5cdFx0Ly8gYW5kIHdlIGNhbiB1c2UgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgdGhlIHNjYWxlLlxyXG5cdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcclxuXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UgJiYgdGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAobm9JbmVydGlhKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ21vdXNldXAgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHJcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0dmFyIGZpcmVEcmFnZW5kID0gdGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nO1xyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChmaXJlRHJhZ2VuZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdG5vSW5lcnRpYTogbm9JbmVydGlhLFxyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufSk7XHJcbiIsImltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4vTGluZVV0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHA7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gKiBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwYXNzZWQgTGF0TG5ncyAoZmlyc3QgcmluZykgZnJvbSBhIHBvbHlnb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbkNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuXHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXI7XHJcblxyXG5cdGlmICghbGF0bG5ncyB8fCBsYXRsbmdzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdsYXRsbmdzIG5vdCBwYXNzZWQnKTtcclxuXHR9XHJcblxyXG5cdGlmICghTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3MpKSB7XHJcblx0XHRjb25zb2xlLndhcm4oJ2xhdGxuZ3MgYXJlIG5vdCBmbGF0ISBPbmx5IHRoZSBmaXJzdCByaW5nIHdpbGwgYmUgdXNlZCcpO1xyXG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3NbMF07XHJcblx0fVxyXG5cclxuXHR2YXIgY2VudHJvaWRMYXRMbmcgPSB0b0xhdExuZyhbMCwgMF0pO1xyXG5cclxuXHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0bG5ncyk7XHJcblx0dmFyIGFyZWFCb3VuZHMgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICogYm91bmRzLmdldE5vcnRoRWFzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldE5vcnRoV2VzdCgpKTtcclxuXHQvLyB0ZXN0cyBzaG93ZWQgdGhhdCBiZWxvdyAxNzAwIHJvdW5kaW5nIGVycm9ycyBhcmUgaGFwcGVuaW5nXHJcblx0aWYgKGFyZWFCb3VuZHMgPCAxNzAwKSB7XHJcblx0XHQvLyBnZXR0aW5nIGEgaW5leGFjdCBjZW50ZXIsIHRvIG1vdmUgdGhlIGxhdGxuZ3MgbmVhciB0byBbMCwgMF0gdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnNcclxuXHRcdGNlbnRyb2lkTGF0TG5nID0gY2VudHJvaWQobGF0bG5ncyk7XHJcblx0fVxyXG5cclxuXHR2YXIgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xyXG5cdFx0cG9pbnRzLnB1c2goY3JzLnByb2plY3QodG9MYXRMbmcoW2xhdGxuZy5sYXQgLSBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZy5sbmcgLSBjZW50cm9pZExhdExuZy5sbmddKSkpO1xyXG5cdH1cclxuXHJcblx0YXJlYSA9IHggPSB5ID0gMDtcclxuXHJcblx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07XHJcblx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdHAxID0gcG9pbnRzW2ldO1xyXG5cdFx0cDIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XHJcblx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xyXG5cdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcclxuXHRcdGFyZWEgKz0gZiAqIDM7XHJcblx0fVxyXG5cclxuXHRpZiAoYXJlYSA9PT0gMCkge1xyXG5cdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXHJcblx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcblx0fSBlbHNlIHtcclxuXHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xyXG5cdH1cclxuXHJcblx0dmFyIGxhdGxuZ0NlbnRlciA9IGNycy51bnByb2plY3QodG9Qb2ludChjZW50ZXIpKTtcclxuXHRyZXR1cm4gdG9MYXRMbmcoW2xhdGxuZ0NlbnRlci5sYXQgKyBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZ0NlbnRlci5sbmcgKyBjZW50cm9pZExhdExuZy5sbmddKTtcclxufVxyXG5cclxuLyogQGZ1bmN0aW9uIGNlbnRyb2lkKGxhdGxuZ3M6IExhdExuZ1tdKTogTGF0TG5nXHJcbiAqIFJldHVybnMgdGhlICdjZW50ZXIgb2YgbWFzcycgb2YgdGhlIHBhc3NlZCBMYXRMbmdzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNlbnRyb2lkKGNvb3Jkcykge1xyXG5cdHZhciBsYXRTdW0gPSAwO1xyXG5cdHZhciBsbmdTdW0gPSAwO1xyXG5cdHZhciBsZW4gPSAwO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdGxhdFN1bSArPSBsYXRsbmcubGF0O1xyXG5cdFx0bG5nU3VtICs9IGxhdGxuZy5sbmc7XHJcblx0XHRsZW4rKztcclxuXHR9XHJcblx0cmV0dXJuIHRvTGF0TG5nKFtsYXRTdW0gLyBsZW4sIGxuZ1N1bSAvIGxlbl0pO1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge2NlbnRyb2lkfSBmcm9tICcuL1BvbHlVdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbi8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4vLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuLy8gW1JhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cHM6Ly9tb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qcy8pLlxyXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuXHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG5cdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdHZhciBpLFxyXG5cdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1BvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbmZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0cHJldiA9IGk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0fVxyXG5cdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG59XHJcblxyXG52YXIgX2xhc3RDb2RlO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbi8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4vLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbi8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG5cdHZhciBjb2RlID0gMDtcclxuXHJcblx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRjb2RlIHw9IDE7XHJcblx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdGNvZGUgfD0gMjtcclxuXHR9XHJcblxyXG5cdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRjb2RlIHw9IDQ7XHJcblx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRjb2RlIHw9IDg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufVxyXG5cclxuLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbmZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcblx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuZXhwb3J0IGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIVV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5bGluZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuXHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sIGNlbnRlcjtcclxuXHJcblx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFpc0ZsYXQobGF0bG5ncykpIHtcclxuXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcblx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuXHR9XHJcblxyXG5cdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG5cdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRsbmdzKTtcclxuXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG5cdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuXHRpZiAoYXJlYUJvdW5kcyA8IDE3MDApIHtcclxuXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuXHR9XHJcblxyXG5cdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuXHR2YXIgcG9pbnRzID0gW107XHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcblx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcblx0fVxyXG5cclxuXHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcclxuXHR9XHJcblxyXG5cdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cclxuXHRpZiAoaGFsZkRpc3QgPT09IDApIHtcclxuXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdFx0cDEgPSBwb2ludHNbaV07XHJcblx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcclxuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xyXG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XHJcblxyXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XHJcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XHJcblx0XHRcdFx0Y2VudGVyID0gW1xyXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcclxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcclxuXHRcdFx0XHRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG5cdHJldHVybiB0b0xhdExuZyhbbGF0bG5nQ2VudGVyLmxhdCArIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nQ2VudGVyLmxuZyArIGNlbnRyb2lkTGF0TG5nLmxuZ10pO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwX3Byb2plY3Rpb24pLlxuXG4gKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG5cbiAqIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XG4gKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG4gKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogTm90ZSB0aGF0IHRoZSBwcm9qZWN0aW9uIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgRVBTRzMzOTUgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICpcclxuICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzQzMjYgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XG5pbXBvcnQge0VQU0czMzk1fSBmcm9tICcuL0NSUy5FUFNHMzM5NSc7XG5pbXBvcnQge0VQU0czODU3LCBFUFNHOTAwOTEzfSBmcm9tICcuL0NSUy5FUFNHMzg1Nyc7XG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuL0NSUy5FUFNHNDMyNic7XG5pbXBvcnQge1NpbXBsZX0gZnJvbSAnLi9DUlMuU2ltcGxlJztcblxuQ1JTLkVhcnRoID0gRWFydGg7XG5DUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbkNSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG5DUlMuU2ltcGxlID0gU2ltcGxlO1xuXG5leHBvcnQge0NSU307XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuZXhwb3J0IHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdC8vXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20oZ3JvdXA6IExheWVyR3JvdXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIGBMYXllckdyb3VwYFxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChVdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgbGF5ZXJJZCA9IHR5cGVvZiBsYXllciA9PT0gJ251bWJlcicgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAuYWRkTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5yZW1vdmVMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobGF5ZXJzLnB1c2gsIGxheWVycyk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIFV0aWwuc3RhbXAobGF5ZXIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgYmFjayBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4uLy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge3NldE9wdGlvbnN9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQGNsYXNzIEljb25cclxuICogQGFrYSBMLkljb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcblx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHQgKi9cclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuXHRcdHRvb2x0aXBBbmNob3I6IFswLCAwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaXplID0gcG9pbnQoc2l6ZU9wdGlvbiksXHJcblx0XHQgICAgYW5jaG9yID0gcG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcblx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiBCcm93c2VyLnJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICh0eXBlb2YgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoICE9PSAnc3RyaW5nJykge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X3N0cmlwVXJsOiBmdW5jdGlvbiAocGF0aCkge1x0Ly8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gdXNlIGluIHRlc3RzXG5cdFx0dmFyIHN0cmlwID0gZnVuY3Rpb24gKHN0ciwgcmUsIGlkeCkge1xuXHRcdFx0dmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuXHRcdFx0cmV0dXJuIG1hdGNoICYmIG1hdGNoW2lkeF07XG5cdFx0fTtcblx0XHRwYXRoID0gc3RyaXAocGF0aCwgL151cmxcXCgoWydcIl0pPyguKylcXDFcXCkkLywgMik7XG5cdFx0cmV0dXJuIHBhdGggJiYgc3RyaXAocGF0aCwgL14oLiopbWFya2VyLWljb25cXC5wbmckLywgMSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblx0XHRwYXRoID0gdGhpcy5fc3RyaXBVcmwocGF0aCk7XG5cdFx0aWYgKHBhdGgpIHsgcmV0dXJuIHBhdGg7IH1cblx0XHR2YXIgbGluayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZiQ9XCJsZWFmbGV0LmNzc1wiXScpO1xuXHRcdGlmICghbGluaykgeyByZXR1cm4gJyc7IH1cblx0XHRyZXR1cm4gbGluay5ocmVmLnN1YnN0cmluZygwLCBsaW5rLmhyZWYubGVuZ3RoIC0gJ2xlYWZsZXQuY3NzJy5sZW5ndGggLSAxKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZSwgY2FuY2VsQW5pbUZyYW1lfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuXHRcdCk7XG5cblx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcblx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cblx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcblx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdC8vIFdoZW4gdXNpbmcgRVM2IGltcG9ydHMgaXQgY291bGQgbm90IGJlIHNldCB3aGVuIGBQb3B1cGAgd2FzIG5vdCBpbXBvcnRlZCBhcyB3ZWxsXG5cdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuXHRcdHRoaXMuX21hcmtlclxuXHRcdFx0LmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XHJcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nIGFzIGxhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0IHtNYXJrZXJEcmFnfSBmcm9tICcuL01hcmtlci5EcmFnJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG5cdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnTWFya2VyJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZS5cclxuXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG5cdFx0YWx0OiAnTWFya2VyJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9uSG92ZXI6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcclxuXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG5cdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ21hcmtlclBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNoYWRvd1BhbmU6IFN0cmluZyA9ICdzaGFkb3dQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHNoYWRvd1BhbmU6ICdzaGFkb3dQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxyXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuT25Gb2N1czogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZW4gYHRydWVgLCB0aGUgbWFwIHdpbGwgcGFuIHdoZW5ldmVyIHRoZSBtYXJrZXIgaXMgZm9jdXNlZCAodmlhXHJcblx0XHQvLyBlLmcuIHByZXNzaW5nIGB0YWJgIG9uIHRoZSBrZXlib2FyZCkgdG8gZW5zdXJlIHRoZSBtYXJrZXIgaXNcclxuXHRcdC8vIHZpc2libGUgd2l0aGluIHRoZSBtYXAncyBib3VuZHNcclxuXHRcdGF1dG9QYW5PbkZvY3VzOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIERyYWdnYWJsZSBtYXJrZXIgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuXHRcdGF1dG9QYW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG5cdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG5cdFx0Ly8gbWFwIGVkZ2UgdG8gc3RhcnQgcGFubmluZyB0aGUgbWFwLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG5cdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBwYW4gYnkuXHJcblx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBpY29uIHVzZWQgYnkgdGhlIG1hcmtlclxyXG5cdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbiAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdCB8fCAnJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdFx0aWNvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuXHRcdFx0RG9tRXZlbnQub24oaWNvbiwgJ2ZvY3VzJywgdGhpcy5fcGFuT25Gb2N1cywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKG9wdGlvbnMuc2hhZG93UGFuZSkuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2ljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuT25Gb2N1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBpY29uT3B0cyA9IHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZSA9IGljb25PcHRzLmljb25TaXplID8gcG9pbnQoaWNvbk9wdHMuaWNvblNpemUpIDogcG9pbnQoMCwgMCk7XHJcblx0XHR2YXIgYW5jaG9yID0gaWNvbk9wdHMuaWNvbkFuY2hvciA/IHBvaW50KGljb25PcHRzLmljb25BbmNob3IpIDogcG9pbnQoMCwgMCk7XHJcblxyXG5cdFx0bWFwLnBhbkluc2lkZSh0aGlzLl9sYXRsbmcsIHtcclxuXHRcdFx0cGFkZGluZ1RvcExlZnQ6IGFuY2hvcixcclxuXHRcdFx0cGFkZGluZ0JvdHRvbVJpZ2h0OiBzaXplLnN1YnRyYWN0KGFuY2hvcilcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3I7XHJcblx0fSxcclxuXHJcblx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3I7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxuZXhwb3J0IHZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgJ3dlaWdodCcpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICtcblx0XHQgICh0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZSB8fCAwKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FYXJ0aCc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn1cbiIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICogXHRbMzQuMDQsIC0xMTguMl1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gKiBcdFtbNDAuNzgsIC03My45MV0sXG4gKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuXG5leHBvcnQgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IExpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXHRcdHJldHVybiBMaW5lVXRpbC5wb2x5bGluZUNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/OiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG5cdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSBMaW5lVXRpbC5pc0ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cdFx0dGhpcy5fcmluZ3MgPSBbXTtcblx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHRpZiAoIXRoaXMuX3Jhd1B4Qm91bmRzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1heC5hZGQocClcblx0XHRdKTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTGluZVV0aWwuY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IExpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRpZiAoTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbi8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbi8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuUG9seWxpbmUuX2ZsYXQgPSBMaW5lVXRpbC5fZmxhdDtcbiIsImltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQgKiBhcyBQb2x5VXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2x5VXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGFrYSBMLlBvbHlnb25cbiAqIEBpbmhlcml0cyBQb2x5bGluZVxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICpcbiAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gKlxuICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqICAgXSxcbiAqICAgWyAvLyBzZWNvbmQgcG9seWdvblxuICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICogICBdXG4gKiBdO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgUG9seWdvbi5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblx0XHRyZXR1cm4gUG9seVV0aWwucG9seWdvbkNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IFBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyfSBmcm9tICcuL21hcmtlci9NYXJrZXInO1xyXG5pbXBvcnQge0NpcmNsZX0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlJztcclxuaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vdmVjdG9yL0NpcmNsZU1hcmtlcic7XHJcbmltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vdmVjdG9yL1BvbHlsaW5lJztcclxuaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL3ZlY3Rvci9Qb2x5Z29uJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi9nZW9tZXRyeS9MaW5lVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcblx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcblx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB7fVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcblx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHRydWU7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcblx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG1hcmtlcnNJbmhlcml0T3B0aW9uczogQm9vbGVhbiA9IGZhbHNlXHJcblx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBVdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4vLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbi8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBnZW9MYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChnZW9MYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGdlb0xheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGZlYXR1cmVMYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9tZXRyeS5mZWF0dXJlc1tpXSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRpZiAoZmVhdHVyZUxheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2goZmVhdHVyZUxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcblx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4vLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG5cdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4vLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbi8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XHJcblx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhdGxuZ3M7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcblx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4sIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XHJcblx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0Ly8gQ2hlY2sgZm9yIGZsYXQgYXJyYXlzIHJlcXVpcmVkIHRvIGVuc3VyZSB1bmJhbGFuY2VkIGFycmF5cyBhcmUgY29ycmVjdGx5IGNvbnZlcnRlZCBpbiByZWN1cnNpb25cclxuXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3NbaV0pID8gMCA6IGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG5cdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuXHR9XHJcblxyXG5cdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXS5zbGljZSgpKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb29yZHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuXHRcdFV0aWwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG5cdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdHJldHVybiBnZW9qc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHR9O1xyXG59XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4vLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5NYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBtdWx0aSA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcblBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgaG9sZXMgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG5cdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0aWYgKCFob2xlcykge1xyXG5cdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuXHQvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcblx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuZXhwb3J0IHZhciBnZW9Kc29uID0gZ2VvSlNPTjtcclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHBzOi8vbWFwcy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcblx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG5cdFx0ekluZGV4OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ2ltZycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0aW1nLm9ubG9hZCA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IFV0aWwuYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgSW1hZ2VPdmVybGF5LlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5leHBvcnQgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0Ly8gT24gc29tZSBicm93c2VycyBhdXRvcGxheSB3aWxsIG9ubHkgd29yayB3aXRoIGBtdXRlZDogdHJ1ZWBcclxuXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcblx0XHRsb29wOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEFzcGVjdFJhdGlvOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuXHRcdC8vIFJlbGV2YW50IGZvciBzdXBwb3J0ZWQgYnJvd3NlcnMuIFNlZSBbYnJvd3NlciBjb21wYXRpYmlsaXR5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdClcclxuXHRcdGtlZXBBc3BlY3RSYXRpbzogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBvbiBtdXRlIHdoZW4gbG9hZGVkLlxyXG5cdFx0bXV0ZWQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGxheXNJbmxpbmU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBNb2JpbGUgYnJvd3NlcnMgd2lsbCBwbGF5IHRoZSB2aWRlbyByaWdodCB3aGVyZSBpdCBpcyBpbnN0ZWFkIG9mIG9wZW4gaXQgdXAgaW4gZnVsbHNjcmVlbiBtb2RlLlxyXG5cdFx0cGxheXNJbmxpbmU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgndmlkZW8nKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHR2aWQub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuXHRcdFx0dmlkLnN0eWxlWydvYmplY3RGaXQnXSA9ICdmaWxsJztcclxuXHRcdH1cclxuXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG5cdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG5cdFx0dmlkLm11dGVkID0gISF0aGlzLm9wdGlvbnMubXV0ZWQ7XHJcblx0XHR2aWQucGxheXNJbmxpbmUgPSAhIXRoaXMub3B0aW9ucy5wbGF5c0lubGluZTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBTVkdPdmVybGF5XG4gKiBAYWthIEwuU1ZHT3ZlcmxheVxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICpcbiAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gKlxuICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG5cdFx0ZWwub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHRlbC5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblx0fVxuXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KVxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuc3ZnT3ZlcmxheShzdmc6IFN0cmluZ3xTVkdFbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFNWR092ZXJsYXkgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiBhbiBTVkcgZWxlbWVudCBhbmQgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cbi8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuZXhwb3J0IGZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcsIExhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIG92ZXJsYXlzIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuZXhwb3J0IHZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHBvcHVwL3Rvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIG1vdXNlIGV2ZW50cy5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgb3ZlcmxheSBwb3NpdGlvbi5cclxuXHRcdG9mZnNldDogWzAsIDBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uID0gJydcclxuXHRcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheSB3aGlsZSBpbml0aWFsaXppbmcuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZVxyXG5cdFx0Ly8gcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcblx0XHRjb250ZW50OiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdGlmIChvcHRpb25zICYmIChvcHRpb25zIGluc3RhbmNlb2YgTGF0TG5nIHx8IFV0aWwuaXNBcnJheShvcHRpb25zKSkpIHtcclxuXHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcob3B0aW9ucyk7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzb3VyY2UpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQpIHtcclxuXHRcdFx0dGhpcy5fY29udGVudCA9IHRoaXMub3B0aW9ucy5jb250ZW50O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIG92ZXJsYXkgdG8gdGhlIG1hcC5cclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgL2Aub3BlblRvb2x0aXAodG9vbHRpcClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkge1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIG92ZXJsYXkuXHJcblx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5jbG9zZVBvcHVwKHBvcHVwKWAvYC5jbG9zZVRvb2x0aXAodG9vbHRpcClgXHJcblx0Ly8gYW5kIGBsYXllci5jbG9zZVBvcHVwKClgL2AuY2xvc2VUb29sdGlwKClgLlxyXG5cdGNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlKGxheWVyPzogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBvdmVybGF5IGJvdW5kIHRvIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuXHQvLyBBcmd1bWVudCBtYXkgYmUgb21pdHRlZCBvbmx5IGZvciBvdmVybGF5IGJvdW5kIHRvIGxheWVyLlxyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBsYXllci50b2dnbGVQb3B1cCgpYC9gLnRvZ2dsZVRvb2x0aXAoKWAuXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2UgPSBsYXllcjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsYXllciA9IHRoaXMuX3NvdXJjZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wcmVwYXJlT3BlbigpO1xyXG5cclxuXHRcdFx0Ly8gb3BlbiB0aGUgb3ZlcmxheSBvbiB0aGUgbWFwXHJcblx0XHRcdHRoaXMub3Blbk9uKGxheWVyLl9tYXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChEb21VdGlsLnJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiB0aGUgb3ZlcmxheS5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheS4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcblx0Ly8gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBjb250YWluZXIgb2YgdGhlIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIG92ZXJsYXkgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgb3ZlcmxheSBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSBpbiBmcm9udCBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IHRvIHRoZSBiYWNrIG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIHByZXBhcmUgYm91bmQgb3ZlcmxheSB0byBvcGVuOiB1cGRhdGUgbGF0bG5nIHBvcyAvIGNvbnRlbnQgc291cmNlIChmb3IgRmVhdHVyZUdyb3VwKVxyXG5cdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuXHRcdGlmICghc291cmNlLl9tYXApIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRzb3VyY2UgPSBudWxsO1xyXG5cdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5fc291cmNlLl9sYXllcnM7XHJcblx0XHRcdGZvciAodmFyIGlkIGluIGxheWVycykge1xyXG5cdFx0XHRcdGlmIChsYXllcnNbaWRdLl9tYXApIHtcclxuXHRcdFx0XHRcdHNvdXJjZSA9IGxheWVyc1tpZF07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFzb3VyY2UpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIFVuYWJsZSB0byBnZXQgc291cmNlIGxheWVyLlxyXG5cclxuXHRcdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghbGF0bG5nKSB7XHJcblx0XHRcdGlmIChzb3VyY2UuZ2V0Q2VudGVyKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRMYXRMbmcpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0TGF0TG5nKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoc291cmNlLmdldEJvdW5kcykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy4nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBldGMuLi4pXHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcblx0XHQvLyBAc2VjdGlvbiBEaXZPdmVybGF5IGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGNvbnRlbnR1cGRhdGU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5IGlzIHVwZGF0ZWRcclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIG92ZXJsYXkgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuTWFwLmluY2x1ZGUoe1xyXG5cdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgY29udGVudCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcblx0XHRpZiAoIShvdmVybGF5IGluc3RhbmNlb2YgT3ZlcmxheUNsYXNzKSkge1xyXG5cdFx0XHRvdmVybGF5ID0gbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zKS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRvdmVybGF5LnNldExhdExuZyhsYXRsbmcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG92ZXJsYXk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5MYXllci5pbmNsdWRlKHtcclxuXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIG9sZCwgY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG5cdFx0aWYgKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKG92ZXJsYXksIG9wdGlvbnMpO1xyXG5cdFx0XHRvdmVybGF5Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3ZlcmxheSA9IChvbGQgJiYgIW9wdGlvbnMpID8gb2xkIDogbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0b3ZlcmxheS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG92ZXJsYXk7XHJcblx0fVxyXG59KTtcclxuIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge1BhdGh9IGZyb20gJy4vdmVjdG9yL1BhdGgnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICpcclxuICogQSBwb3B1cCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICogb3JcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cChsYXRsbmcsIHtjb250ZW50OiAnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5leHBvcnQgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdC8vIFRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBjYW4gYmUgc3R5bGVkIHVzaW5nIHRoZVxyXG5cdFx0Ly8gYGxlYWZsZXQtcG9wdXAtc2Nyb2xsZWRgIENTUyBjbGFzcyBzZWxlY3Rvci5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcblx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHJcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKG1hcC5fcG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0bWFwLl9wb3B1cCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIERpdk92ZXJsYXkucHJvdG90eXBlLm9wZW5Pbi5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjb250ZXh0bWVudScsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBEb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpOyAvLyBvdmVycmlkZXMgdGhlIGltcGxpY2l0IHJvbGU9bGluayBvZiA8YT4gZWxlbWVudHMgIzczOTlcclxuXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ0Nsb3NlIHBvcHVwJyk7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjMjE1Ozwvc3Bhbj4nO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG5cdFx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGV2KTtcclxuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKHRoaXMuX21hcC5fcGFuQW5pbSkgeyB0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpOyB9XHJcblxyXG5cdFx0Ly8gV2UgY2FuIGVuZGxlc3NseSByZWN1cnNlIGlmIGtlZXBJblZpZXcgaXMgc2V0IGFuZCB0aGUgdmlldyByZXNldHMuXHJcblx0XHQvLyBMZXQncyBndWFyZCBhZ2FpbnN0IHRoYXQgYnkgZXhpdGluZyBlYXJseSBpZiB3ZSdyZSByZXNwb25kaW5nIHRvIG91ciBvd24gYXV0b3Bhbi5cclxuXHRcdGlmICh0aGlzLl9hdXRvcGFubmluZykge1xyXG5cdFx0XHR0aGlzLl9hdXRvcGFubmluZyA9IGZhbHNlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChEb21VdGlsLmdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG5cdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcblx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0bGF5ZXJQb3MuX2FkZChEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHQvLyBUcmFjayB0aGF0IHdlJ3JlIGF1dG9wYW5uaW5nLCBhcyB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmUtcmFuIG9uIG1vdmVlbmRcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYGxhdGxuZ2Agd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCBwb3B1cCwgbGF0bG5nLCBvcHRpb25zKVxyXG5cdFx0ICAub3Blbk9uKHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0cG9wdXAgPSBhcmd1bWVudHMubGVuZ3RoID8gcG9wdXAgOiB0aGlzLl9wb3B1cDtcclxuXHRcdGlmIChwb3B1cCkge1xyXG5cdFx0XHRwb3B1cC5jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX3BvcHVwID0gdGhpcy5faW5pdE92ZXJsYXkoUG9wdXAsIHRoaXMuX3BvcHVwLCBjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9wcmVwYXJlT3BlbihsYXRsbmcgfHwgdGhpcy5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0XHR0aGlzLl9wb3B1cC5vcGVuT24odGhpcy5fbWFwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC50b2dnbGUodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9wb3B1cCA/IHRoaXMuX3BvcHVwLmlzT3BlbigpIDogZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG5cdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCAhdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cclxuXHRcdHZhciB0YXJnZXQgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IHRhcmdldCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdC8vIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuXHRcdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGFyZ2V0O1xyXG5cdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5cbi8qXG4gKiBAY2xhc3MgVG9vbHRpcFxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAqIEBha2EgTC5Ub29sdGlwXG4gKiBVc2VkIHRvIGRpc3BsYXkgc21hbGwgdGV4dHMgb24gdG9wIG9mIG1hcCBsYXllcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHRvb2x0aXAgdG8gbWFya2VyOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFRvb2x0aXBgIG1ldGhvZC5cbiAqXG4gKiBBIHRvb2x0aXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAoKVxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcbiAqIFx0LnNldENvbnRlbnQoJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJylcbiAqIFx0LmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqIG9yXG4gKiBgYGBqc1xuICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAobGF0bG5nLCB7Y29udGVudDogJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJ30pXG4gKiBcdC5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICpcbiAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICogZm9yIGNvbXB1dGluZyB0b29sdGlwIG9mZnNldHRpbmc6XG4gKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gKi9cblxuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbmV4cG9ydCB2YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRvZmZzZXQ6IFswLCAwXSxcblxuXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcblx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cblx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWxseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cblx0XHRvcGFjaXR5OiAwLjlcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdHRoaXMuYWRkRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0dGhpcy5yZW1vdmVFdmVudFBhcmVudCh0aGlzLl9zb3VyY2UpO1xuXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcblx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XG5cblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdsZWFmbGV0LXRvb2x0aXAtJyArIFV0aWwuc3RhbXAodGhpcykpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBzdWJYLCBzdWJZLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodDtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IDA7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0c3ViWCA9IDA7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHN1YlggPSAwO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoICsgKG9mZnNldC54ICsgYW5jaG9yLngpICogMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9XG5cblx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludChzdWJYLCBzdWJZLCB0cnVlKSkuYWRkKG9mZnNldCkuYWRkKGFuY2hvcik7XG5cblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIGBUb29sdGlwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC50b29sdGlwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBgbGF0bG5nYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxuZXhwb3J0IHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucylcblx0XHQgIC5vcGVuT24odGhpcyk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0dG9vbHRpcC5jbG9zZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn0pO1xuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICogYGBgXG4gKi9cblxuLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuaXNUb29sdGlwT3BlbigpKSB7XG5cdFx0XHR0aGlzLnVuYmluZFRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHR0aGlzLl90b29sdGlwID0gdGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdGhpcy5fdG9vbHRpcCwgY29udGVudCwgb3B0aW9ucyk7XG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9hZGRGb2N1c0xpc3RlbmVycztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4obGF0bG5nKSkge1xuXHRcdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdFx0dGhpcy5fdG9vbHRpcC5vcGVuT24odGhpcy5fbWFwKTtcblxuXHRcdFx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllcih0aGlzKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuXHRcdFx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHJldHVybiB0aGlzLl90b29sdGlwLmNsb3NlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnRvZ2dsZSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X2FkZEZvY3VzTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZ2V0RWxlbWVudCkge1xuXHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyKHRoaXMpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcblx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllciwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWwpIHtcblx0XHRcdERvbUV2ZW50Lm9uKGVsLCAnZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGxheWVyO1xuXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdERvbUV2ZW50Lm9uKGVsLCAnYmx1cicsIHRoaXMuY2xvc2VUb29sdGlwLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lci5pZCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIG1hcCBpcyBtb3ZpbmcsIHdlIHdpbGwgc2hvdyB0aGUgdG9vbHRpcCBhZnRlciBpdCdzIGRvbmUuXG5cdFx0aWYgKHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgJiYgIXRoaXMuX29wZW5PbmNlRmxhZykge1xuXHRcdFx0dGhpcy5fb3Blbk9uY2VGbGFnID0gdHJ1ZTtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHRoaXMuX21hcC5vbmNlKCdtb3ZlZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9vcGVuT25jZUZsYWcgPSBmYWxzZTtcblx0XHRcdFx0dGhhdC5fb3BlblRvb2x0aXAoZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0dGhpcy5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7ZW1wdHl9IGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbmV4cG9ydCB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0ZW1wdHkoZGl2KTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBwb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuZXhwb3J0IHtpY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xuSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5leHBvcnQge0ljb259O1xuXG5leHBvcnQge0Rpdkljb24sIGRpdkljb259IGZyb20gJy4vRGl2SWNvbic7XG5leHBvcnQge01hcmtlciwgbWFya2VyfSBmcm9tICcuL01hcmtlcic7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG5leHBvcnQgdmFyIEdyaWRMYXllciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG5cdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuXHRcdHRpbGVTaXplOiAyNTYsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSAoZGVwZW5kcylcblx0XHQvLyBMb2FkIG5ldyB0aWxlcyBvbmx5IHdoZW4gcGFubmluZyBlbmRzLlxuXHRcdC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXG5cdFx0Ly8gYGZhbHNlYCBvdGhlcndpc2UgaW4gb3JkZXIgdG8gZGlzcGxheSBuZXcgdGlsZXMgX2R1cmluZ18gcGFubmluZywgc2luY2UgaXQgaXMgZWFzeSB0byBwYW4gb3V0c2lkZSB0aGVcblx0XHQvLyBbYGtlZXBCdWZmZXJgXSgjZ3JpZGxheWVyLWtlZXBidWZmZXIpIG9wdGlvbiBpbiBkZXNrdG9wIGJyb3dzZXJzLlxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBCcm93c2VyLm1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcblx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cblx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fcmVzZXRWaWV3KCk7IC8vIGltcGxpY2l0IF91cGRhdGUoKSBjYWxsXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG5cdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG5cdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHRcdFx0aWYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSkge1xuXHRcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBVdGlsLmZhbHNlRm4sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0eiA9IE51bWJlcih6KTtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0VXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfb25VcGRhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uQ3JlYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbChOdW1iZXIoeikpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aWxlWm9vbSk7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gbGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cblx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcblx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0ZWw6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkcyxcblx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHR9O1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcblx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBOb3RlIHRoYXQgbW9zdCB0aWxlIHNlcnZlcnMgcmVxdWlyZSBhdHRyaWJ1dGlvbiwgd2hpY2ggeW91IGNhbiBzZXQgdW5kZXIgYExheWVyYC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJywgYXR0cmlidXRpb246ICcmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycyd9KS5hZGRUbyhtYXApO1xuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVmZXJyZXJQb2xpY3k6IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC5cclxuXHRcdC8vIFRoaXMgbWF5IGJlIG5lZWRlZCBpZiB5b3VyIG1hcCdzIHJlbmRlcmluZyBjb250ZXh0IGhhcyBhIHN0cmljdCBkZWZhdWx0IGJ1dCB5b3VyIHRpbGUgcHJvdmlkZXIgZXhwZWN0cyBhIHZhbGlkIHJlZmVycmVyXHJcblx0XHQvLyAoZS5nLiB0byB2YWxpZGF0ZSBhbiBBUEkgdG9rZW4pLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0hUTUxJbWFnZUVsZW1lbnQucmVmZXJyZXJQb2xpY3ldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50L3JlZmVycmVyUG9saWN5KSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdHJlZmVycmVyUG9saWN5OiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tID0gTWF0aC5tYXgob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20gLSAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSArIDEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fSBlbHNlIGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgbWF4Wm9vbSBpcyBndGUgbWluWm9vbVxyXG5cdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgbWluWm9vbSBpcyBsdGUgbWF4Wm9vbVxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG5cdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgdGhpcyBuZXcgb3B0aW9uIHdlIGZvbGxvdyB0aGUgZG9jdW1lbnRlZCBiZWhhdmlvclxyXG5cdFx0Ly8gbW9yZSBjbG9zZWx5IGJ5IG9ubHkgc2V0dGluZyB0aGUgcHJvcGVydHkgd2hlbiBzdHJpbmdcclxuXHRcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR0aWxlLnJlZmVycmVyUG9saWN5ID0gdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBhbHQgYXR0cmlidXRlIGlzIHNldCB0byB0aGUgZW1wdHkgc3RyaW5nLFxyXG5cdFx0Ly8gYWxsb3dpbmcgc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoZSBkZWNvcmF0aXZlIGltYWdlIHRpbGVzLlxyXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS90dXRvcmlhbHMvaW1hZ2VzL2RlY29yYXRpdmUvXHJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hcmlhLyNlbC1pbWctZW1wdHktYWx0XHJcblx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuXHQvLyBAdW5pbmhlcml0YWJsZVxyXG5cdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcblx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBVdGlsLmV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcblx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcblx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBVdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHR2YXIgY29vcmRzID0gdGhpcy5fdGlsZXNbaV0uY29vcmRzO1xyXG5cdFx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcblx0XHRcdFx0XHQvLyBAZXZlbnQgdGlsZWFib3J0OiBUaWxlRXZlbnRcclxuXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIHdhcyBsb2FkaW5nIGJ1dCBpcyBub3cgbm90IHdhbnRlZC5cclxuXHRcdFx0XHRcdHRoaXMuZmlyZSgndGlsZWFib3J0Jywge1xyXG5cdFx0XHRcdFx0XHR0aWxlOiB0aWxlLFxyXG5cdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcblx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgVXRpbC5lbXB0eUltYWdlVXJsKTtcclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsIGtleSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAodGlsZSAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IFV0aWwuZW1wdHlJbWFnZVVybCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FUFNHNDMyNic7XHJcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHBzOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XHJcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcblx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcblx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJleHBvcnQge0dyaWRMYXllciwgZ3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XG5pbXBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XG5pbXBvcnQge1RpbGVMYXllcldNUywgdGlsZUxheWVyV01TfSBmcm9tICcuL1RpbGVMYXllci5XTVMnO1xuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5leHBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfTtcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxuZXhwb3J0IHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFV0aWwuc3RhbXAodGhpcyk7XG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0Ly8gYWx3YXlzIGtlZXAgdHJhbnNmb3JtLW9yaWdpbiBhcyAwIDBcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cblx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQoY3VycmVudENlbnRlclBvaW50KVxuXHRcdFx0XHQgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBDYW52YXNcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLkNhbnZhc1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL2NhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENhbnZhcyBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRvbGVyYW5jZTogTnVtYmVyID0gMFxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpY2sgdG9sZXJhbmNlIGFyb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXAuXG5cdFx0dG9sZXJhbmNlOiAwXG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblx0XHRjb250YWluZXJbJ19sZWFmbGV0X2Rpc2FibGVfZXZlbnRzJ10gPSB0cnVlO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuXHRcdHZhciBsYXllcjtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9yZWRyYXcoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgZGFzaFZhbHVlLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcblx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcblx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG5cdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG5cdFx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fZmlyZUV2ZW50KGNsaWNrZWRMYXllciA/IFtjbGlja2VkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdGlmICh0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG5cdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG5cdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyZWRMYXllciA/IFt0aGlzLl9ob3ZlcmVkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXG5cdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH0sIHRoaXMpLCAzMik7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuXG5leHBvcnQgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIERvIG5vdCByZXR1cm4gZm4gZnJvbSBjYXRjaCBibG9jayBzbyBgZWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvcHVsbC83Mjc5XG5cdH1cblx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHR9O1xufSkoKTtcblxuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqXG4gKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqL1xuXG4vLyBtaXhpbiB0byByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuZXhwb3J0IHZhciB2bWxNaXhpbiA9IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSB2bWxDcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG5cdFx0bGF5ZXIuX3BhdGggPSB2bWxDcmVhdGUoJ3BhdGgnKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdERvbVV0aWwucmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zLFxuXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG5cdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuXHRcdGNvbnRhaW5lci5maWxsZWQgPSAhIW9wdGlvbnMuZmlsbDtcblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0aWYgKCFzdHJva2UpIHtcblx0XHRcdFx0c3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSA9IHZtbENyZWF0ZSgnc3Ryb2tlJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuXHR9XG59O1xuIiwiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtzdGFtcH0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7c3ZnQ3JlYXRlLCBwb2ludHNUb1BhdGh9IGZyb20gJy4vU1ZHLlV0aWwnO1xuZXhwb3J0IHtwb2ludHNUb1BhdGh9O1xuaW1wb3J0IHt2bWxNaXhpbiwgdm1sQ3JlYXRlfSBmcm9tICcuL1NWRy5WTUwnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vc3ZnKSwgU1ZHIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAqIHRoaXMgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBjcmVhdGUoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7IHRoaXMuX2luaXRDb250YWluZXIoKTsgfVxuXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnJlbW92ZShsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoKTtcblx0fVxufSk7XG5cbmlmIChCcm93c2VyLnZtbCkge1xuXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG59XG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBzdmcob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5zdmcgfHwgQnJvd3Nlci52bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi8uLi9tYXAvTWFwJztcbmltcG9ydCB7Y2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge3N2Z30gZnJvbSAnLi9TVkcnO1xuXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cblx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcblx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcblx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGlmICghcmVuZGVyZXIpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAqL1xuXG4vKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGFrYSBMLlJlY3RhbmdsZVxuICogQGluaGVyaXRzIFBvbHlnb25cbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICogYGBgXG4gKlxuICovXG5cblxuZXhwb3J0IHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRQb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSk7XG5cdH0sXG5cblx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdGxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XG5cdFx0cmV0dXJuIFtcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuXHRcdF07XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucmVjdGFuZ2xlKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJleHBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmV4cG9ydCB7Q2FudmFzLCBjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7U1ZHLCBjcmVhdGUsIHBvaW50c1RvUGF0aCwgc3ZnfSBmcm9tICcuL1NWRyc7XG5TVkcuY3JlYXRlID0gY3JlYXRlO1xuU1ZHLnBvaW50c1RvUGF0aCA9IHBvaW50c1RvUGF0aDtcbmV4cG9ydCB7U1ZHLCBzdmd9O1xuaW1wb3J0ICcuL1JlbmRlcmVyLmdldFJlbmRlcmVyJztcdC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgbmVlZGVkIGJlY2F1c2UgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbmV4cG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmV4cG9ydCB7Q2lyY2xlTWFya2VyLCBjaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmV4cG9ydCB7Q2lyY2xlLCBjaXJjbGV9IGZyb20gJy4vQ2lyY2xlJztcbmV4cG9ydCB7UG9seWxpbmUsIHBvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmV4cG9ydCB7UG9seWdvbiwgcG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmV4cG9ydCB7UmVjdGFuZ2xlLCByZWN0YW5nbGV9IGZyb20gJy4vUmVjdGFuZ2xlJztcbiIsImV4cG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuZXhwb3J0IHtMYXllckdyb3VwLCBsYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xuZXhwb3J0IHtGZWF0dXJlR3JvdXAsIGZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xuaW1wb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29uLCBnZW9tZXRyeVRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCBjb29yZHNUb0xhdExuZ3MsIGxhdExuZ1RvQ29vcmRzLCBsYXRMbmdzVG9Db29yZHMsIGdldEZlYXR1cmUsIGFzRmVhdHVyZX0gZnJvbSAnLi9HZW9KU09OJztcbkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5HZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcztcbkdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5HZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcbmV4cG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbn07XG5cbmV4cG9ydCB7SW1hZ2VPdmVybGF5LCBpbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmV4cG9ydCB7VmlkZW9PdmVybGF5LCB2aWRlb092ZXJsYXl9IGZyb20gJy4vVmlkZW9PdmVybGF5JztcbmV4cG9ydCB7U1ZHT3ZlcmxheSwgc3ZnT3ZlcmxheX0gZnJvbSAnLi9TVkdPdmVybGF5JztcblxuZXhwb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuZXhwb3J0IHtQb3B1cCwgcG9wdXB9IGZyb20gJy4vUG9wdXAnO1xuZXhwb3J0IHtUb29sdGlwLCB0b29sdGlwfSBmcm9tICcuL1Rvb2x0aXAnO1xuXG5leHBvcnQgKiBmcm9tICcuL21hcmtlci9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3RpbGUvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi92ZWN0b3IvaW5kZXgnO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRkZWxldGUgdGhpcy5fcGFuZTtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG5cdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG5cdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG5cdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cdH0sXG5cblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cblx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4vLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG5cdGluZXJ0aWE6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG5leHBvcnQgdmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gbGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBlLm5vSW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcblx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4vLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7b24sIG9mZiwgc3RvcH0gZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcblx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcblx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG5cdGtleWJvYXJkOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcblx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG5cdGtleWJvYXJkUGFuRGVsdGE6IDgwXG59KTtcblxuZXhwb3J0IHZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0b24oY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9mZnNldDtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuXHRcdFx0aWYgKCFtYXAuX3BhbkFuaW0gfHwgIW1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykge1xuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG5cdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldCh0b1BvaW50KG9mZnNldCksIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHRcdHZhciBuZXdMYXRMbmcgPSBtYXAud3JhcExhdExuZyhtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KG1hcC5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpKTtcblx0XHRcdFx0XHRtYXAucGFuVG8obmV3TGF0TG5nKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNlIHdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbmV4cG9ydCB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuTWFwLlRhcEhvbGQgaXMgdXNlZCB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50IG9uIGxvbmcgaG9sZCxcbiAqIHdoaWNoIG90aGVyd2lzZSBpcyBub3QgZmlyZWQgYnkgbW9iaWxlIFNhZmFyaS5cbiAqL1xuXG52YXIgdGFwSG9sZERlbGF5ID0gNjAwO1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXBIb2xkOiBCb29sZWFuXG5cdC8vIEVuYWJsZXMgc2ltdWxhdGlvbiBvZiBgY29udGV4dG1lbnVgIGV2ZW50LCBkZWZhdWx0IGlzIGB0cnVlYCBmb3IgbW9iaWxlIFNhZmFyaS5cblx0dGFwSG9sZDogQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnNhZmFyaSAmJiBCcm93c2VyLm1vYmlsZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5leHBvcnQgdmFyIFRhcEhvbGQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fY2FuY2VsKCk7XG5cdFx0XHRpZiAoIXRoaXMuX2lzVGFwVmFsaWQoKSkgeyByZXR1cm47IH1cblxuXHRcdFx0Ly8gcHJldmVudCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby90b3VjaC1ldmVudHMvI21vdXNlLWV2ZW50c1xuXHRcdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcblx0XHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9jYW5jZWxDbGlja1ByZXZlbnQpO1xuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0fSwgdGhpcyksIHRhcEhvbGREZWxheSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2NhbmNlbENsaWNrUHJldmVudDogZnVuY3Rpb24gY2FuY2VsQ2xpY2tQcmV2ZW50KCkge1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgY2FuY2VsQ2xpY2tQcmV2ZW50KTtcblx0fSxcblxuXHRfY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCB7XG5cdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0XHRcdHZpZXc6IHdpbmRvdyxcblx0XHRcdC8vIGRldGFpbDogMSxcblx0XHRcdHNjcmVlblg6IGUuc2NyZWVuWCxcblx0XHRcdHNjcmVlblk6IGUuc2NyZWVuWSxcblx0XHRcdGNsaWVudFg6IGUuY2xpZW50WCxcblx0XHRcdGNsaWVudFk6IGUuY2xpZW50WSxcblx0XHRcdC8vIGJ1dHRvbjogMixcblx0XHRcdC8vIGJ1dHRvbnM6IDJcblx0XHR9KTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcEhvbGQ6IEhhbmRsZXJcbi8vIExvbmcgdGFwIGhhbmRsZXIgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCAodXNlZnVsIGluIG1vYmlsZSBTYWZhcmkpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcEhvbGQnLCBUYXBIb2xkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG5cdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG5cdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdC8vIGJyb3dzZXJzLlxuXHR0b3VjaFpvb206IEJyb3dzZXIudG91Y2gsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gVXRpbC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSwgdW5kZWZpbmVkKTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XG5pbXBvcnQge0JveFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuQm94Wm9vbSc7XG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5pbXBvcnQge0RvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20nO1xuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbmltcG9ydCB7RHJhZ30gZnJvbSAnLi9oYW5kbGVyL01hcC5EcmFnJztcbk1hcC5EcmFnID0gRHJhZztcbmltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJy4vaGFuZGxlci9NYXAuS2V5Ym9hcmQnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5pbXBvcnQge1Njcm9sbFdoZWVsWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20nO1xuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbmltcG9ydCB7VGFwSG9sZH0gZnJvbSAnLi9oYW5kbGVyL01hcC5UYXBIb2xkJztcbk1hcC5UYXBIb2xkID0gVGFwSG9sZDtcbmltcG9ydCB7VG91Y2hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRvdWNoWm9vbSc7XG5NYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG5leHBvcnQge01hcCwgY3JlYXRlTWFwIGFzIG1hcH0gZnJvbSAnLi9NYXAnO1xuIl0sIm5hbWVzIjpbImV4dGVuZCIsImRlc3QiLCJpIiwiaiIsImxlbiIsInNyYyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNyZWF0ZSQyIiwiT2JqZWN0IiwiY3JlYXRlIiwiRiIsInByb3RvIiwicHJvdG90eXBlIiwiYmluZCIsImZuIiwib2JqIiwic2xpY2UiLCJBcnJheSIsImFwcGx5IiwiY2FsbCIsImFyZ3MiLCJjb25jYXQiLCJsYXN0SWQiLCJzdGFtcCIsIl9sZWFmbGV0X2lkIiwidGhyb3R0bGUiLCJ0aW1lIiwiY29udGV4dCIsImxvY2siLCJ3cmFwcGVyRm4iLCJsYXRlciIsInNldFRpbWVvdXQiLCJ3cmFwTnVtIiwieCIsInJhbmdlIiwiaW5jbHVkZU1heCIsIm1heCIsIm1pbiIsImQiLCJmYWxzZUZuIiwiZm9ybWF0TnVtIiwibnVtIiwicHJlY2lzaW9uIiwicG93IiwiTWF0aCIsInVuZGVmaW5lZCIsInJvdW5kIiwidHJpbSIsInN0ciIsInJlcGxhY2UiLCJzcGxpdFdvcmRzIiwic3BsaXQiLCJzZXRPcHRpb25zIiwib3B0aW9ucyIsImhhc093blByb3BlcnR5IiwiZ2V0UGFyYW1TdHJpbmciLCJleGlzdGluZ1VybCIsInVwcGVyY2FzZSIsInBhcmFtcyIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0b1VwcGVyQ2FzZSIsImluZGV4T2YiLCJqb2luIiwidGVtcGxhdGVSZSIsInRlbXBsYXRlIiwiZGF0YSIsImtleSIsInZhbHVlIiwiRXJyb3IiLCJpc0FycmF5IiwidG9TdHJpbmciLCJhcnJheSIsImVsIiwiZW1wdHlJbWFnZVVybCIsImdldFByZWZpeGVkIiwibmFtZSIsIndpbmRvdyIsImxhc3RUaW1lIiwidGltZW91dERlZmVyIiwiRGF0ZSIsInRpbWVUb0NhbGwiLCJyZXF1ZXN0Rm4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxGbiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaWQiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0QW5pbUZyYW1lIiwiaW1tZWRpYXRlIiwiY2FuY2VsQW5pbUZyYW1lIiwiQ2xhc3MiLCJwcm9wcyIsIk5ld0NsYXNzIiwiaW5pdGlhbGl6ZSIsImNhbGxJbml0SG9va3MiLCJwYXJlbnRQcm90byIsIl9fc3VwZXJfXyIsImNvbnN0cnVjdG9yIiwic3RhdGljcyIsImluY2x1ZGVzIiwiY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMiLCJfaW5pdEhvb2tzIiwiX2luaXRIb29rc0NhbGxlZCIsImluY2x1ZGUiLCJwYXJlbnRPcHRpb25zIiwibWVyZ2VPcHRpb25zIiwiYWRkSW5pdEhvb2siLCJpbml0IiwiTCIsIk1peGluIiwiRXZlbnRzIiwiY29uc29sZSIsIndhcm4iLCJzdGFjayIsIm9uIiwidHlwZXMiLCJ0eXBlIiwiX29uIiwib2ZmIiwiX2V2ZW50cyIsIl9vZmYiLCJyZW1vdmVBbGwiLCJfb25jZSIsIl9saXN0ZW5zIiwibmV3TGlzdGVuZXIiLCJjdHgiLCJvbmNlIiwibGlzdGVuZXJzIiwiX2ZpcmluZ0NvdW50IiwiaW5kZXgiLCJsaXN0ZW5lciIsInNwbGljZSIsImZpcmUiLCJwcm9wYWdhdGUiLCJsaXN0ZW5zIiwiZXZlbnQiLCJ0YXJnZXQiLCJzb3VyY2VUYXJnZXQiLCJsIiwiX3Byb3BhZ2F0ZUV2ZW50IiwiX2ZuIiwiX2V2ZW50UGFyZW50cyIsImFkZEV2ZW50UGFyZW50IiwicmVtb3ZlRXZlbnRQYXJlbnQiLCJlIiwibGF5ZXIiLCJwcm9wYWdhdGVkRnJvbSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXJBbGxFdmVudExpc3RlbmVycyIsImFkZE9uZVRpbWVFdmVudExpc3RlbmVyIiwiZmlyZUV2ZW50IiwiaGFzRXZlbnRMaXN0ZW5lcnMiLCJFdmVudGVkIiwiUG9pbnQiLCJ5IiwidHJ1bmMiLCJ2IiwiZmxvb3IiLCJjZWlsIiwiY2xvbmUiLCJhZGQiLCJwb2ludCIsIl9hZGQiLCJ0b1BvaW50Iiwic3VidHJhY3QiLCJfc3VidHJhY3QiLCJkaXZpZGVCeSIsIl9kaXZpZGVCeSIsIm11bHRpcGx5QnkiLCJfbXVsdGlwbHlCeSIsInNjYWxlQnkiLCJ1bnNjYWxlQnkiLCJfcm91bmQiLCJfZmxvb3IiLCJfY2VpbCIsIl90cnVuYyIsImRpc3RhbmNlVG8iLCJzcXJ0IiwiZXF1YWxzIiwiY29udGFpbnMiLCJhYnMiLCJCb3VuZHMiLCJhIiwiYiIsInBvaW50cyIsIm1pbjIiLCJtYXgyIiwidG9Cb3VuZHMiLCJnZXRDZW50ZXIiLCJnZXRCb3R0b21MZWZ0IiwiZ2V0VG9wUmlnaHQiLCJnZXRUb3BMZWZ0IiwiZ2V0Qm90dG9tUmlnaHQiLCJnZXRTaXplIiwiaW50ZXJzZWN0cyIsImJvdW5kcyIsInhJbnRlcnNlY3RzIiwieUludGVyc2VjdHMiLCJvdmVybGFwcyIsInhPdmVybGFwcyIsInlPdmVybGFwcyIsImlzVmFsaWQiLCJwYWQiLCJidWZmZXJSYXRpbyIsImhlaWdodEJ1ZmZlciIsIndpZHRoQnVmZmVyIiwiTGF0TG5nQm91bmRzIiwiY29ybmVyMSIsImNvcm5lcjIiLCJsYXRsbmdzIiwic3ciLCJfc291dGhXZXN0IiwibmUiLCJfbm9ydGhFYXN0Iiwic3cyIiwibmUyIiwiTGF0TG5nIiwidG9MYXRMbmciLCJ0b0xhdExuZ0JvdW5kcyIsImxhdCIsImxuZyIsImdldFNvdXRoV2VzdCIsImdldE5vcnRoRWFzdCIsImdldE5vcnRoV2VzdCIsImdldE5vcnRoIiwiZ2V0V2VzdCIsImdldFNvdXRoRWFzdCIsImdldFNvdXRoIiwiZ2V0RWFzdCIsImxhdEludGVyc2VjdHMiLCJsbmdJbnRlcnNlY3RzIiwibGF0T3ZlcmxhcHMiLCJsbmdPdmVybGFwcyIsInRvQkJveFN0cmluZyIsIm1heE1hcmdpbiIsImFsdCIsImlzTmFOIiwibWFyZ2luIiwib3RoZXIiLCJFYXJ0aCIsImRpc3RhbmNlIiwid3JhcCIsIndyYXBMYXRMbmciLCJzaXplSW5NZXRlcnMiLCJsYXRBY2N1cmFjeSIsImxuZ0FjY3VyYWN5IiwiY29zIiwiUEkiLCJjIiwibG9uIiwiQ1JTIiwibGF0TG5nVG9Qb2ludCIsImxhdGxuZyIsInpvb20iLCJwcm9qZWN0ZWRQb2ludCIsInByb2plY3Rpb24iLCJwcm9qZWN0Iiwic2NhbGUiLCJ0cmFuc2Zvcm1hdGlvbiIsIl90cmFuc2Zvcm0iLCJwb2ludFRvTGF0TG5nIiwidW50cmFuc2Zvcm1lZFBvaW50IiwidW50cmFuc2Zvcm0iLCJ1bnByb2plY3QiLCJsb2ciLCJMTjIiLCJnZXRQcm9qZWN0ZWRCb3VuZHMiLCJpbmZpbml0ZSIsInMiLCJ0cmFuc2Zvcm0iLCJ3cmFwTG5nIiwid3JhcExhdCIsIndyYXBMYXRMbmdCb3VuZHMiLCJjZW50ZXIiLCJuZXdDZW50ZXIiLCJsYXRTaGlmdCIsImxuZ1NoaWZ0IiwibmV3U3ciLCJuZXdOZSIsIlIiLCJsYXRsbmcxIiwibGF0bG5nMiIsInJhZCIsImxhdDEiLCJsYXQyIiwic2luRExhdCIsInNpbiIsInNpbkRMb24iLCJhdGFuMiIsImVhcnRoUmFkaXVzIiwiU3BoZXJpY2FsTWVyY2F0b3IiLCJNQVhfTEFUSVRVREUiLCJhdGFuIiwiZXhwIiwiVHJhbnNmb3JtYXRpb24iLCJfYSIsIl9iIiwiX2MiLCJfZCIsInRvVHJhbnNmb3JtYXRpb24iLCJFUFNHMzg1NyIsImNvZGUiLCJFUFNHOTAwOTEzIiwic3ZnQ3JlYXRlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJwb2ludHNUb1BhdGgiLCJyaW5ncyIsImNsb3NlZCIsImxlbjIiLCJwIiwiQnJvd3NlciIsInN2ZyIsInN0eWxlIiwiZG9jdW1lbnRFbGVtZW50IiwiaWUiLCJpZWx0OSIsImVkZ2UiLCJuYXZpZ2F0b3IiLCJ3ZWJraXQiLCJ1c2VyQWdlbnRDb250YWlucyIsImFuZHJvaWQiLCJhbmRyb2lkMjMiLCJ3ZWJraXRWZXIiLCJwYXJzZUludCIsImV4ZWMiLCJ1c2VyQWdlbnQiLCJhbmRyb2lkU3RvY2siLCJvcGVyYSIsImNocm9tZSIsImdlY2tvIiwic2FmYXJpIiwicGhhbnRvbSIsIm9wZXJhMTIiLCJ3aW4iLCJwbGF0Zm9ybSIsImllM2QiLCJ3ZWJraXQzZCIsIldlYktpdENTU01hdHJpeCIsImdlY2tvM2QiLCJhbnkzZCIsIkxfRElTQUJMRV8zRCIsIm1vYmlsZSIsIm9yaWVudGF0aW9uIiwibW9iaWxlV2Via2l0IiwibW9iaWxlV2Via2l0M2QiLCJtc1BvaW50ZXIiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsInBvaW50ZXIiLCJ0b3VjaE5hdGl2ZSIsIlRvdWNoRXZlbnQiLCJ0b3VjaCIsIkxfTk9fVE9VQ0giLCJtb2JpbGVPcGVyYSIsIm1vYmlsZUdlY2tvIiwicmV0aW5hIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNjcmVlbiIsImRldmljZVhEUEkiLCJsb2dpY2FsWERQSSIsInBhc3NpdmVFdmVudHMiLCJzdXBwb3J0c1Bhc3NpdmVPcHRpb24iLCJvcHRzIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJjYW52YXMkMSIsImNyZWF0ZUVsZW1lbnQiLCJnZXRDb250ZXh0Iiwic3ZnJDEiLCJjcmVhdGVTVkdSZWN0IiwiaW5saW5lU3ZnIiwiZGl2IiwiaW5uZXJIVE1MIiwiZmlyc3RDaGlsZCIsIm5hbWVzcGFjZVVSSSIsInZtbCIsInNoYXBlIiwiYmVoYXZpb3IiLCJhZGoiLCJtYWMiLCJsaW51eCIsInRvTG93ZXJDYXNlIiwiY2FudmFzIiwiUE9JTlRFUl9ET1dOIiwiUE9JTlRFUl9NT1ZFIiwiUE9JTlRFUl9VUCIsIlBPSU5URVJfQ0FOQ0VMIiwicEV2ZW50IiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwidG91Y2hjYW5jZWwiLCJoYW5kbGUiLCJfb25Qb2ludGVyU3RhcnQiLCJfaGFuZGxlUG9pbnRlciIsIl9wb2ludGVycyIsIl9wb2ludGVyRG9jTGlzdGVuZXIiLCJhZGRQb2ludGVyTGlzdGVuZXIiLCJoYW5kbGVyIiwiX2FkZFBvaW50ZXJEb2NMaXN0ZW5lciIsInJlbW92ZVBvaW50ZXJMaXN0ZW5lciIsIl9nbG9iYWxQb2ludGVyRG93biIsInBvaW50ZXJJZCIsIl9nbG9iYWxQb2ludGVyTW92ZSIsIl9nbG9iYWxQb2ludGVyVXAiLCJwb2ludGVyVHlwZSIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwidG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiTVNQT0lOVEVSX1RZUEVfVE9VQ0giLCJwcmV2ZW50RGVmYXVsdCIsIm1ha2VEYmxjbGljayIsIm5ld0V2ZW50IiwicHJvcCIsImRldGFpbCIsImlzVHJ1c3RlZCIsIl9zaW11bGF0ZWQiLCJkZWxheSIsImFkZERvdWJsZVRhcExpc3RlbmVyIiwibGFzdCIsInNpbURibGNsaWNrIiwic291cmNlQ2FwYWJpbGl0aWVzIiwiZmlyZXNUb3VjaEV2ZW50cyIsInBhdGgiLCJnZXRQcm9wYWdhdGlvblBhdGgiLCJzb21lIiwiSFRNTExhYmVsRWxlbWVudCIsImF0dHJpYnV0ZXMiLCJmb3IiLCJIVE1MSW5wdXRFbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJub3ciLCJkYmxjbGljayIsInJlbW92ZURvdWJsZVRhcExpc3RlbmVyIiwiaGFuZGxlcnMiLCJUUkFOU0ZPUk0iLCJ0ZXN0UHJvcCIsIlRSQU5TSVRJT04iLCJUUkFOU0lUSU9OX0VORCIsImdldEVsZW1lbnRCeUlkIiwiZ2V0U3R5bGUiLCJjdXJyZW50U3R5bGUiLCJkZWZhdWx0VmlldyIsImNzcyIsImdldENvbXB1dGVkU3R5bGUiLCJjcmVhdGUkMSIsInRhZ05hbWUiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJhcHBlbmRDaGlsZCIsInJlbW92ZSIsInBhcmVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImVtcHR5IiwidG9Gcm9udCIsImxhc3RDaGlsZCIsInRvQmFjayIsImluc2VydEJlZm9yZSIsImhhc0NsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0Q2xhc3MiLCJSZWdFeHAiLCJ0ZXN0IiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwic2V0Q2xhc3MiLCJyZW1vdmVDbGFzcyIsImJhc2VWYWwiLCJjb3JyZXNwb25kaW5nRWxlbWVudCIsInNldE9wYWNpdHkiLCJvcGFjaXR5IiwiX3NldE9wYWNpdHlJRSIsImZpbHRlciIsImZpbHRlck5hbWUiLCJmaWx0ZXJzIiwiaXRlbSIsIkVuYWJsZWQiLCJPcGFjaXR5Iiwic2V0VHJhbnNmb3JtIiwib2Zmc2V0IiwicG9zIiwic2V0UG9zaXRpb24iLCJfbGVhZmxldF9wb3MiLCJsZWZ0IiwidG9wIiwiZ2V0UG9zaXRpb24iLCJkaXNhYmxlVGV4dFNlbGVjdGlvbiIsImVuYWJsZVRleHRTZWxlY3Rpb24iLCJfdXNlclNlbGVjdCIsInVzZXJTZWxlY3RQcm9wZXJ0eSIsImRpc2FibGVJbWFnZURyYWciLCJlbmFibGVJbWFnZURyYWciLCJfb3V0bGluZUVsZW1lbnQiLCJfb3V0bGluZVN0eWxlIiwicHJldmVudE91dGxpbmUiLCJlbGVtZW50IiwidGFiSW5kZXgiLCJyZXN0b3JlT3V0bGluZSIsIm91dGxpbmVTdHlsZSIsImdldFNpemVkUGFyZW50Tm9kZSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiYm9keSIsImdldFNjYWxlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiYm91bmRpbmdDbGllbnRSZWN0IiwiYWRkT25lIiwiZXZlbnRzS2V5IiwiYmF0Y2hSZW1vdmUiLCJyZW1vdmVPbmUiLCJmaWx0ZXJGbiIsIm1vdXNlU3Vic3QiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIndoZWVsIiwib3JpZ2luYWxIYW5kbGVyIiwicGFzc2l2ZSIsImlzRXh0ZXJuYWxUYXJnZXQiLCJhdHRhY2hFdmVudCIsImRldGFjaEV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwib3JpZ2luYWxFdmVudCIsIl9zdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwiZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uIiwiZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24iLCJyZXR1cm5WYWx1ZSIsInN0b3AiLCJldiIsImNvbXBvc2VkUGF0aCIsImdldE1vdXNlUG9zaXRpb24iLCJjbGllbnRYIiwiY2xpZW50WSIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJ3aGVlbFB4RmFjdG9yIiwiZ2V0V2hlZWxEZWx0YSIsIndoZWVsRGVsdGFZIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwiZGVsdGFYIiwiZGVsdGFaIiwid2hlZWxEZWx0YSIsInJlbGF0ZWQiLCJyZWxhdGVkVGFyZ2V0IiwiZXJyIiwiUG9zQW5pbWF0aW9uIiwicnVuIiwibmV3UG9zIiwiZHVyYXRpb24iLCJlYXNlTGluZWFyaXR5IiwiX2VsIiwiX2luUHJvZ3Jlc3MiLCJfZHVyYXRpb24iLCJfZWFzZU91dFBvd2VyIiwiX3N0YXJ0UG9zIiwiX29mZnNldCIsIl9zdGFydFRpbWUiLCJfYW5pbWF0ZSIsIl9zdGVwIiwiX2NvbXBsZXRlIiwiX2FuaW1JZCIsImVsYXBzZWQiLCJfcnVuRnJhbWUiLCJfZWFzZU91dCIsInByb2dyZXNzIiwidCIsIk1hcCIsImNycyIsIm1pblpvb20iLCJtYXhab29tIiwibGF5ZXJzIiwibWF4Qm91bmRzIiwicmVuZGVyZXIiLCJ6b29tQW5pbWF0aW9uIiwiem9vbUFuaW1hdGlvblRocmVzaG9sZCIsImZhZGVBbmltYXRpb24iLCJtYXJrZXJab29tQW5pbWF0aW9uIiwidHJhbnNmb3JtM0RMaW1pdCIsInpvb21TbmFwIiwiem9vbURlbHRhIiwidHJhY2tSZXNpemUiLCJfaGFuZGxlcnMiLCJfbGF5ZXJzIiwiX3pvb21Cb3VuZExheWVycyIsIl9zaXplQ2hhbmdlZCIsIl9pbml0Q29udGFpbmVyIiwiX2luaXRMYXlvdXQiLCJfb25SZXNpemUiLCJfaW5pdEV2ZW50cyIsInNldE1heEJvdW5kcyIsIl96b29tIiwiX2xpbWl0Wm9vbSIsInNldFZpZXciLCJyZXNldCIsIl96b29tQW5pbWF0ZWQiLCJfY3JlYXRlQW5pbVByb3h5IiwiX3Byb3h5IiwiX2NhdGNoVHJhbnNpdGlvbkVuZCIsIl9hZGRMYXllcnMiLCJfbGltaXRDZW50ZXIiLCJfc3RvcCIsIl9sb2FkZWQiLCJhbmltYXRlIiwicGFuIiwibW92ZWQiLCJfdHJ5QW5pbWF0ZWRab29tIiwiX3RyeUFuaW1hdGVkUGFuIiwiX3NpemVUaW1lciIsIl9yZXNldFZpZXciLCJub01vdmVTdGFydCIsInNldFpvb20iLCJ6b29tSW4iLCJkZWx0YSIsInpvb21PdXQiLCJzZXRab29tQXJvdW5kIiwiZ2V0Wm9vbVNjYWxlIiwidmlld0hhbGYiLCJjb250YWluZXJQb2ludCIsImxhdExuZ1RvQ29udGFpbmVyUG9pbnQiLCJjZW50ZXJPZmZzZXQiLCJjb250YWluZXJQb2ludFRvTGF0TG5nIiwiX2dldEJvdW5kc0NlbnRlclpvb20iLCJnZXRCb3VuZHMiLCJwYWRkaW5nVEwiLCJwYWRkaW5nVG9wTGVmdCIsInBhZGRpbmciLCJwYWRkaW5nQlIiLCJwYWRkaW5nQm90dG9tUmlnaHQiLCJnZXRCb3VuZHNab29tIiwiSW5maW5pdHkiLCJwYWRkaW5nT2Zmc2V0Iiwic3dQb2ludCIsIm5lUG9pbnQiLCJmaXRCb3VuZHMiLCJmaXRXb3JsZCIsInBhblRvIiwicGFuQnkiLCJnZXRab29tIiwiX3BhbkFuaW0iLCJfb25QYW5UcmFuc2l0aW9uU3RlcCIsIl9vblBhblRyYW5zaXRpb25FbmQiLCJfbWFwUGFuZSIsIl9nZXRNYXBQYW5lUG9zIiwiX3Jhd1BhbkJ5IiwiZmx5VG8iLCJ0YXJnZXRDZW50ZXIiLCJ0YXJnZXRab29tIiwiZnJvbSIsInRvIiwic2l6ZSIsInN0YXJ0Wm9vbSIsIncwIiwidzEiLCJ1MSIsInJobyIsInJobzIiLCJyIiwiczEiLCJzMiIsInQxIiwiYjEiLCJzcSIsInNpbmgiLCJuIiwiY29zaCIsInRhbmgiLCJyMCIsInciLCJ1IiwiZWFzZU91dCIsInN0YXJ0IiwiUyIsImZyYW1lIiwiX2ZseVRvRnJhbWUiLCJfbW92ZSIsImdldFNjYWxlWm9vbSIsIl9tb3ZlRW5kIiwiX21vdmVTdGFydCIsImZseVRvQm91bmRzIiwiX3Bhbkluc2lkZU1heEJvdW5kcyIsInNldE1pblpvb20iLCJvbGRab29tIiwic2V0TWF4Wm9vbSIsInBhbkluc2lkZUJvdW5kcyIsIl9lbmZvcmNpbmdCb3VuZHMiLCJwYW5JbnNpZGUiLCJwaXhlbENlbnRlciIsInBpeGVsUG9pbnQiLCJwaXhlbEJvdW5kcyIsImdldFBpeGVsQm91bmRzIiwicGFkZGVkQm91bmRzIiwicGFkZGVkU2l6ZSIsImludmFsaWRhdGVTaXplIiwib2xkU2l6ZSIsIl9sYXN0Q2VudGVyIiwibmV3U2l6ZSIsIm9sZENlbnRlciIsImRlYm91bmNlTW92ZWVuZCIsImxvY2F0ZSIsIl9sb2NhdGVPcHRpb25zIiwidGltZW91dCIsIndhdGNoIiwiX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IiLCJtZXNzYWdlIiwib25SZXNwb25zZSIsIl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlIiwib25FcnJvciIsIl9sb2NhdGlvbldhdGNoSWQiLCJnZW9sb2NhdGlvbiIsIndhdGNoUG9zaXRpb24iLCJnZXRDdXJyZW50UG9zaXRpb24iLCJzdG9wTG9jYXRlIiwiY2xlYXJXYXRjaCIsImVycm9yIiwiX2NvbnRhaW5lciIsImNvb3JkcyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiYWNjdXJhY3kiLCJ0aW1lc3RhbXAiLCJhZGRIYW5kbGVyIiwiSGFuZGxlckNsYXNzIiwiZW5hYmxlIiwiX2NvbnRhaW5lcklkIiwiX2NsZWFyQ29udHJvbFBvcyIsIl9yZXNpemVSZXF1ZXN0IiwiX2NsZWFySGFuZGxlcnMiLCJfcGFuZXMiLCJfcmVuZGVyZXIiLCJjcmVhdGVQYW5lIiwicGFuZSIsIl9jaGVja0lmTG9hZGVkIiwiX21vdmVkIiwibGF5ZXJQb2ludFRvTGF0TG5nIiwiX2dldENlbnRlckxheWVyUG9pbnQiLCJnZXRNaW5ab29tIiwiX2xheWVyc01pblpvb20iLCJnZXRNYXhab29tIiwiX2xheWVyc01heFpvb20iLCJpbnNpZGUiLCJudyIsInNlIiwiYm91bmRzU2l6ZSIsInNuYXAiLCJzY2FsZXgiLCJzY2FsZXkiLCJfc2l6ZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwidG9wTGVmdFBvaW50IiwiX2dldFRvcExlZnRQb2ludCIsImdldFBpeGVsT3JpZ2luIiwiX3BpeGVsT3JpZ2luIiwiZ2V0UGl4ZWxXb3JsZEJvdW5kcyIsImdldFBhbmUiLCJnZXRQYW5lcyIsImdldENvbnRhaW5lciIsInRvWm9vbSIsImZyb21ab29tIiwibGF0TG5nVG9MYXllclBvaW50IiwiY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQiLCJsYXllclBvaW50VG9Db250YWluZXJQb2ludCIsImxheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCIsIm1vdXNlRXZlbnRUb0xheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9MYXRMbmciLCJfb25TY3JvbGwiLCJfZmFkZUFuaW1hdGVkIiwicG9zaXRpb24iLCJfaW5pdFBhbmVzIiwiX2luaXRDb250cm9sUG9zIiwicGFuZXMiLCJfcGFuZVJlbmRlcmVycyIsIm1hcmtlclBhbmUiLCJzaGFkb3dQYW5lIiwibG9hZGluZyIsInpvb21DaGFuZ2VkIiwic3VwcmVzc0V2ZW50IiwiX2dldE5ld1BpeGVsT3JpZ2luIiwicGluY2giLCJfZ2V0Wm9vbVNwYW4iLCJfdGFyZ2V0cyIsIm9uT2ZmIiwiX2hhbmRsZURPTUV2ZW50IiwiX29uTW92ZUVuZCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJfZmluZEV2ZW50VGFyZ2V0cyIsInRhcmdldHMiLCJpc0hvdmVyIiwic3JjRWxlbWVudCIsImRyYWdnaW5nIiwiX2RyYWdnYWJsZU1vdmVkIiwiX2lzQ2xpY2tEaXNhYmxlZCIsIl9maXJlRE9NRXZlbnQiLCJfbW91c2VFdmVudHMiLCJjYW52YXNUYXJnZXRzIiwic3ludGgiLCJmaWx0ZXJlZCIsImlzTWFya2VyIiwiZ2V0TGF0TG5nIiwiX3JhZGl1cyIsImJ1YmJsaW5nTW91c2VFdmVudHMiLCJlbmFibGVkIiwiYm94Wm9vbSIsImRpc2FibGUiLCJ3aGVuUmVhZHkiLCJjYWxsYmFjayIsInBpeGVsT3JpZ2luIiwiX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCIsInRvcExlZnQiLCJfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyIsImxhdExuZ0JvdW5kcyIsIl9nZXRDZW50ZXJPZmZzZXQiLCJjZW50ZXJQb2ludCIsInZpZXdCb3VuZHMiLCJfZ2V0Qm91bmRzT2Zmc2V0IiwiX2xpbWl0T2Zmc2V0IiwibmV3Qm91bmRzIiwicHhCb3VuZHMiLCJwcm9qZWN0ZWRNYXhCb3VuZHMiLCJtaW5PZmZzZXQiLCJtYXhPZmZzZXQiLCJkeCIsIl9yZWJvdW5kIiwiZHkiLCJyaWdodCIsInByb3h5IiwibWFwUGFuZSIsIl9hbmltYXRpbmdab29tIiwiX29uWm9vbVRyYW5zaXRpb25FbmQiLCJfYW5pbU1vdmVFbmQiLCJfZGVzdHJveUFuaW1Qcm94eSIsInoiLCJwcm9wZXJ0eU5hbWUiLCJfbm90aGluZ1RvQW5pbWF0ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfYW5pbWF0ZVpvb20iLCJzdGFydEFuaW0iLCJub1VwZGF0ZSIsIl9hbmltYXRlVG9DZW50ZXIiLCJfYW5pbWF0ZVRvWm9vbSIsIl90ZW1wRmlyZVpvb21FdmVudCIsImNyZWF0ZU1hcCIsIkNvbnRyb2wiLCJtYXAiLCJfbWFwIiwicmVtb3ZlQ29udHJvbCIsImFkZENvbnRyb2wiLCJhZGRUbyIsIm9uQWRkIiwiY29ybmVyIiwiX2NvbnRyb2xDb3JuZXJzIiwib25SZW1vdmUiLCJfcmVmb2N1c09uTWFwIiwic2NyZWVuWCIsInNjcmVlblkiLCJmb2N1cyIsImNvbnRyb2wiLCJjb3JuZXJzIiwiX2NvbnRyb2xDb250YWluZXIiLCJjcmVhdGVDb3JuZXIiLCJ2U2lkZSIsImhTaWRlIiwiTGF5ZXJzIiwiY29sbGFwc2VkIiwiYXV0b1pJbmRleCIsImhpZGVTaW5nbGVCYXNlIiwic29ydExheWVycyIsInNvcnRGdW5jdGlvbiIsImxheWVyQSIsImxheWVyQiIsIm5hbWVBIiwibmFtZUIiLCJiYXNlTGF5ZXJzIiwib3ZlcmxheXMiLCJfbGF5ZXJDb250cm9sSW5wdXRzIiwiX2xhc3RaSW5kZXgiLCJfaGFuZGxpbmdDbGljayIsIl9wcmV2ZW50Q2xpY2siLCJfYWRkTGF5ZXIiLCJfdXBkYXRlIiwiX2NoZWNrRGlzYWJsZWRMYXllcnMiLCJfb25MYXllckNoYW5nZSIsIl9leHBhbmRJZk5vdENvbGxhcHNlZCIsImFkZEJhc2VMYXllciIsImFkZE92ZXJsYXkiLCJyZW1vdmVMYXllciIsIl9nZXRMYXllciIsImV4cGFuZCIsIl9zZWN0aW9uIiwiYWNjZXB0YWJsZUhlaWdodCIsIm9mZnNldFRvcCIsImNvbGxhcHNlIiwic2V0QXR0cmlidXRlIiwic2VjdGlvbiIsIl9leHBhbmRTYWZlbHkiLCJsaW5rIiwiX2xheWVyc0xpbmsiLCJocmVmIiwidGl0bGUiLCJrZXlkb3duIiwia2V5Q29kZSIsImNsaWNrIiwiX2Jhc2VMYXllcnNMaXN0IiwiX3NlcGFyYXRvciIsIl9vdmVybGF5c0xpc3QiLCJvdmVybGF5Iiwic29ydCIsInNldFpJbmRleCIsImJhc2VMYXllcnNQcmVzZW50Iiwib3ZlcmxheXNQcmVzZW50IiwiYmFzZUxheWVyc0NvdW50IiwiX2FkZEl0ZW0iLCJkaXNwbGF5IiwiX2NyZWF0ZVJhZGlvRWxlbWVudCIsImNoZWNrZWQiLCJyYWRpb0h0bWwiLCJyYWRpb0ZyYWdtZW50IiwibGFiZWwiLCJoYXNMYXllciIsImlucHV0IiwiZGVmYXVsdENoZWNrZWQiLCJsYXllcklkIiwiX29uSW5wdXRDbGljayIsImhvbGRlciIsImlucHV0cyIsImFkZGVkTGF5ZXJzIiwicmVtb3ZlZExheWVycyIsImFkZExheWVyIiwiZGlzYWJsZWQiLCJ0aGF0IiwiWm9vbSIsInpvb21JblRleHQiLCJ6b29tSW5UaXRsZSIsInpvb21PdXRUZXh0Iiwiem9vbU91dFRpdGxlIiwiem9vbU5hbWUiLCJfem9vbUluQnV0dG9uIiwiX2NyZWF0ZUJ1dHRvbiIsIl96b29tSW4iLCJfem9vbU91dEJ1dHRvbiIsIl96b29tT3V0IiwiX3VwZGF0ZURpc2FibGVkIiwiX2Rpc2FibGVkIiwic2hpZnRLZXkiLCJodG1sIiwiem9vbUNvbnRyb2wiLCJTY2FsZSIsIm1heFdpZHRoIiwibWV0cmljIiwiaW1wZXJpYWwiLCJfYWRkU2NhbGVzIiwidXBkYXRlV2hlbklkbGUiLCJfbVNjYWxlIiwiX2lTY2FsZSIsIm1heE1ldGVycyIsIl91cGRhdGVTY2FsZXMiLCJfdXBkYXRlTWV0cmljIiwiX3VwZGF0ZUltcGVyaWFsIiwibWV0ZXJzIiwiX2dldFJvdW5kTnVtIiwiX3VwZGF0ZVNjYWxlIiwibWF4RmVldCIsIm1heE1pbGVzIiwibWlsZXMiLCJmZWV0IiwidGV4dCIsInJhdGlvIiwicG93MTAiLCJ1a3JhaW5pYW5GbGFnIiwiQXR0cmlidXRpb24iLCJwcmVmaXgiLCJfYXR0cmlidXRpb25zIiwiYXR0cmlidXRpb25Db250cm9sIiwiZ2V0QXR0cmlidXRpb24iLCJhZGRBdHRyaWJ1dGlvbiIsIl9hZGRBdHRyaWJ1dGlvbiIsInJlbW92ZUF0dHJpYnV0aW9uIiwic2V0UHJlZml4IiwiYXR0cmlicyIsInByZWZpeEFuZEF0dHJpYnMiLCJhdHRyaWJ1dGlvbiIsIkhhbmRsZXIiLCJfZW5hYmxlZCIsImFkZEhvb2tzIiwicmVtb3ZlSG9va3MiLCJTVEFSVCIsIkRyYWdnYWJsZSIsImNsaWNrVG9sZXJhbmNlIiwiZHJhZ1N0YXJ0VGFyZ2V0IiwiX2VsZW1lbnQiLCJfZHJhZ1N0YXJ0VGFyZ2V0IiwiX3ByZXZlbnRPdXRsaW5lIiwiX29uRG93biIsIl9kcmFnZ2luZyIsImZpbmlzaERyYWciLCJ3aGljaCIsImJ1dHRvbiIsIl9tb3ZpbmciLCJmaXJzdCIsInNpemVkUGFyZW50IiwiX3N0YXJ0UG9pbnQiLCJfcGFyZW50U2NhbGUiLCJtb3VzZWV2ZW50IiwiX29uTW92ZSIsIl9vblVwIiwiX2xhc3RUYXJnZXQiLCJTVkdFbGVtZW50SW5zdGFuY2UiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsIl9uZXdQb3MiLCJfbGFzdEV2ZW50IiwiX3VwZGF0ZVBvc2l0aW9uIiwibm9JbmVydGlhIiwiZmlyZURyYWdlbmQiLCJjbGlwUG9seWdvbiIsImNsaXBwZWRQb2ludHMiLCJlZGdlcyIsImsiLCJfY29kZSIsIl9nZXRCaXRDb2RlIiwiX2dldEVkZ2VJbnRlcnNlY3Rpb24iLCJwb2x5Z29uQ2VudGVyIiwicDEiLCJwMiIsImYiLCJhcmVhIiwiaXNGbGF0IiwiY2VudHJvaWRMYXRMbmciLCJhcmVhQm91bmRzIiwiY2VudHJvaWQiLCJsYXRsbmdDZW50ZXIiLCJsYXRTdW0iLCJsbmdTdW0iLCJzaW1wbGlmeSIsInRvbGVyYW5jZSIsInNxVG9sZXJhbmNlIiwiX3JlZHVjZVBvaW50cyIsIl9zaW1wbGlmeURQIiwicG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsIl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCIsImNsb3Nlc3RQb2ludE9uU2VnbWVudCIsIkFycmF5Q29uc3RydWN0b3IiLCJVaW50OEFycmF5IiwibWFya2VycyIsIl9zaW1wbGlmeURQU3RlcCIsIm5ld1BvaW50cyIsIm1heFNxRGlzdCIsInNxRGlzdCIsInJlZHVjZWRQb2ludHMiLCJwcmV2IiwiX3NxRGlzdCIsIl9sYXN0Q29kZSIsImNsaXBTZWdtZW50IiwidXNlTGFzdENvZGUiLCJjb2RlQSIsImNvZGVCIiwiY29kZU91dCIsIm5ld0NvZGUiLCJkb3QiLCJfZmxhdCIsInBvbHlsaW5lQ2VudGVyIiwiaGFsZkRpc3QiLCJzZWdEaXN0IiwiZGlzdCIsIkxvbkxhdCIsIk1lcmNhdG9yIiwiUl9NSU5PUiIsInRtcCIsImNvbiIsInRzIiwidGFuIiwicGhpIiwiZHBoaSIsIkVQU0czMzk1IiwiRVBTRzQzMjYiLCJTaW1wbGUiLCJMYXllciIsInJlbW92ZUZyb20iLCJfbWFwVG9BZGQiLCJhZGRJbnRlcmFjdGl2ZVRhcmdldCIsInRhcmdldEVsIiwicmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQiLCJfbGF5ZXJBZGQiLCJnZXRFdmVudHMiLCJldmVudHMiLCJiZWZvcmVBZGQiLCJlYWNoTGF5ZXIiLCJtZXRob2QiLCJfYWRkWm9vbUxpbWl0IiwiX3VwZGF0ZVpvb21MZXZlbHMiLCJfcmVtb3ZlWm9vbUxpbWl0Iiwib2xkWm9vbVNwYW4iLCJMYXllckdyb3VwIiwiZ2V0TGF5ZXJJZCIsImNsZWFyTGF5ZXJzIiwiaW52b2tlIiwibWV0aG9kTmFtZSIsImdldExheWVyIiwiZ2V0TGF5ZXJzIiwiekluZGV4IiwibGF5ZXJHcm91cCIsIkZlYXR1cmVHcm91cCIsInNldFN0eWxlIiwiYnJpbmdUb0Zyb250IiwiYnJpbmdUb0JhY2siLCJmZWF0dXJlR3JvdXAiLCJJY29uIiwicG9wdXBBbmNob3IiLCJ0b29sdGlwQW5jaG9yIiwiY3Jvc3NPcmlnaW4iLCJjcmVhdGVJY29uIiwib2xkSWNvbiIsIl9jcmVhdGVJY29uIiwiY3JlYXRlU2hhZG93IiwiX2dldEljb25VcmwiLCJpbWciLCJfY3JlYXRlSW1nIiwiX3NldEljb25TdHlsZXMiLCJzaXplT3B0aW9uIiwiYW5jaG9yIiwic2hhZG93QW5jaG9yIiwiaWNvbkFuY2hvciIsIm1hcmdpbkxlZnQiLCJtYXJnaW5Ub3AiLCJpY29uIiwiSWNvbkRlZmF1bHQiLCJpY29uVXJsIiwiaWNvblJldGluYVVybCIsInNoYWRvd1VybCIsImljb25TaXplIiwic2hhZG93U2l6ZSIsImltYWdlUGF0aCIsIl9kZXRlY3RJY29uUGF0aCIsIl9zdHJpcFVybCIsInN0cmlwIiwicmUiLCJpZHgiLCJtYXRjaCIsInF1ZXJ5U2VsZWN0b3IiLCJzdWJzdHJpbmciLCJNYXJrZXJEcmFnIiwibWFya2VyIiwiX21hcmtlciIsIl9pY29uIiwiX2RyYWdnYWJsZSIsImRyYWdzdGFydCIsIl9vbkRyYWdTdGFydCIsInByZWRyYWciLCJfb25QcmVEcmFnIiwiZHJhZyIsIl9vbkRyYWciLCJkcmFnZW5kIiwiX29uRHJhZ0VuZCIsIl9hZGp1c3RQYW4iLCJzcGVlZCIsImF1dG9QYW5TcGVlZCIsImF1dG9QYW5QYWRkaW5nIiwiaWNvblBvcyIsIm9yaWdpbiIsInBhbkJvdW5kcyIsIm1vdmVtZW50IiwiX3BhblJlcXVlc3QiLCJfb2xkTGF0TG5nIiwiY2xvc2VQb3B1cCIsImF1dG9QYW4iLCJzaGFkb3ciLCJfc2hhZG93IiwiX2xhdGxuZyIsIm9sZExhdExuZyIsIk1hcmtlciIsImludGVyYWN0aXZlIiwia2V5Ym9hcmQiLCJ6SW5kZXhPZmZzZXQiLCJyaXNlT25Ib3ZlciIsInJpc2VPZmZzZXQiLCJhdXRvUGFuT25Gb2N1cyIsImRyYWdnYWJsZSIsIl9pbml0SWNvbiIsInVwZGF0ZSIsIl9yZW1vdmVJY29uIiwiX3JlbW92ZVNoYWRvdyIsInZpZXdyZXNldCIsInNldExhdExuZyIsInNldFpJbmRleE9mZnNldCIsImdldEljb24iLCJzZXRJY29uIiwiX3BvcHVwIiwiYmluZFBvcHVwIiwiZ2V0RWxlbWVudCIsIl9zZXRQb3MiLCJjbGFzc1RvQWRkIiwiYWRkSWNvbiIsIm1vdXNlb3ZlciIsIl9icmluZ1RvRnJvbnQiLCJtb3VzZW91dCIsIl9yZXNldFpJbmRleCIsIl9wYW5PbkZvY3VzIiwibmV3U2hhZG93IiwiYWRkU2hhZG93IiwiX3VwZGF0ZU9wYWNpdHkiLCJfaW5pdEludGVyYWN0aW9uIiwiX3pJbmRleCIsIl91cGRhdGVaSW5kZXgiLCJvcHQiLCJpY29uT3B0cyIsIl9nZXRQb3B1cEFuY2hvciIsIl9nZXRUb29sdGlwQW5jaG9yIiwiUGF0aCIsInN0cm9rZSIsImNvbG9yIiwid2VpZ2h0IiwibGluZUNhcCIsImxpbmVKb2luIiwiZGFzaEFycmF5IiwiZGFzaE9mZnNldCIsImZpbGwiLCJmaWxsQ29sb3IiLCJmaWxsT3BhY2l0eSIsImZpbGxSdWxlIiwiZ2V0UmVuZGVyZXIiLCJfaW5pdFBhdGgiLCJfcmVzZXQiLCJfYWRkUGF0aCIsIl9yZW1vdmVQYXRoIiwicmVkcmF3IiwiX3VwZGF0ZVBhdGgiLCJfdXBkYXRlU3R5bGUiLCJfdXBkYXRlQm91bmRzIiwiX2JyaW5nVG9CYWNrIiwiX3BhdGgiLCJfcHJvamVjdCIsIl9jbGlja1RvbGVyYW5jZSIsIkNpcmNsZU1hcmtlciIsInJhZGl1cyIsInNldFJhZGl1cyIsImdldFJhZGl1cyIsIl9wb2ludCIsInIyIiwiX3JhZGl1c1kiLCJfcHhCb3VuZHMiLCJfdXBkYXRlQ2lyY2xlIiwiX2VtcHR5IiwiX2JvdW5kcyIsIl9jb250YWluc1BvaW50IiwiY2lyY2xlTWFya2VyIiwiQ2lyY2xlIiwibGVnYWN5T3B0aW9ucyIsIl9tUmFkaXVzIiwiaGFsZiIsImxhdFIiLCJib3R0b20iLCJsbmdSIiwiYWNvcyIsImNpcmNsZSIsIlBvbHlsaW5lIiwic21vb3RoRmFjdG9yIiwibm9DbGlwIiwiX3NldExhdExuZ3MiLCJnZXRMYXRMbmdzIiwiX2xhdGxuZ3MiLCJzZXRMYXRMbmdzIiwiaXNFbXB0eSIsImNsb3Nlc3RMYXllclBvaW50IiwibWluRGlzdGFuY2UiLCJtaW5Qb2ludCIsImNsb3Nlc3QiLCJqTGVuIiwiX3BhcnRzIiwiX2RlZmF1bHRTaGFwZSIsImFkZExhdExuZyIsIl9jb252ZXJ0TGF0TG5ncyIsInJlc3VsdCIsImZsYXQiLCJfcmluZ3MiLCJfcHJvamVjdExhdGxuZ3MiLCJfcmF3UHhCb3VuZHMiLCJwcm9qZWN0ZWRCb3VuZHMiLCJyaW5nIiwiX2NsaXBQb2ludHMiLCJwYXJ0cyIsInNlZ21lbnQiLCJfc2ltcGxpZnlQb2ludHMiLCJfdXBkYXRlUG9seSIsInBhcnQiLCJwb2x5bGluZSIsIlBvbHlnb24iLCJwb3AiLCJjbGlwcGVkIiwicG9seWdvbiIsIkdlb0pTT04iLCJnZW9qc29uIiwiYWRkRGF0YSIsImZlYXR1cmVzIiwiZmVhdHVyZSIsImdlb21ldHJpZXMiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwiZ2VvbWV0cnlUb0xheWVyIiwiYXNGZWF0dXJlIiwiZGVmYXVsdE9wdGlvbnMiLCJyZXNldFN0eWxlIiwib25FYWNoRmVhdHVyZSIsIl9zZXRMYXllclN0eWxlIiwicG9pbnRUb0xheWVyIiwiX2Nvb3Jkc1RvTGF0TG5nIiwiY29vcmRzVG9MYXRMbmciLCJfcG9pbnRUb0xheWVyIiwiY29vcmRzVG9MYXRMbmdzIiwiZ2VvTGF5ZXIiLCJwcm9wZXJ0aWVzIiwiZmVhdHVyZUxheWVyIiwicG9pbnRUb0xheWVyRm4iLCJtYXJrZXJzSW5oZXJpdE9wdGlvbnMiLCJsZXZlbHNEZWVwIiwibGF0TG5nVG9Db29yZHMiLCJsYXRMbmdzVG9Db29yZHMiLCJnZXRGZWF0dXJlIiwibmV3R2VvbWV0cnkiLCJQb2ludFRvR2VvSlNPTiIsInRvR2VvSlNPTiIsIm11bHRpIiwiaG9sZXMiLCJ0b011bHRpUG9pbnQiLCJpc0dlb21ldHJ5Q29sbGVjdGlvbiIsImpzb25zIiwianNvbiIsImdlb0pTT04iLCJnZW9Kc29uIiwiSW1hZ2VPdmVybGF5IiwiZXJyb3JPdmVybGF5VXJsIiwidXJsIiwiX3VybCIsIl9pbWFnZSIsIl9pbml0SW1hZ2UiLCJzdHlsZU9wdHMiLCJzZXRVcmwiLCJzZXRCb3VuZHMiLCJ6b29tYW5pbSIsIndhc0VsZW1lbnRTdXBwbGllZCIsIm9uc2VsZWN0c3RhcnQiLCJvbm1vdXNlbW92ZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJfb3ZlcmxheU9uRXJyb3IiLCJpbWFnZSIsImVycm9yVXJsIiwiaW1hZ2VPdmVybGF5IiwiVmlkZW9PdmVybGF5IiwiYXV0b3BsYXkiLCJsb29wIiwia2VlcEFzcGVjdFJhdGlvIiwibXV0ZWQiLCJwbGF5c0lubGluZSIsInZpZCIsIm9ubG9hZGVkZGF0YSIsInNvdXJjZUVsZW1lbnRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzb3VyY2VzIiwic291cmNlIiwidmlkZW9PdmVybGF5IiwidmlkZW8iLCJTVkdPdmVybGF5Iiwic3ZnT3ZlcmxheSIsIkRpdk92ZXJsYXkiLCJjb250ZW50IiwiX3NvdXJjZSIsIl9jb250ZW50Iiwib3Blbk9uIiwiY2xvc2UiLCJ0b2dnbGUiLCJfcHJlcGFyZU9wZW4iLCJfcmVtb3ZlVGltZW91dCIsImdldENvbnRlbnQiLCJzZXRDb250ZW50IiwidmlzaWJpbGl0eSIsIl91cGRhdGVDb250ZW50IiwiX3VwZGF0ZUxheW91dCIsImlzT3BlbiIsIm5vZGUiLCJfY29udGVudE5vZGUiLCJoYXNDaGlsZE5vZGVzIiwiX2dldEFuY2hvciIsIl9jb250YWluZXJCb3R0b20iLCJfY29udGFpbmVyTGVmdCIsIl9jb250YWluZXJXaWR0aCIsIl9pbml0T3ZlcmxheSIsIk92ZXJsYXlDbGFzcyIsIm9sZCIsIlBvcHVwIiwibWluV2lkdGgiLCJtYXhIZWlnaHQiLCJhdXRvUGFuUGFkZGluZ1RvcExlZnQiLCJhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0Iiwia2VlcEluVmlldyIsImNsb3NlQnV0dG9uIiwiYXV0b0Nsb3NlIiwiY2xvc2VPbkVzY2FwZUtleSIsInBvcHVwIiwiY2xvc2VPbkNsaWNrIiwiY2xvc2VQb3B1cE9uQ2xpY2siLCJwcmVjbGljayIsIm1vdmVlbmQiLCJ3cmFwcGVyIiwiX3dyYXBwZXIiLCJfdGlwQ29udGFpbmVyIiwiX3RpcCIsIl9jbG9zZUJ1dHRvbiIsIndoaXRlU3BhY2UiLCJzY3JvbGxlZENsYXNzIiwiX2F1dG9wYW5uaW5nIiwibWFyZ2luQm90dG9tIiwiY29udGFpbmVySGVpZ2h0IiwiY29udGFpbmVyV2lkdGgiLCJsYXllclBvcyIsImNvbnRhaW5lclBvcyIsIm9wZW5Qb3B1cCIsIl9wb3B1cEhhbmRsZXJzQWRkZWQiLCJfb3BlblBvcHVwIiwia2V5cHJlc3MiLCJfb25LZXlQcmVzcyIsIm1vdmUiLCJfbW92ZVBvcHVwIiwidW5iaW5kUG9wdXAiLCJ0b2dnbGVQb3B1cCIsImlzUG9wdXBPcGVuIiwic2V0UG9wdXBDb250ZW50IiwiZ2V0UG9wdXAiLCJUb29sdGlwIiwiZGlyZWN0aW9uIiwicGVybWFuZW50Iiwic3RpY2t5IiwidG9vbHRpcCIsIl9zZXRQb3NpdGlvbiIsInN1YlgiLCJzdWJZIiwidG9vbHRpcFBvaW50IiwidG9vbHRpcFdpZHRoIiwidG9vbHRpcEhlaWdodCIsIm9wZW5Ub29sdGlwIiwiY2xvc2VUb29sdGlwIiwiYmluZFRvb2x0aXAiLCJfdG9vbHRpcCIsImlzVG9vbHRpcE9wZW4iLCJ1bmJpbmRUb29sdGlwIiwiX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zIiwiX3Rvb2x0aXBIYW5kbGVyc0FkZGVkIiwiX21vdmVUb29sdGlwIiwiX29wZW5Ub29sdGlwIiwiX2FkZEZvY3VzTGlzdGVuZXJzIiwibW91c2Vtb3ZlIiwiX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIiLCJ0b2dnbGVUb29sdGlwIiwic2V0VG9vbHRpcENvbnRlbnQiLCJnZXRUb29sdGlwIiwiX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllciIsIm1vdmluZyIsIl9vcGVuT25jZUZsYWciLCJEaXZJY29uIiwiYmdQb3MiLCJFbGVtZW50IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiZGl2SWNvbiIsIkRlZmF1bHQiLCJHcmlkTGF5ZXIiLCJ0aWxlU2l6ZSIsInVwZGF0ZVdoZW5ab29taW5nIiwidXBkYXRlSW50ZXJ2YWwiLCJtYXhOYXRpdmVab29tIiwibWluTmF0aXZlWm9vbSIsIm5vV3JhcCIsImtlZXBCdWZmZXIiLCJfbGV2ZWxzIiwiX3RpbGVzIiwiX3JlbW92ZUFsbFRpbGVzIiwiX3RpbGVab29tIiwiX3NldEF1dG9aSW5kZXgiLCJpc0xvYWRpbmciLCJfbG9hZGluZyIsInRpbGVab29tIiwiX2NsYW1wWm9vbSIsIl91cGRhdGVMZXZlbHMiLCJ2aWV3cHJlcmVzZXQiLCJfaW52YWxpZGF0ZUFsbCIsImNyZWF0ZVRpbGUiLCJnZXRUaWxlU2l6ZSIsImNvbXBhcmUiLCJjaGlsZHJlbiIsImVkZ2VaSW5kZXgiLCJpc0Zpbml0ZSIsIm5leHRGcmFtZSIsIndpbGxQcnVuZSIsInRpbGUiLCJjdXJyZW50IiwibG9hZGVkIiwiZmFkZSIsImFjdGl2ZSIsIl9vbk9wYXF1ZVRpbGUiLCJfbm9QcnVuZSIsIl9wcnVuZVRpbGVzIiwiX2ZhZGVGcmFtZSIsIk51bWJlciIsIl9vblVwZGF0ZUxldmVsIiwiX3JlbW92ZVRpbGVzQXRab29tIiwiX29uUmVtb3ZlTGV2ZWwiLCJsZXZlbCIsIl9zZXRab29tVHJhbnNmb3JtIiwiX29uQ3JlYXRlTGV2ZWwiLCJfbGV2ZWwiLCJyZXRhaW4iLCJfcmV0YWluUGFyZW50IiwiX3JldGFpbkNoaWxkcmVuIiwiX3JlbW92ZVRpbGUiLCJ4MiIsInkyIiwiejIiLCJjb29yZHMyIiwiX3RpbGVDb29yZHNUb0tleSIsImFuaW1hdGluZyIsIl9zZXRWaWV3Iiwibm9QcnVuZSIsInRpbGVab29tQ2hhbmdlZCIsIl9hYm9ydExvYWRpbmciLCJfcmVzZXRHcmlkIiwiX3NldFpvb21UcmFuc2Zvcm1zIiwidHJhbnNsYXRlIiwiX3RpbGVTaXplIiwiX2dsb2JhbFRpbGVSYW5nZSIsIl9weEJvdW5kc1RvVGlsZVJhbmdlIiwiX3dyYXBYIiwiX3dyYXBZIiwiX2dldFRpbGVkUGl4ZWxCb3VuZHMiLCJtYXBab29tIiwiaGFsZlNpemUiLCJ0aWxlUmFuZ2UiLCJ0aWxlQ2VudGVyIiwicXVldWUiLCJub1BydW5lUmFuZ2UiLCJfaXNWYWxpZFRpbGUiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJfYWRkVGlsZSIsInRpbGVCb3VuZHMiLCJfdGlsZUNvb3Jkc1RvQm91bmRzIiwiX2tleVRvQm91bmRzIiwiX2tleVRvVGlsZUNvb3JkcyIsIl90aWxlQ29vcmRzVG9Od1NlIiwibndQb2ludCIsInNlUG9pbnQiLCJicCIsIl9pbml0VGlsZSIsInRpbGVQb3MiLCJfZ2V0VGlsZVBvcyIsIl93cmFwQ29vcmRzIiwiX3RpbGVSZWFkeSIsIl9ub1RpbGVzVG9Mb2FkIiwibmV3Q29vcmRzIiwiZ3JpZExheWVyIiwiVGlsZUxheWVyIiwic3ViZG9tYWlucyIsImVycm9yVGlsZVVybCIsInpvb21PZmZzZXQiLCJ0bXMiLCJ6b29tUmV2ZXJzZSIsImRldGVjdFJldGluYSIsInJlZmVycmVyUG9saWN5IiwiX29uVGlsZVJlbW92ZSIsIm5vUmVkcmF3IiwiZG9uZSIsIl90aWxlT25Mb2FkIiwiX3RpbGVPbkVycm9yIiwiZ2V0VGlsZVVybCIsIl9nZXRTdWJkb21haW4iLCJfZ2V0Wm9vbUZvclVybCIsImludmVydGVkWSIsImdldEF0dHJpYnV0ZSIsInRpbGVQb2ludCIsImNvbXBsZXRlIiwidGlsZUxheWVyIiwiVGlsZUxheWVyV01TIiwiZGVmYXVsdFdtc1BhcmFtcyIsInNlcnZpY2UiLCJyZXF1ZXN0Iiwic3R5bGVzIiwiZm9ybWF0IiwidHJhbnNwYXJlbnQiLCJ2ZXJzaW9uIiwid21zUGFyYW1zIiwicmVhbFJldGluYSIsIl9jcnMiLCJfd21zVmVyc2lvbiIsInBhcnNlRmxvYXQiLCJwcm9qZWN0aW9uS2V5IiwiYmJveCIsInNldFBhcmFtcyIsInRpbGVMYXllcldNUyIsIldNUyIsIndtcyIsIlJlbmRlcmVyIiwiX3VwZGF0ZVBhdGhzIiwiX2Rlc3Ryb3lDb250YWluZXIiLCJfb25ab29tIiwiem9vbWVuZCIsIl9vblpvb21FbmQiLCJfb25BbmltWm9vbSIsIl91cGRhdGVUcmFuc2Zvcm0iLCJjdXJyZW50Q2VudGVyUG9pbnQiLCJfY2VudGVyIiwidG9wTGVmdE9mZnNldCIsIkNhbnZhcyIsIl9vblZpZXdQcmVSZXNldCIsIl9wb3N0cG9uZVVwZGF0ZVBhdGhzIiwiX2RyYXciLCJfb25Nb3VzZU1vdmUiLCJfb25DbGljayIsIl9oYW5kbGVNb3VzZU91dCIsIl9jdHgiLCJfcmVkcmF3UmVxdWVzdCIsIl9yZWRyYXdCb3VuZHMiLCJfcmVkcmF3IiwibSIsIl91cGRhdGVEYXNoQXJyYXkiLCJvcmRlciIsIl9vcmRlciIsIl9kcmF3TGFzdCIsIm5leHQiLCJfZHJhd0ZpcnN0IiwiX3JlcXVlc3RSZWRyYXciLCJfZXh0ZW5kUmVkcmF3Qm91bmRzIiwiZGFzaFZhbHVlIiwiX2Rhc2hBcnJheSIsIl9jbGVhciIsImNsZWFyUmVjdCIsInNhdmUiLCJyZXN0b3JlIiwiYmVnaW5QYXRoIiwiY2xpcCIsIl9kcmF3aW5nIiwiY2xvc2VQYXRoIiwiX2ZpbGxTdHJva2UiLCJhcmMiLCJnbG9iYWxBbHBoYSIsImZpbGxTdHlsZSIsInNldExpbmVEYXNoIiwibGluZVdpZHRoIiwic3Ryb2tlU3R5bGUiLCJjbGlja2VkTGF5ZXIiLCJfZmlyZUV2ZW50IiwiX2hhbmRsZU1vdXNlSG92ZXIiLCJfaG92ZXJlZExheWVyIiwiX21vdXNlSG92ZXJUaHJvdHRsZWQiLCJjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIiLCJ2bWxDcmVhdGUiLCJuYW1lc3BhY2VzIiwidm1sTWl4aW4iLCJjb29yZHNpemUiLCJfc3Ryb2tlIiwiX2ZpbGwiLCJzdHJva2VkIiwiZmlsbGVkIiwiZGFzaFN0eWxlIiwiZW5kY2FwIiwiam9pbnN0eWxlIiwiX3NldFBhdGgiLCJTVkciLCJfcm9vdEdyb3VwIiwiX3N2Z1NpemUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJfZ2V0UGFuZVJlbmRlcmVyIiwiX2NyZWF0ZVJlbmRlcmVyIiwicHJlZmVyQ2FudmFzIiwiUmVjdGFuZ2xlIiwiX2JvdW5kc1RvTGF0TG5ncyIsInJlY3RhbmdsZSIsIkJveFpvb20iLCJfcGFuZSIsIm92ZXJsYXlQYW5lIiwiX3Jlc2V0U3RhdGVUaW1lb3V0IiwiX2Rlc3Ryb3kiLCJfb25Nb3VzZURvd24iLCJfcmVzZXRTdGF0ZSIsIl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSIsImNvbnRleHRtZW51IiwibW91c2V1cCIsIl9vbk1vdXNlVXAiLCJfb25LZXlEb3duIiwiX2JveCIsIl9maW5pc2giLCJib3hab29tQm91bmRzIiwiZG91YmxlQ2xpY2tab29tIiwiRG91YmxlQ2xpY2tab29tIiwiX29uRG91YmxlQ2xpY2siLCJpbmVydGlhIiwiaW5lcnRpYURlY2VsZXJhdGlvbiIsImluZXJ0aWFNYXhTcGVlZCIsIndvcmxkQ29weUp1bXAiLCJtYXhCb3VuZHNWaXNjb3NpdHkiLCJEcmFnIiwiX29uUHJlRHJhZ0xpbWl0IiwiX29uUHJlRHJhZ1dyYXAiLCJfcG9zaXRpb25zIiwiX3RpbWVzIiwiX29mZnNldExpbWl0IiwiX3Zpc2Nvc2l0eSIsIl9sYXN0VGltZSIsIl9sYXN0UG9zIiwiX2Fic1BvcyIsIl9wcnVuZVBvc2l0aW9ucyIsInNoaWZ0IiwicHhDZW50ZXIiLCJweFdvcmxkQ2VudGVyIiwiX2luaXRpYWxXb3JsZE9mZnNldCIsIl93b3JsZFdpZHRoIiwiX3Zpc2NvdXNMaW1pdCIsInRocmVzaG9sZCIsImxpbWl0Iiwid29ybGRXaWR0aCIsImhhbGZXaWR0aCIsIm5ld1gxIiwibmV3WDIiLCJuZXdYIiwiZWFzZSIsInNwZWVkVmVjdG9yIiwibGltaXRlZFNwZWVkIiwibGltaXRlZFNwZWVkVmVjdG9yIiwiZGVjZWxlcmF0aW9uRHVyYXRpb24iLCJrZXlib2FyZFBhbkRlbHRhIiwiS2V5Ym9hcmQiLCJrZXlDb2RlcyIsImRvd24iLCJ1cCIsIl9zZXRQYW5EZWx0YSIsIl9zZXRab29tRGVsdGEiLCJfb25Gb2N1cyIsImJsdXIiLCJfb25CbHVyIiwibW91c2Vkb3duIiwiX2FkZEhvb2tzIiwiX3JlbW92ZUhvb2tzIiwiX2ZvY3VzZWQiLCJkb2NFbCIsInNjcm9sbFRvIiwicGFuRGVsdGEiLCJrZXlzIiwiX3BhbktleXMiLCJjb2RlcyIsIl96b29tS2V5cyIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwibmV3TGF0TG5nIiwic2Nyb2xsV2hlZWxab29tIiwid2hlZWxEZWJvdW5jZVRpbWUiLCJ3aGVlbFB4UGVyWm9vbUxldmVsIiwiU2Nyb2xsV2hlZWxab29tIiwiX29uV2hlZWxTY3JvbGwiLCJfZGVsdGEiLCJkZWJvdW5jZSIsIl9sYXN0TW91c2VQb3MiLCJfdGltZXIiLCJfcGVyZm9ybVpvb20iLCJkMiIsImQzIiwiZDQiLCJ0YXBIb2xkRGVsYXkiLCJ0YXBIb2xkIiwidGFwVG9sZXJhbmNlIiwiVGFwSG9sZCIsIl9ob2xkVGltZW91dCIsIl9jYW5jZWwiLCJfaXNUYXBWYWxpZCIsIl9jYW5jZWxDbGlja1ByZXZlbnQiLCJfc2ltdWxhdGVFdmVudCIsImNhbmNlbENsaWNrUHJldmVudCIsInNpbXVsYXRlZEV2ZW50IiwiTW91c2VFdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidmlldyIsImRpc3BhdGNoRXZlbnQiLCJ0b3VjaFpvb20iLCJib3VuY2VBdFpvb21MaW1pdHMiLCJUb3VjaFpvb20iLCJfb25Ub3VjaFN0YXJ0IiwiX3pvb21pbmciLCJfY2VudGVyUG9pbnQiLCJfc3RhcnRMYXRMbmciLCJfcGluY2hTdGFydExhdExuZyIsIl9zdGFydERpc3QiLCJfc3RhcnRab29tIiwiX29uVG91Y2hNb3ZlIiwiX29uVG91Y2hFbmQiLCJfYW5pbVJlcXVlc3QiLCJtb3ZlRm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3840\n")},3450:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Jx: function() { return /* binding */ cubicOut; },\n/* harmony export */   sn: function() { return /* reexport safe */ _internal_index_js__WEBPACK_IMPORTED_MODULE_0__.D_O; }\n/* harmony export */ });\n/* unused harmony exports backInOut, backIn, backOut, bounceOut, bounceInOut, bounceIn, circInOut, circIn, circOut, cubicInOut, cubicIn, elasticInOut, elasticIn, elasticOut, expoInOut, expoIn, expoOut, quadInOut, quadIn, quadOut, quartInOut, quartIn, quartOut, quintInOut, quintIn, quintOut, sineInOut, sineIn, sineOut */\n/* harmony import */ var _internal_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3267);\n/*\nAdapted from https://github.com/mattdesl\nDistributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md\n*/\n\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction backInOut(t) {\n  const s = 1.70158 * 1.525;\n  if ((t *= 2) < 1) return 0.5 * (t * t * ((s + 1) * t - s));\n  return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction backIn(t) {\n  const s = 1.70158;\n  return t * t * ((s + 1) * t - s);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction backOut(t) {\n  const s = 1.70158;\n  return --t * t * ((s + 1) * t + s) + 1;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction bounceOut(t) {\n  const a = 4.0 / 11.0;\n  const b = 8.0 / 11.0;\n  const c = 9.0 / 10.0;\n  const ca = 4356.0 / 361.0;\n  const cb = 35442.0 / 1805.0;\n  const cc = 16061.0 / 1805.0;\n  const t2 = t * t;\n  return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction bounceInOut(t) {\n  return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction bounceIn(t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction circInOut(t) {\n  if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1);\n  return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction circIn(t) {\n  return 1.0 - Math.sqrt(1.0 - t * t);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction circOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction cubicInOut(t) {\n  return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction cubicIn(t) {\n  return t * t * t;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction cubicOut(t) {\n  const f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction elasticInOut(t) {\n  return t < 0.5 ? 0.5 * Math.sin(+13.0 * Math.PI / 2 * 2.0 * t) * Math.pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * Math.sin(-13.0 * Math.PI / 2 * (2.0 * t - 1.0 + 1.0)) * Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction elasticIn(t) {\n  return Math.sin(13.0 * t * Math.PI / 2) * Math.pow(2.0, 10.0 * (t - 1.0));\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction elasticOut(t) {\n  return Math.sin(-13.0 * (t + 1.0) * Math.PI / 2) * Math.pow(2.0, -10.0 * t) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction expoInOut(t) {\n  return t === 0.0 || t === 1.0 ? t : t < 0.5 ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0) : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction expoIn(t) {\n  return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction expoOut(t) {\n  return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quadInOut(t) {\n  t /= 0.5;\n  if (t < 1) return 0.5 * t * t;\n  t--;\n  return -0.5 * (t * (t - 2) - 1);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quadIn(t) {\n  return t * t;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quadOut(t) {\n  return -t * (t - 2.0);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quartInOut(t) {\n  return t < 0.5 ? +8.0 * Math.pow(t, 4.0) : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quartIn(t) {\n  return Math.pow(t, 4.0);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quartOut(t) {\n  return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quintInOut(t) {\n  if ((t *= 2) < 1) return 0.5 * t * t * t * t * t;\n  return 0.5 * ((t -= 2) * t * t * t * t + 2);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quintIn(t) {\n  return t * t * t * t * t;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quintOut(t) {\n  return --t * t * t * t * t + 1;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction sineInOut(t) {\n  return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction sineIn(t) {\n  const v = Math.cos(t * Math.PI * 0.5);\n  if (Math.abs(v) < 1e-14) return 1;else return 1 - v;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction sineOut(t) {\n  return Math.sin(t * Math.PI / 2);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEdBQUdlLElBQUksQ0FBQ1csRUFBRSxHQUFHLEdBQUcsQ0FBQztFQUNyQyxJQUFJWCxJQUFJLENBQUM4QixHQUFHLENBQUNELENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxLQUM3QixPQUFPLENBQUMsR0FBR0EsQ0FBQztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0UsT0FBT0EsQ0FBQzlDLENBQUMsRUFBRTtFQUMxQixPQUFPZSxJQUFJLENBQUNVLEdBQUcsQ0FBRXpCLENBQUMsR0FBR2UsSUFBSSxDQUFDVyxFQUFFLEdBQUksQ0FBQyxDQUFDO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9lYXNpbmcvaW5kZXguanM/M2MwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbFxuRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2Vhc2VzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiovXG5leHBvcnQgeyBpZGVudGl0eSBhcyBsaW5lYXIgfSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5qcyc7XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrSW5PdXQodCkge1xuXHRjb25zdCBzID0gMS43MDE1OCAqIDEuNTI1O1xuXHRpZiAoKHQgKj0gMikgPCAxKSByZXR1cm4gMC41ICogKHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykpO1xuXHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgocyArIDEpICogdCArIHMpICsgMik7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrSW4odCkge1xuXHRjb25zdCBzID0gMS43MDE1ODtcblx0cmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrT3V0KHQpIHtcblx0Y29uc3QgcyA9IDEuNzAxNTg7XG5cdHJldHVybiAtLXQgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcblx0Y29uc3QgYSA9IDQuMCAvIDExLjA7XG5cdGNvbnN0IGIgPSA4LjAgLyAxMS4wO1xuXHRjb25zdCBjID0gOS4wIC8gMTAuMDtcblx0Y29uc3QgY2EgPSA0MzU2LjAgLyAzNjEuMDtcblx0Y29uc3QgY2IgPSAzNTQ0Mi4wIC8gMTgwNS4wO1xuXHRjb25zdCBjYyA9IDE2MDYxLjAgLyAxODA1LjA7XG5cdGNvbnN0IHQyID0gdCAqIHQ7XG5cdHJldHVybiB0IDwgYVxuXHRcdD8gNy41NjI1ICogdDJcblx0XHQ6IHQgPCBiXG5cdFx0PyA5LjA3NSAqIHQyIC0gOS45ICogdCArIDMuNFxuXHRcdDogdCA8IGNcblx0XHQ/IGNhICogdDIgLSBjYiAqIHQgKyBjY1xuXHRcdDogMTAuOCAqIHQgKiB0IC0gMjAuNTIgKiB0ICsgMTAuNzI7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG5cdHJldHVybiB0IDwgMC41ID8gMC41ICogKDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0ICogMi4wKSkgOiAwLjUgKiBib3VuY2VPdXQodCAqIDIuMCAtIDEuMCkgKyAwLjU7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbih0KSB7XG5cdHJldHVybiAxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjSW5PdXQodCkge1xuXHRpZiAoKHQgKj0gMikgPCAxKSByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2lyY0luKHQpIHtcblx0cmV0dXJuIDEuMCAtIE1hdGguc3FydCgxLjAgLSB0ICogdCk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjT3V0KHQpIHtcblx0cmV0dXJuIE1hdGguc3FydCgxIC0gLS10ICogdCk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyA0LjAgKiB0ICogdCAqIHQgOiAwLjUgKiBNYXRoLnBvdygyLjAgKiB0IC0gMi4wLCAzLjApICsgMS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNJbih0KSB7XG5cdHJldHVybiB0ICogdCAqIHQ7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY091dCh0KSB7XG5cdGNvbnN0IGYgPSB0IC0gMS4wO1xuXHRyZXR1cm4gZiAqIGYgKiBmICsgMS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjVcblx0XHQ/IDAuNSAqIE1hdGguc2luKCgoKzEzLjAgKiBNYXRoLlBJKSAvIDIpICogMi4wICogdCkgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAoMi4wICogdCAtIDEuMCkpXG5cdFx0OiAwLjUgKlxuXHRcdFx0XHRNYXRoLnNpbigoKC0xMy4wICogTWF0aC5QSSkgLyAyKSAqICgyLjAgKiB0IC0gMS4wICsgMS4wKSkgKlxuXHRcdFx0XHRNYXRoLnBvdygyLjAsIC0xMC4wICogKDIuMCAqIHQgLSAxLjApKSArXG5cdFx0XHRcdDEuMDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XG5cdHJldHVybiBNYXRoLnNpbigoMTMuMCAqIHQgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5zaW4oKC0xMy4wICogKHQgKyAxLjApICogTWF0aC5QSSkgLyAyKSAqIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KSArIDEuMDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cG9Jbk91dCh0KSB7XG5cdHJldHVybiB0ID09PSAwLjAgfHwgdCA9PT0gMS4wXG5cdFx0PyB0XG5cdFx0OiB0IDwgMC41XG5cdFx0PyArMC41ICogTWF0aC5wb3coMi4wLCAyMC4wICogdCAtIDEwLjApXG5cdFx0OiAtMC41ICogTWF0aC5wb3coMi4wLCAxMC4wIC0gdCAqIDIwLjApICsgMS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luKHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCA/IHQgOiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb091dCh0KSB7XG5cdHJldHVybiB0ID09PSAxLjAgPyB0IDogMS4wIC0gTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcblx0dCAvPSAwLjU7XG5cdGlmICh0IDwgMSkgcmV0dXJuIDAuNSAqIHQgKiB0O1xuXHR0LS07XG5cdHJldHVybiAtMC41ICogKHQgKiAodCAtIDIpIC0gMSk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW4odCkge1xuXHRyZXR1cm4gdCAqIHQ7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkT3V0KHQpIHtcblx0cmV0dXJuIC10ICogKHQgLSAyLjApO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhcnRJbk91dCh0KSB7XG5cdHJldHVybiB0IDwgMC41ID8gKzguMCAqIE1hdGgucG93KHQsIDQuMCkgOiAtOC4wICogTWF0aC5wb3codCAtIDEuMCwgNC4wKSArIDEuMDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0SW4odCkge1xuXHRyZXR1cm4gTWF0aC5wb3codCwgNC4wKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0T3V0KHQpIHtcblx0cmV0dXJuIE1hdGgucG93KHQgLSAxLjAsIDMuMCkgKiAoMS4wIC0gdCkgKyAxLjA7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWludEluT3V0KHQpIHtcblx0aWYgKCh0ICo9IDIpIDwgMSkgcmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpbnRJbih0KSB7XG5cdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1aW50T3V0KHQpIHtcblx0cmV0dXJuIC0tdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZUluT3V0KHQpIHtcblx0cmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5lSW4odCkge1xuXHRjb25zdCB2ID0gTWF0aC5jb3ModCAqIE1hdGguUEkgKiAwLjUpO1xuXHRpZiAoTWF0aC5hYnModikgPCAxZS0xNCkgcmV0dXJuIDE7XG5cdGVsc2UgcmV0dXJuIDEgLSB2O1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZU91dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG59XG4iXSwibmFtZXMiOlsiaWRlbnRpdHkiLCJsaW5lYXIiLCJiYWNrSW5PdXQiLCJ0IiwicyIsImJhY2tJbiIsImJhY2tPdXQiLCJib3VuY2VPdXQiLCJhIiwiYiIsImMiLCJjYSIsImNiIiwiY2MiLCJ0MiIsImJvdW5jZUluT3V0IiwiYm91bmNlSW4iLCJjaXJjSW5PdXQiLCJNYXRoIiwic3FydCIsImNpcmNJbiIsImNpcmNPdXQiLCJjdWJpY0luT3V0IiwicG93IiwiY3ViaWNJbiIsImN1YmljT3V0IiwiZiIsImVsYXN0aWNJbk91dCIsInNpbiIsIlBJIiwiZWxhc3RpY0luIiwiZWxhc3RpY091dCIsImV4cG9Jbk91dCIsImV4cG9JbiIsImV4cG9PdXQiLCJxdWFkSW5PdXQiLCJxdWFkSW4iLCJxdWFkT3V0IiwicXVhcnRJbk91dCIsInF1YXJ0SW4iLCJxdWFydE91dCIsInF1aW50SW5PdXQiLCJxdWludEluIiwicXVpbnRPdXQiLCJzaW5lSW5PdXQiLCJjb3MiLCJzaW5lSW4iLCJ2IiwiYWJzIiwic2luZU91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3450\n")},419:function(){"use strict";eval("\n;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/version.js\n// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nconst VERSION = '4.2.18';\nconst PUBLIC_VERSION = '4';\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/disclose-version/index.js\n\nif (typeof window !== 'undefined')\n  // @ts-ignore\n  (window.__svelte || (window.__svelte = {\n    v: new Set()\n  })).v.add(PUBLIC_VERSION);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUEsT0FBTyxHQUFHLFFBQVE7QUFDeEIsTUFBTUMsY0FBYyxHQUFHLEdBQUcsQzs7QUNUMkI7QUFFNUQsSUFBSSxPQUFPQyxNQUFNLEtBQUssV0FBVztFQUNoQztFQUNBLENBQUNBLE1BQU0sQ0FBQ0MsUUFBUSxLQUFLRCxNQUFNLENBQUNDLFFBQVEsR0FBRztJQUFFQyxDQUFDLEVBQUUsSUFBSUMsR0FBRyxDQUFDO0VBQUUsQ0FBQyxDQUFDLEVBQUVELENBQUMsQ0FBQ0UsR0FBRyxDQUFDTCxjQUFjLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zaGFyZWQvdmVyc2lvbi5qcz9mN2JlIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZGlzY2xvc2UtdmVyc2lvbi9pbmRleC5qcz8xZWMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWNvbXBpbGVyI3N2ZWx0ZS12ZXJzaW9uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc0LjIuMTgnO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzQnO1xuIiwiaW1wb3J0IHsgUFVCTElDX1ZFUlNJT04gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdmVyc2lvbi5qcyc7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcblx0Ly8gQHRzLWlnbm9yZVxuXHQod2luZG93Ll9fc3ZlbHRlIHx8ICh3aW5kb3cuX19zdmVsdGUgPSB7IHY6IG5ldyBTZXQoKSB9KSkudi5hZGQoUFVCTElDX1ZFUlNJT04pO1xuIl0sIm5hbWVzIjpbIlZFUlNJT04iLCJQVUJMSUNfVkVSU0lPTiIsIndpbmRvdyIsIl9fc3ZlbHRlIiwidiIsIlNldCIsImFkZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///419\n")},3267:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  r7T: function() { return /* reexport */ SvelteComponent; },\n  Jk$: function() { return /* reexport */ add_flush_callback; },\n  Dti: function() { return /* reexport */ scheduler_add_render_callback; },\n  BCw: function() { return /* reexport */ dom_append; },\n  kZQ: function() { return /* reexport */ append_styles; },\n  kpz: function() { return /* reexport */ utils_assign; },\n  CFu: function() { return /* reexport */ dom_attr; },\n  oIE: function() { return /* reexport */ bind; },\n  Dnk: function() { return /* reexport */ binding_callbacks; },\n  GYV: function() { return /* reexport */ transitions_check_outros; },\n  j0C: function() { return /* reexport */ component_subscribe; },\n  N0i: function() { return /* reexport */ create_component; },\n  b7f: function() { return /* reexport */ create_in_transition; },\n  CUz: function() { return /* reexport */ create_out_transition; },\n  Of3: function() { return /* reexport */ create_slot; },\n  n_k: function() { return /* reexport */ destroy_block; },\n  Hbl: function() { return /* reexport */ destroy_component; },\n  ppq: function() { return /* reexport */ destroy_each; },\n  YoD: function() { return /* reexport */ dom_detach; },\n  ND4: function() { return /* reexport */ dom_element; },\n  Iex: function() { return /* reexport */ empty; },\n  rv_: function() { return /* reexport */ each_ensure_array_like; },\n  i32: function() { return /* reexport */ get_all_dirty_from_scope; },\n  sWk: function() { return /* reexport */ get_slot_changes; },\n  HN9: function() { return /* reexport */ get_spread_update; },\n  V44: function() { return /* reexport */ transitions_group_outros; },\n  D_O: function() { return /* reexport */ identity; },\n  TsN: function() { return /* reexport */ init; },\n  Yry: function() { return /* reexport */ dom_insert; },\n  Qk1: function() { return /* reexport */ utils_is_function; },\n  KTR: function() { return /* reexport */ dom_listen; },\n  HWo: function() { return /* reexport */ loop_loop; },\n  wSR: function() { return /* reexport */ mount_component; },\n  lQ1: function() { return /* reexport */ utils_noop; },\n  tB5: function() { return /* reexport */ environment_now; },\n  oEI: function() { return /* reexport */ null_to_empty; },\n  XP4: function() { return /* reexport */ outro_and_destroy_block; },\n  oOW: function() { return /* reexport */ utils_run_all; },\n  jXN: function() { return /* reexport */ safe_not_equal; },\n  iQh: function() { return /* reexport */ set_data; },\n  hgi: function() { return /* reexport */ set_style; },\n  MyT: function() { return /* reexport */ set_svg_attributes; },\n  xem: function() { return /* reexport */ space; },\n  AE: function() { return /* reexport */ split_css_unit; },\n  mq_: function() { return /* reexport */ src_url_equal; },\n  QQy: function() { return /* reexport */ svg_element; },\n  Qq7: function() { return /* reexport */ dom_text; },\n  c7F: function() { return /* reexport */ transitions_transition_in; },\n  Tn8: function() { return /* reexport */ transitions_transition_out; },\n  l7s: function() { return /* reexport */ update_keyed_each; },\n  nkG: function() { return /* reexport */ update_slot_base; }\n});\n\n// UNUSED EXPORTS: HtmlTag, HtmlTagHydration, ResizeObserverSingleton, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_iframe_resize_listener, add_location, add_styles, add_transform, afterUpdate, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, attr_dev, attribute_to_object, beforeUpdate, blank_object, bubble, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_custom_element, create_ssr_component, current_component, custom_event, dataset_dev, debug, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element_is, end_hydrating, ensure_array_like_dev, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_spread_object, get_store_value, get_svelte_dataset, globals, handle_promise, hasContext, has_prop, head_selector, init_binding_group, init_binding_group_dynamic, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_promise, is_void, listen_dev, loop_guard, merge_ssr_styles, missing_component, not_equal, object_without_properties, onDestroy, onMount, once, prevent_default, prop_dev, query_selector_all, raf, resize_observer_border_box, resize_observer_content_box, resize_observer_device_pixel_content_box, run, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, spread, srcset_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, stringify_spread, subscribe, tick, time_ranges_to_array, to_number, toggle_class, trusted, update_await_block_branch, update_slot, validate_component, validate_dynamic_element, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr\n\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/utils.js\n/** @returns {void} */\nfunction utils_noop() {}\nconst identity = x => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nfunction utils_assign(tar, src) {\n  // @ts-ignore\n  for (const k in src) tar[k] = src[k];\n  return /** @type {T & S} */tar;\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nfunction utils_is_promise(value) {\n  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof ( /** @type {any} */value.then) === 'function';\n}\n\n/** @returns {void} */\nfunction add_location(element, file, line, column, char) {\n  element.__svelte_meta = {\n    loc: {\n      file,\n      line,\n      column,\n      char\n    }\n  };\n}\nfunction run(fn) {\n  return fn();\n}\nfunction utils_blank_object() {\n  return Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nfunction utils_run_all(fns) {\n  fns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nfunction utils_is_function(thing) {\n  return typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';\n}\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n  if (element_src === url) return true;\n  if (!src_url_equal_anchor) {\n    src_url_equal_anchor = document.createElement('a');\n  }\n  // This is actually faster than doing URL(..).href\n  src_url_equal_anchor.href = url;\n  return element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n  return srcset.split(',').map(src => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element_srcset, srcset) {\n  const element_urls = split_srcset(element_srcset.srcset);\n  const urls = split_srcset(srcset || '');\n  return urls.length === element_urls.length && urls.every(([url, width], i) => width === element_urls[i][1] && (\n  // We need to test both ways because Vite will create an a full URL with\n  // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n  // relative URLs inside srcset are not automatically resolved to absolute URLs by\n  // browsers (in contrast to img.src). This means both SSR and DOM code could\n  // contain relative or absolute URLs.\n  src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0])));\n}\n\n/** @returns {boolean} */\nfunction not_equal(a, b) {\n  return a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nfunction validate_store(store, name) {\n  if (store != null && typeof store.subscribe !== 'function') {\n    throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n  }\n}\nfunction subscribe(store, ...callbacks) {\n  if (store == null) {\n    for (const callback of callbacks) {\n      callback(undefined);\n    }\n    return utils_noop;\n  }\n  const unsub = store.subscribe(...callbacks);\n  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nfunction get_store_value(store) {\n  let value;\n  subscribe(store, _ => value = _)();\n  return value;\n}\n\n/** @returns {void} */\nfunction component_subscribe(component, store, callback) {\n  component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? utils_assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === undefined) {\n      return lets;\n    }\n    if (typeof lets === 'object') {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\n\n/** @returns {void} */\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\n\n/** @returns {void} */\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n  const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n  update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\n\n/** @returns {{}} */\nfunction exclude_internal_props(props) {\n  const result = {};\n  for (const k in props) if (k[0] !== '$') result[k] = props[k];\n  return result;\n}\n\n/** @returns {{}} */\nfunction compute_rest_props(props, keys) {\n  const rest = {};\n  keys = new Set(keys);\n  for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n  return rest;\n}\n\n/** @returns {{}} */\nfunction compute_slots(slots) {\n  const result = {};\n  for (const key in slots) {\n    result[key] = true;\n  }\n  return result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nfunction once(fn) {\n  let ran = false;\n  return function (...args) {\n    if (ran) return;\n    ran = true;\n    fn.call(this, ...args);\n  };\n}\nfunction null_to_empty(value) {\n  return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n  store.set(value);\n  return ret;\n}\nconst utils_has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n  return action_result && utils_is_function(action_result.destroy) ? action_result.destroy : utils_noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nfunction split_css_unit(value) {\n  const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n  return split ? [parseFloat(split[1]), split[2] || 'px'] : [( /** @type {number} */value), 'px'];\n}\nconst utils_contenteditable_truthy_values = (/* unused pure expression or super */ null && (['', true, 1, 'true', 'contenteditable']));\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/environment.js\n\nconst is_client = typeof window !== 'undefined';\n\n/** @type {() => number} */\nlet environment_now = is_client ? () => window.performance.now() : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : utils_noop;\n\n// used internally for testing\n/** @returns {void} */\nfunction set_now(fn) {\n  environment_now = fn;\n}\n\n/** @returns {void} */\nfunction set_raf(fn) {\n  raf = fn;\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/loop.js\n\nconst tasks = new Set();\n\n/**\n * @param {number} now\n * @returns {void}\n */\nfunction run_tasks(now) {\n  tasks.forEach(task => {\n    if (!task.c(now)) {\n      tasks.delete(task);\n      task.f();\n    }\n  });\n  if (tasks.size !== 0) raf(run_tasks);\n}\n\n/**\n * For testing purposes only!\n * @returns {void}\n */\nfunction clear_loops() {\n  tasks.clear();\n}\n\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n * @param {import('./private.js').TaskCallback} callback\n * @returns {import('./private.js').Task}\n */\nfunction loop_loop(callback) {\n  /** @type {import('./private.js').TaskEntry} */\n  let task;\n  if (tasks.size === 0) raf(run_tasks);\n  return {\n    promise: new Promise(fulfill => {\n      tasks.add(task = {\n        c: callback,\n        f: fulfill\n      });\n    }),\n    abort() {\n      tasks.delete(task);\n    }\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/globals.js\n/** @type {typeof globalThis} */\nconst globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis :\n// @ts-ignore Node typings have this\nglobal;\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js\n\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n  /**\n   * @private\n   * @readonly\n   * @type {WeakMap<Element, import('./private.js').Listener>}\n   */\n  _listeners = \"WeakMap\" in globals ? new WeakMap() : undefined;\n\n  /**\n   * @private\n   * @type {ResizeObserver}\n   */\n  _observer = undefined;\n\n  /** @type {ResizeObserverOptions} */\n  options;\n\n  /** @param {ResizeObserverOptions} options */\n  constructor(options) {\n    this.options = options;\n  }\n\n  /**\n   * @param {Element} element\n   * @param {import('./private.js').Listener} listener\n   * @returns {() => void}\n   */\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element); // this line can probably be removed\n    };\n  }\n\n  /**\n   * @private\n   */\n  _getObserver() {\n    return this._observer ?? (this._observer = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        ResizeObserverSingleton.entries.set(entry.target, entry);\n        this._listeners.get(entry.target)?.(entry);\n      }\n    }));\n  }\n}\n\n// Needs to be written like this to pass the tree-shake-test\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? new WeakMap() : undefined;\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dom.js\n\n\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nfunction start_hydrating() {\n  is_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nfunction end_hydrating() {\n  is_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n  // Return first index of value larger than input value in the range [low, high)\n  while (low < high) {\n    const mid = low + (high - low >> 1);\n    if (key(mid) <= value) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n  if (target.hydrate_init) return;\n  target.hydrate_init = true;\n  // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n  let children = /** @type {ArrayLike<NodeEx2>} */target.childNodes;\n  // If target is <head>, there may be children without claim_order\n  if (target.nodeName === 'HEAD') {\n    const my_children = [];\n    for (let i = 0; i < children.length; i++) {\n      const node = children[i];\n      if (node.claim_order !== undefined) {\n        my_children.push(node);\n      }\n    }\n    children = my_children;\n  }\n  /*\n   * Reorder claimed children optimally.\n   * We can reorder claimed children optimally by finding the longest subsequence of\n   * nodes that are already claimed in order and only moving the rest. The longest\n   * subsequence of nodes that are claimed in order can be found by\n   * computing the longest increasing subsequence of .claim_order values.\n   *\n   * This algorithm is optimal in generating the least amount of reorder operations\n   * possible.\n   *\n   * Proof:\n   * We know that, given a set of reordering operations, the nodes that do not move\n   * always form an increasing subsequence, since they do not move among each other\n   * meaning that they must be already ordered among each other. Thus, the maximal\n   * set of nodes that do not move form a longest increasing subsequence.\n   */\n  // Compute longest increasing subsequence\n  // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n  const m = new Int32Array(children.length + 1);\n  // Predecessor indices + 1\n  const p = new Int32Array(children.length);\n  m[0] = -1;\n  let longest = 0;\n  for (let i = 0; i < children.length; i++) {\n    const current = children[i].claim_order;\n    // Find the largest subsequence length such that it ends in a value less than our current value\n    // upper_bound returns first greater value, so we subtract one\n    // with fast path for when we are on the current longest subsequence\n    const seq_len = (longest > 0 && children[m[longest]].claim_order <= current ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n    p[i] = m[seq_len] + 1;\n    const new_len = seq_len + 1;\n    // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n    m[new_len] = i;\n    longest = Math.max(new_len, longest);\n  }\n  // The longest increasing subsequence of nodes (initially reversed)\n\n  /**\n   * @type {NodeEx2[]}\n   */\n  const lis = [];\n  // The rest of the nodes, nodes that will be moved\n\n  /**\n   * @type {NodeEx2[]}\n   */\n  const to_move = [];\n  let last = children.length - 1;\n  for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n    lis.push(children[cur - 1]);\n    for (; last >= cur; last--) {\n      to_move.push(children[last]);\n    }\n    last--;\n  }\n  for (; last >= 0; last--) {\n    to_move.push(children[last]);\n  }\n  lis.reverse();\n  // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n  to_move.sort((a, b) => a.claim_order - b.claim_order);\n  // Finally, we move the nodes\n  for (let i = 0, j = 0; i < to_move.length; i++) {\n    while (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n      j++;\n    }\n    const anchor = j < lis.length ? lis[j] : null;\n    target.insertBefore(to_move[i], anchor);\n  }\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nfunction dom_append(target, node) {\n  target.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = dom_element('style');\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nfunction get_root_for_style(node) {\n  if (!node) return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && /** @type {ShadowRoot} */root.host) {\n    return /** @type {ShadowRoot} */root;\n  }\n  return node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nfunction append_empty_stylesheet(node) {\n  const style_element = dom_element('style');\n  // For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n  // these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n  // Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n  // So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n  // The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n  style_element.textContent = '/* empty */';\n  append_stylesheet(get_root_for_style(node), style_element);\n  return style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n  dom_append( /** @type {Document} */node.head || node, style);\n  return style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nfunction dom_append_hydration(target, node) {\n  if (is_hydrating) {\n    init_hydrate(target);\n    if (target.actual_end_child === undefined || target.actual_end_child !== null && target.actual_end_child.parentNode !== target) {\n      target.actual_end_child = target.firstChild;\n    }\n    // Skip nodes of undefined ordering\n    while (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n      target.actual_end_child = target.actual_end_child.nextSibling;\n    }\n    if (node !== target.actual_end_child) {\n      // We only insert if the ordering of this node should be modified or the parent node is not target\n      if (node.claim_order !== undefined || node.parentNode !== target) {\n        target.insertBefore(node, target.actual_end_child);\n      }\n    } else {\n      target.actual_end_child = node.nextSibling;\n    }\n  } else if (node.parentNode !== target || node.nextSibling !== null) {\n    target.appendChild(node);\n  }\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nfunction dom_insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nfunction dom_insert_hydration(target, node, anchor) {\n  if (is_hydrating && !anchor) {\n    dom_append_hydration(target, node);\n  } else if (node.parentNode !== target || node.nextSibling != anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nfunction dom_detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * @returns {void} */\nfunction destroy_each(iterations, detaching) {\n  for (let i = 0; i < iterations.length; i += 1) {\n    if (iterations[i]) iterations[i].d(detaching);\n  }\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nfunction dom_element(name) {\n  return document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nfunction element_is(name, is) {\n  return document.createElement(name, {\n    is\n  });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nfunction object_without_properties(obj, exclude) {\n  const target = /** @type {Pick<T, Exclude<keyof T, K>>} */{};\n  for (const k in obj) {\n    if (has_prop(obj, k) &&\n    // @ts-ignore\n    exclude.indexOf(k) === -1) {\n      // @ts-ignore\n      target[k] = obj[k];\n    }\n  }\n  return target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nfunction svg_element(name) {\n  return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nfunction dom_text(data) {\n  return document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nfunction space() {\n  return dom_text(' ');\n}\n\n/**\n * @returns {Text} */\nfunction empty() {\n  return dom_text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nfunction comment(content) {\n  return document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nfunction dom_listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nfunction prevent_default(fn) {\n  return function (event) {\n    event.preventDefault();\n    // @ts-ignore\n    return fn.call(this, event);\n  };\n}\n\n/**\n * @returns {(event: any) => any} */\nfunction stop_propagation(fn) {\n  return function (event) {\n    event.stopPropagation();\n    // @ts-ignore\n    return fn.call(this, event);\n  };\n}\n\n/**\n * @returns {(event: any) => any} */\nfunction stop_immediate_propagation(fn) {\n  return function (event) {\n    event.stopImmediatePropagation();\n    // @ts-ignore\n    return fn.call(this, event);\n  };\n}\n\n/**\n * @returns {(event: any) => void} */\nfunction dom_self(fn) {\n  return function (event) {\n    // @ts-ignore\n    if (event.target === this) fn.call(this, event);\n  };\n}\n\n/**\n * @returns {(event: any) => void} */\nfunction trusted(fn) {\n  return function (event) {\n    // @ts-ignore\n    if (event.isTrusted) fn.call(this, event);\n  };\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nfunction dom_attr(node, attribute, value) {\n  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = (/* unused pure expression or super */ null && (['width', 'height']));\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nfunction set_attributes(node, attributes) {\n  // @ts-ignore\n  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n  for (const key in attributes) {\n    if (attributes[key] == null) {\n      node.removeAttribute(key);\n    } else if (key === 'style') {\n      node.style.cssText = attributes[key];\n    } else if (key === '__value') {\n      /** @type {any} */node.value = node[key] = attributes[key];\n    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n      node[key] = attributes[key];\n    } else {\n      dom_attr(node, key, attributes[key]);\n    }\n  }\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nfunction set_svg_attributes(node, attributes) {\n  for (const key in attributes) {\n    dom_attr(node, key, attributes[key]);\n  }\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nfunction set_custom_element_data_map(node, data_map) {\n  Object.keys(data_map).forEach(key => {\n    set_custom_element_data(node, key, data_map[key]);\n  });\n}\n\n/**\n * @returns {void} */\nfunction set_custom_element_data(node, prop, value) {\n  const lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n  if (lower in node) {\n    node[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n  } else if (prop in node) {\n    node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n  } else {\n    dom_attr(node, prop, value);\n  }\n}\n\n/**\n * @param {string} tag\n */\nfunction set_dynamic_element_data(tag) {\n  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nfunction xlink_attr(node, attribute, value) {\n  node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nfunction get_svelte_dataset(node) {\n  return node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nfunction get_binding_group_value(group, __value, checked) {\n  const value = new Set();\n  for (let i = 0; i < group.length; i += 1) {\n    if (group[i].checked) value.add(group[i].__value);\n  }\n  if (!checked) {\n    value.delete(__value);\n  }\n  return Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nfunction init_binding_group(group) {\n  /**\n   * @type {HTMLInputElement[]} */\n  let _inputs;\n  return {\n    /* push */p(...inputs) {\n      _inputs = inputs;\n      _inputs.forEach(input => group.push(input));\n    },\n    /* remove */r() {\n      _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n    }\n  };\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nfunction init_binding_group_dynamic(group, indexes) {\n  /**\n   * @type {HTMLInputElement[]} */\n  let _group = get_binding_group(group);\n\n  /**\n   * @type {HTMLInputElement[]} */\n  let _inputs;\n  function get_binding_group(group) {\n    for (let i = 0; i < indexes.length; i++) {\n      group = group[indexes[i]] = group[indexes[i]] || [];\n    }\n    return group;\n  }\n\n  /**\n   * @returns {void} */\n  function push() {\n    _inputs.forEach(input => _group.push(input));\n  }\n\n  /**\n   * @returns {void} */\n  function remove() {\n    _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n  }\n  return {\n    /* update */u(new_indexes) {\n      indexes = new_indexes;\n      const new_group = get_binding_group(group);\n      if (new_group !== _group) {\n        remove();\n        _group = new_group;\n        push();\n      }\n    },\n    /* push */p(...inputs) {\n      _inputs = inputs;\n      push();\n    },\n    /* remove */r: remove\n  };\n}\n\n/** @returns {number} */\nfunction to_number(value) {\n  return value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nfunction time_ranges_to_array(ranges) {\n  const array = [];\n  for (let i = 0; i < ranges.length; i += 1) {\n    array.push({\n      start: ranges.start(i),\n      end: ranges.end(i)\n    });\n  }\n  return array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n  if (nodes.claim_info === undefined) {\n    nodes.claim_info = {\n      last_index: 0,\n      total_claimed: 0\n    };\n  }\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n  // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n  init_claim_info(nodes);\n  const result_node = (() => {\n    // We first try to find an element after the previous one\n    for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (predicate(node)) {\n        const replacement = process_node(node);\n        if (replacement === undefined) {\n          nodes.splice(i, 1);\n        } else {\n          nodes[i] = replacement;\n        }\n        if (!dont_update_last_index) {\n          nodes.claim_info.last_index = i;\n        }\n        return node;\n      }\n    }\n    // Otherwise, we try to find one before\n    // We iterate in reverse so that we don't go too far back\n    for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n      const node = nodes[i];\n      if (predicate(node)) {\n        const replacement = process_node(node);\n        if (replacement === undefined) {\n          nodes.splice(i, 1);\n        } else {\n          nodes[i] = replacement;\n        }\n        if (!dont_update_last_index) {\n          nodes.claim_info.last_index = i;\n        } else if (replacement === undefined) {\n          // Since we spliced before the last_index, we decrease it\n          nodes.claim_info.last_index--;\n        }\n        return node;\n      }\n    }\n    // If we can't find any matching node, we create a new one\n    return create_node();\n  })();\n  result_node.claim_order = nodes.claim_info.total_claimed;\n  nodes.claim_info.total_claimed += 1;\n  return result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n  return claim_node(nodes, /** @returns {node is Element | SVGElement} */\n  node => node.nodeName === name, /** @param {Element} node */\n  node => {\n    const remove = [];\n    for (let j = 0; j < node.attributes.length; j++) {\n      const attribute = node.attributes[j];\n      if (!attributes[attribute.name]) {\n        remove.push(attribute.name);\n      }\n    }\n    remove.forEach(v => node.removeAttribute(v));\n    return undefined;\n  }, () => create_element(name));\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nfunction claim_element(nodes, name, attributes) {\n  return claim_element_base(nodes, name, attributes, dom_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nfunction claim_svg_element(nodes, name, attributes) {\n  return claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nfunction claim_text(nodes, data) {\n  return claim_node(nodes, /** @returns {node is Text} */\n  node => node.nodeType === 3, /** @param {Text} node */\n  node => {\n    const data_str = '' + data;\n    if (node.data.startsWith(data_str)) {\n      if (node.data.length !== data_str.length) {\n        return node.splitText(data_str.length);\n      }\n    } else {\n      node.data = data_str;\n    }\n  }, () => dom_text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n  );\n}\n\n/**\n * @returns {Text} */\nfunction claim_space(nodes) {\n  return claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nfunction claim_comment(nodes, data) {\n  return claim_node(nodes, /** @returns {node is Comment} */\n  node => node.nodeType === 8, /** @param {Comment} node */\n  node => {\n    node.data = '' + data;\n    return undefined;\n  }, () => comment(data), true);\n}\nfunction get_comment_idx(nodes, text, start) {\n  for (let i = start; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nfunction claim_html_tag(nodes, is_svg) {\n  // find html opening tag\n  const start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n  const end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n  if (start_index === -1 || end_index === -1) {\n    return new HtmlTagHydration(is_svg);\n  }\n  init_claim_info(nodes);\n  const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n  dom_detach(html_tag_nodes[0]);\n  dom_detach(html_tag_nodes[html_tag_nodes.length - 1]);\n  const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n  if (claimed_nodes.length === 0) {\n    return new HtmlTagHydration(is_svg);\n  }\n  for (const n of claimed_nodes) {\n    n.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n  }\n  return new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data(text, data) {\n  data = '' + data;\n  if (text.data === data) return;\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data_contenteditable(text, data) {\n  data = '' + data;\n  if (text.wholeText === data) return;\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n  if (~contenteditable_truthy_values.indexOf(attr_value)) {\n    set_data_contenteditable(text, data);\n  } else {\n    set_data(text, data);\n  }\n}\n\n/**\n * @returns {void} */\nfunction set_input_value(input, value) {\n  input.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nfunction set_input_type(input, type) {\n  try {\n    input.type = type;\n  } catch (e) {\n    // do nothing\n  }\n}\n\n/**\n * @returns {void} */\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? 'important' : '');\n  }\n}\n\n/**\n * @returns {void} */\nfunction select_option(select, value, mounting) {\n  for (let i = 0; i < select.options.length; i += 1) {\n    const option = select.options[i];\n    if (option.__value === value) {\n      option.selected = true;\n      return;\n    }\n  }\n  if (!mounting || value !== undefined) {\n    select.selectedIndex = -1; // no option should be selected\n  }\n}\n\n/**\n * @returns {void} */\nfunction select_options(select, value) {\n  for (let i = 0; i < select.options.length; i += 1) {\n    const option = select.options[i];\n    option.selected = ~value.indexOf(option.__value);\n  }\n}\nfunction select_value(select) {\n  const selected_option = select.querySelector(':checked');\n  return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n  return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nfunction is_crossorigin() {\n  if (crossorigin === undefined) {\n    crossorigin = false;\n    try {\n      if (typeof window !== 'undefined' && window.parent) {\n        void window.parent.document;\n      }\n    } catch (error) {\n      crossorigin = true;\n    }\n  }\n  return crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nfunction add_iframe_resize_listener(node, fn) {\n  const computed_style = getComputedStyle(node);\n  if (computed_style.position === 'static') {\n    node.style.position = 'relative';\n  }\n  const iframe = dom_element('iframe');\n  iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n  iframe.setAttribute('aria-hidden', 'true');\n  iframe.tabIndex = -1;\n  const crossorigin = is_crossorigin();\n\n  /**\n   * @type {() => void}\n   */\n  let unsubscribe;\n  if (crossorigin) {\n    iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>\";\n    unsubscribe = dom_listen(window, 'message', /** @param {MessageEvent} event */event => {\n      if (event.source === iframe.contentWindow) fn();\n    });\n  } else {\n    iframe.src = 'about:blank';\n    iframe.onload = () => {\n      unsubscribe = dom_listen(iframe.contentWindow, 'resize', fn);\n      // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n      // see https://github.com/sveltejs/svelte/issues/4233\n      fn();\n    };\n  }\n  dom_append(node, iframe);\n  return () => {\n    if (crossorigin) {\n      unsubscribe();\n    } else if (unsubscribe && iframe.contentWindow) {\n      unsubscribe();\n    }\n    dom_detach(iframe);\n  };\n}\nconst resize_observer_content_box = /* @__PURE__ */new ResizeObserverSingleton({\n  box: 'content-box'\n});\nconst resize_observer_border_box = /* @__PURE__ */new ResizeObserverSingleton({\n  box: 'border-box'\n});\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */new ResizeObserverSingleton({\n  box: 'device-pixel-content-box'\n});\n\n\n/**\n * @returns {void} */\nfunction toggle_class(element, name, toggle) {\n  // The `!!` is required because an `undefined` flag means flipping the current state.\n  element.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nfunction dom_custom_event(type, detail, {\n  bubbles = false,\n  cancelable = false\n} = {}) {\n  return new CustomEvent(type, {\n    detail,\n    bubbles,\n    cancelable\n  });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nfunction query_selector_all(selector, parent = document.body) {\n  return Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nfunction head_selector(nodeId, head) {\n  const result = [];\n  let started = 0;\n  for (const node of head.childNodes) {\n    if (node.nodeType === 8 /* comment node */) {\n      const comment = node.textContent.trim();\n      if (comment === `HEAD_${nodeId}_END`) {\n        started -= 1;\n        result.push(node);\n      } else if (comment === `HEAD_${nodeId}_START`) {\n        started += 1;\n        result.push(node);\n      }\n    } else if (started > 0) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/** */\nclass HtmlTag {\n  /**\n   * @private\n   * @default false\n   */\n  is_svg = false;\n  /** parent for creating node */\n  e = undefined;\n  /** html tag nodes */\n  n = undefined;\n  /** target */\n  t = undefined;\n  /** anchor */\n  a = undefined;\n  constructor(is_svg = false) {\n    this.is_svg = is_svg;\n    this.e = this.n = null;\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  c(html) {\n    this.h(html);\n  }\n\n  /**\n   * @param {string} html\n   * @param {HTMLElement | SVGElement} target\n   * @param {HTMLElement | SVGElement} anchor\n   * @returns {void}\n   */\n  m(html, target, anchor = null) {\n    if (!this.e) {\n      if (this.is_svg) this.e = svg_element( /** @type {keyof SVGElementTagNameMap} */target.nodeName);\n      /** #7364  target for <template> may be provided as #document-fragment(11) */else this.e = dom_element( /** @type {keyof HTMLElementTagNameMap} */\n      target.nodeType === 11 ? 'TEMPLATE' : target.nodeName);\n      this.t = target.tagName !== 'TEMPLATE' ? target : /** @type {HTMLTemplateElement} */target.content;\n      this.c(html);\n    }\n    this.i(anchor);\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  h(html) {\n    this.e.innerHTML = html;\n    this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n  }\n\n  /**\n   * @returns {void} */\n  i(anchor) {\n    for (let i = 0; i < this.n.length; i += 1) {\n      dom_insert(this.t, this.n[i], anchor);\n    }\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  p(html) {\n    this.d();\n    this.h(html);\n    this.i(this.a);\n  }\n\n  /**\n   * @returns {void} */\n  d() {\n    this.n.forEach(dom_detach);\n  }\n}\nclass HtmlTagHydration extends HtmlTag {\n  /** @type {Element[]} hydration claimed nodes */\n  l = undefined;\n  constructor(is_svg = false, claimed_nodes) {\n    super(is_svg);\n    this.e = this.n = null;\n    this.l = claimed_nodes;\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  c(html) {\n    if (this.l) {\n      this.n = this.l;\n    } else {\n      super.c(html);\n    }\n  }\n\n  /**\n   * @returns {void} */\n  i(anchor) {\n    for (let i = 0; i < this.n.length; i += 1) {\n      dom_insert_hydration(this.t, this.n[i], anchor);\n    }\n  }\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nfunction attribute_to_object(attributes) {\n  const result = {};\n  for (const attribute of attributes) {\n    result[attribute.name] = attribute.value;\n  }\n  return result;\n}\nconst escaped = {\n  '\"': '&quot;',\n  '&': '&amp;',\n  '<': '&lt;'\n};\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n  return String(attribute).replace(regex_attribute_characters_to_escape, match => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nfunction stringify_spread(attributes) {\n  let str = ' ';\n  for (const key in attributes) {\n    if (attributes[key] != null) {\n      str += `${key}=\"${escape_attribute(attributes[key])}\" `;\n    }\n  }\n  return str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nfunction get_custom_elements_slots(element) {\n  const result = {};\n  element.childNodes.forEach( /** @param {Element} node */node => {\n    result[node.slot || 'default'] = true;\n  });\n  return result;\n}\nfunction construct_svelte_component(component, props) {\n  return new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/style_manager.js\n\n\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\n/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */\nconst managed_styles = new Map();\nlet active = 0;\n\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\n/**\n * @param {string} str\n * @returns {number}\n */\nfunction hash(str) {\n  let hash = 5381;\n  let i = str.length;\n  while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);\n  return hash >>> 0;\n}\n\n/**\n * @param {Document | ShadowRoot} doc\n * @param {Element & ElementCSSInlineStyle} node\n * @returns {{ stylesheet: any; rules: {}; }}\n */\nfunction create_style_information(doc, node) {\n  const info = {\n    stylesheet: append_empty_stylesheet(node),\n    rules: {}\n  };\n  managed_styles.set(doc, info);\n  return info;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {number} a\n * @param {number} b\n * @param {number} duration\n * @param {number} delay\n * @param {(t: number) => number} ease\n * @param {(t: number, u: number) => string} fn\n * @param {number} uid\n * @returns {string}\n */\nfunction style_manager_create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n  const step = 16.666 / duration;\n  let keyframes = '{\\n';\n  for (let p = 0; p <= 1; p += step) {\n    const t = a + (b - a) * ease(p);\n    keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n  }\n  const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n  const name = `__svelte_${hash(rule)}_${uid}`;\n  const doc = get_root_for_style(node);\n  const {\n    stylesheet,\n    rules\n  } = managed_styles.get(doc) || create_style_information(doc, node);\n  if (!rules[name]) {\n    rules[name] = true;\n    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n  }\n  const animation = node.style.animation || '';\n  node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n  active += 1;\n  return name;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {string} [name]\n * @returns {void}\n */\nfunction style_manager_delete_rule(node, name) {\n  const previous = (node.style.animation || '').split(', ');\n  const next = previous.filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation\n  : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n  );\n  const deleted = previous.length - next.length;\n  if (deleted) {\n    node.style.animation = next.join(', ');\n    active -= deleted;\n    if (!active) clear_rules();\n  }\n}\n\n/** @returns {void} */\nfunction clear_rules() {\n  raf(() => {\n    if (active) return;\n    managed_styles.forEach(info => {\n      const {\n        ownerNode\n      } = info.stylesheet;\n      // there is no ownerNode if it runs on jsdom.\n      if (ownerNode) dom_detach(ownerNode);\n    });\n    managed_styles.clear();\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/animations.js\n\n\n\n\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {import('./private.js').PositionRect} from\n * @param {import('./private.js').AnimationFn} fn\n */\nfunction create_animation(node, from, fn, params) {\n  if (!from) return noop;\n  const to = node.getBoundingClientRect();\n  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;\n  const {\n    delay = 0,\n    duration = 300,\n    easing = linear,\n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay,\n    // @ts-ignore todo:\n    end = start_time + duration,\n    tick = noop,\n    css\n  } = fn(node, {\n    from,\n    to\n  }, params);\n  let running = true;\n  let started = false;\n  let name;\n  /** @returns {void} */\n  function start() {\n    if (css) {\n      name = create_rule(node, 0, 1, duration, delay, easing, css);\n    }\n    if (!delay) {\n      started = true;\n    }\n  }\n  /** @returns {void} */\n  function stop() {\n    if (css) delete_rule(node, name);\n    running = false;\n  }\n  loop(now => {\n    if (!started && now >= start_time) {\n      started = true;\n    }\n    if (started && now >= end) {\n      tick(1, 0);\n      stop();\n    }\n    if (!running) {\n      return false;\n    }\n    if (started) {\n      const p = now - start_time;\n      const t = 0 + 1 * easing(p / duration);\n      tick(t, 1 - t);\n    }\n    return true;\n  });\n  start();\n  tick(0, 1);\n  return stop;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @returns {void}\n */\nfunction fix_position(node) {\n  const style = getComputedStyle(node);\n  if (style.position !== 'absolute' && style.position !== 'fixed') {\n    const {\n      width,\n      height\n    } = style;\n    const a = node.getBoundingClientRect();\n    node.style.position = 'absolute';\n    node.style.width = width;\n    node.style.height = height;\n    add_transform(node, a);\n  }\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {import('./private.js').PositionRect} a\n * @returns {void}\n */\nfunction add_transform(node, a) {\n  const b = node.getBoundingClientRect();\n  if (a.left !== b.left || a.top !== b.top) {\n    const style = getComputedStyle(node);\n    const transform = style.transform === 'none' ? '' : style.transform;\n    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/lifecycle.js\n\nlet lifecycle_current_component;\n\n/** @returns {void} */\nfunction lifecycle_set_current_component(component) {\n  lifecycle_current_component = component;\n}\nfunction lifecycle_get_current_component() {\n  if (!lifecycle_current_component) throw new Error('Function called outside component initialization');\n  return lifecycle_current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nfunction beforeUpdate(fn) {\n  lifecycle_get_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nfunction onMount(fn) {\n  lifecycle_get_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nfunction afterUpdate(fn) {\n  lifecycle_get_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nfunction onDestroy(fn) {\n  lifecycle_get_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nfunction createEventDispatcher() {\n  const component = lifecycle_get_current_component();\n  return (type, detail, {\n    cancelable = false\n  } = {}) => {\n    const callbacks = component.$$.callbacks[type];\n    if (callbacks) {\n      // TODO are there situations where events could be dispatched\n      // in a server (non-DOM) environment?\n      const event = custom_event( /** @type {string} */type, detail, {\n        cancelable\n      });\n      callbacks.slice().forEach(fn => {\n        fn.call(component, event);\n      });\n      return !event.defaultPrevented;\n    }\n    return true;\n  };\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nfunction setContext(key, context) {\n  lifecycle_get_current_component().$$.context.set(key, context);\n  return context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nfunction getContext(key) {\n  return lifecycle_get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nfunction getAllContexts() {\n  return lifecycle_get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nfunction hasContext(key) {\n  return lifecycle_get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nfunction bubble(component, event) {\n  const callbacks = component.$$.callbacks[event.type];\n  if (callbacks) {\n    // @ts-ignore\n    callbacks.slice().forEach(fn => fn.call(this, event));\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/scheduler.js\n\n\nconst dirty_components = [];\nconst intros = {\n  enabled: false\n};\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */Promise.resolve();\nlet update_scheduled = false;\n\n/** @returns {void} */\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(scheduler_flush);\n  }\n}\n\n/** @returns {Promise<void>} */\nfunction tick() {\n  schedule_update();\n  return resolved_promise;\n}\n\n/** @returns {void} */\nfunction scheduler_add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\n\n/** @returns {void} */\nfunction add_flush_callback(fn) {\n  flush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nfunction scheduler_flush() {\n  // Do not reenter flush while dirty components are updated, as this can\n  // result in an infinite loop. Instead, let the inner flush handle it.\n  // Reentrancy is ok afterwards for bindings etc.\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = lifecycle_current_component;\n  do {\n    // first, call beforeUpdate functions\n    // and update components\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        lifecycle_set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      // reset dirty state to not end up in a deadlocked state and then rethrow\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    lifecycle_set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length) binding_callbacks.pop()();\n    // then, once components are updated, call\n    // afterUpdate functions. This may cause\n    // subsequent updates...\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        // ...so guard against infinite loops\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  lifecycle_set_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    utils_run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(scheduler_add_render_callback);\n  }\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach(c => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach(c => c());\n  render_callbacks = filtered;\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/transitions.js\n\n\n\n\n\n\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n  if (!promise) {\n    promise = Promise.resolve();\n    promise.then(() => {\n      promise = null;\n    });\n  }\n  return promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n  node.dispatchEvent(dom_custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nfunction transitions_group_outros() {\n  outros = {\n    r: 0,\n    c: [],\n    p: outros // parent group\n  };\n}\n\n/**\n * @returns {void} */\nfunction transitions_check_outros() {\n  if (!outros.r) {\n    utils_run_all(outros.c);\n  }\n  outros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nfunction transitions_transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nfunction transitions_transition_out(block, local, detach, callback) {\n  if (block && block.o) {\n    if (outroing.has(block)) return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach) block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = {\n  duration: 0\n};\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nfunction create_in_transition(node, fn, params) {\n  /**\n   * @type {TransitionOptions} */\n  const options = {\n    direction: 'in'\n  };\n  let config = fn(node, params, options);\n  let running = false;\n  let animation_name;\n  let task;\n  let uid = 0;\n\n  /**\n   * @returns {void} */\n  function cleanup() {\n    if (animation_name) style_manager_delete_rule(node, animation_name);\n  }\n\n  /**\n   * @returns {void} */\n  function go() {\n    const {\n      delay = 0,\n      duration = 300,\n      easing = identity,\n      tick = utils_noop,\n      css\n    } = config || null_transition;\n    if (css) animation_name = style_manager_create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n    tick(0, 1);\n    const start_time = environment_now() + delay;\n    const end_time = start_time + duration;\n    if (task) task.abort();\n    running = true;\n    scheduler_add_render_callback(() => dispatch(node, true, 'start'));\n    task = loop_loop(now => {\n      if (running) {\n        if (now >= end_time) {\n          tick(1, 0);\n          dispatch(node, true, 'end');\n          cleanup();\n          return running = false;\n        }\n        if (now >= start_time) {\n          const t = easing((now - start_time) / duration);\n          tick(t, 1 - t);\n        }\n      }\n      return running;\n    });\n  }\n  let started = false;\n  return {\n    start() {\n      if (started) return;\n      started = true;\n      style_manager_delete_rule(node);\n      if (utils_is_function(config)) {\n        config = config(options);\n        wait().then(go);\n      } else {\n        go();\n      }\n    },\n    invalidate() {\n      started = false;\n    },\n    end() {\n      if (running) {\n        cleanup();\n        running = false;\n      }\n    }\n  };\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nfunction create_out_transition(node, fn, params) {\n  /** @type {TransitionOptions} */\n  const options = {\n    direction: 'out'\n  };\n  let config = fn(node, params, options);\n  let running = true;\n  let animation_name;\n  const group = outros;\n  group.r += 1;\n  /** @type {boolean} */\n  let original_inert_value;\n\n  /**\n   * @returns {void} */\n  function go() {\n    const {\n      delay = 0,\n      duration = 300,\n      easing = identity,\n      tick = utils_noop,\n      css\n    } = config || null_transition;\n    if (css) animation_name = style_manager_create_rule(node, 1, 0, duration, delay, easing, css);\n    const start_time = environment_now() + delay;\n    const end_time = start_time + duration;\n    scheduler_add_render_callback(() => dispatch(node, false, 'start'));\n    if ('inert' in node) {\n      original_inert_value = /** @type {HTMLElement} */node.inert;\n      node.inert = true;\n    }\n    loop_loop(now => {\n      if (running) {\n        if (now >= end_time) {\n          tick(0, 1);\n          dispatch(node, false, 'end');\n          if (! --group.r) {\n            // this will result in `end()` being called,\n            // so we don't need to clean up here\n            utils_run_all(group.c);\n          }\n          return false;\n        }\n        if (now >= start_time) {\n          const t = easing((now - start_time) / duration);\n          tick(1 - t, t);\n        }\n      }\n      return running;\n    });\n  }\n  if (utils_is_function(config)) {\n    wait().then(() => {\n      // @ts-ignore\n      config = config(options);\n      go();\n    });\n  } else {\n    go();\n  }\n  return {\n    end(reset) {\n      if (reset && 'inert' in node) {\n        node.inert = original_inert_value;\n      }\n      if (reset && config.tick) {\n        config.tick(1, 0);\n      }\n      if (running) {\n        if (animation_name) style_manager_delete_rule(node, animation_name);\n        running = false;\n      }\n    }\n  };\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nfunction create_bidirectional_transition(node, fn, params, intro) {\n  /**\n   * @type {TransitionOptions} */\n  const options = {\n    direction: 'both'\n  };\n  let config = fn(node, params, options);\n  let t = intro ? 0 : 1;\n\n  /**\n   * @type {Program | null} */\n  let running_program = null;\n\n  /**\n   * @type {PendingProgram | null} */\n  let pending_program = null;\n  let animation_name = null;\n\n  /** @type {boolean} */\n  let original_inert_value;\n\n  /**\n   * @returns {void} */\n  function clear_animation() {\n    if (animation_name) delete_rule(node, animation_name);\n  }\n\n  /**\n   * @param {PendingProgram} program\n   * @param {number} duration\n   * @returns {Program}\n   */\n  function init(program, duration) {\n    const d = /** @type {Program['d']} */program.b - t;\n    duration *= Math.abs(d);\n    return {\n      a: t,\n      b: program.b,\n      d,\n      duration,\n      start: program.start,\n      end: program.start + duration,\n      group: program.group\n    };\n  }\n\n  /**\n   * @param {INTRO | OUTRO} b\n   * @returns {void}\n   */\n  function go(b) {\n    const {\n      delay = 0,\n      duration = 300,\n      easing = linear,\n      tick = noop,\n      css\n    } = config || null_transition;\n\n    /**\n     * @type {PendingProgram} */\n    const program = {\n      start: now() + delay,\n      b\n    };\n    if (!b) {\n      // @ts-ignore todo: improve typings\n      program.group = outros;\n      outros.r += 1;\n    }\n    if ('inert' in node) {\n      if (b) {\n        if (original_inert_value !== undefined) {\n          // aborted/reversed outro — restore previous inert value\n          node.inert = original_inert_value;\n        }\n      } else {\n        original_inert_value = /** @type {HTMLElement} */node.inert;\n        node.inert = true;\n      }\n    }\n    if (running_program || pending_program) {\n      pending_program = program;\n    } else {\n      // if this is an intro, and there's a delay, we need to do\n      // an initial tick and/or apply CSS animation immediately\n      if (css) {\n        clear_animation();\n        animation_name = create_rule(node, t, b, duration, delay, easing, css);\n      }\n      if (b) tick(0, 1);\n      running_program = init(program, duration);\n      add_render_callback(() => dispatch(node, b, 'start'));\n      loop(now => {\n        if (pending_program && now > pending_program.start) {\n          running_program = init(pending_program, duration);\n          pending_program = null;\n          dispatch(node, running_program.b, 'start');\n          if (css) {\n            clear_animation();\n            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n          }\n        }\n        if (running_program) {\n          if (now >= running_program.end) {\n            tick(t = running_program.b, 1 - t);\n            dispatch(node, running_program.b, 'end');\n            if (!pending_program) {\n              // we're done\n              if (running_program.b) {\n                // intro — we can tidy up immediately\n                clear_animation();\n              } else {\n                // outro — needs to be coordinated\n                if (! --running_program.group.r) run_all(running_program.group.c);\n              }\n            }\n            running_program = null;\n          } else if (now >= running_program.start) {\n            const p = now - running_program.start;\n            t = running_program.a + running_program.d * easing(p / running_program.duration);\n            tick(t, 1 - t);\n          }\n        }\n        return !!(running_program || pending_program);\n      });\n    }\n  }\n  return {\n    run(b) {\n      if (is_function(config)) {\n        wait().then(() => {\n          const opts = {\n            direction: b ? 'in' : 'out'\n          };\n          // @ts-ignore\n          config = config(opts);\n          go(b);\n        });\n      } else {\n        go(b);\n      }\n    },\n    end() {\n      clear_animation();\n      running_program = pending_program = null;\n    }\n  };\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/await_block.js\n\n\n\n\n\n/**\n * @template T\n * @param {Promise<T>} promise\n * @param {import('./private.js').PromiseInfo<T>} info\n * @returns {boolean}\n */\nfunction handle_promise(promise, info) {\n  const token = info.token = {};\n  /**\n   * @param {import('./private.js').FragmentFactory} type\n   * @param {0 | 1 | 2} index\n   * @param {number} [key]\n   * @param {any} [value]\n   * @returns {void}\n   */\n  function update(type, index, key, value) {\n    if (info.token !== token) return;\n    info.resolved = value;\n    let child_ctx = info.ctx;\n    if (key !== undefined) {\n      child_ctx = child_ctx.slice();\n      child_ctx[key] = value;\n    }\n    const block = type && (info.current = type)(child_ctx);\n    let needs_flush = false;\n    if (info.block) {\n      if (info.blocks) {\n        info.blocks.forEach((block, i) => {\n          if (i !== index && block) {\n            group_outros();\n            transition_out(block, 1, 1, () => {\n              if (info.blocks[i] === block) {\n                info.blocks[i] = null;\n              }\n            });\n            check_outros();\n          }\n        });\n      } else {\n        info.block.d(1);\n      }\n      block.c();\n      transition_in(block, 1);\n      block.m(info.mount(), info.anchor);\n      needs_flush = true;\n    }\n    info.block = block;\n    if (info.blocks) info.blocks[index] = block;\n    if (needs_flush) {\n      flush();\n    }\n  }\n  if (is_promise(promise)) {\n    const current_component = get_current_component();\n    promise.then(value => {\n      set_current_component(current_component);\n      update(info.then, 1, info.value, value);\n      set_current_component(null);\n    }, error => {\n      set_current_component(current_component);\n      update(info.catch, 2, info.error, error);\n      set_current_component(null);\n      if (!info.hasCatch) {\n        throw error;\n      }\n    });\n    // if we previously had a then/catch block, destroy it\n    if (info.current !== info.pending) {\n      update(info.pending, 0);\n      return true;\n    }\n  } else {\n    if (info.current !== info.then) {\n      update(info.then, 1, info.value, promise);\n      return true;\n    }\n    info.resolved = /** @type {T} */promise;\n  }\n}\n\n/** @returns {void} */\nfunction update_await_block_branch(info, ctx, dirty) {\n  const child_ctx = ctx.slice();\n  const {\n    resolved\n  } = info;\n  if (info.current === info.then) {\n    child_ctx[info.value] = resolved;\n  }\n  if (info.current === info.catch) {\n    child_ctx[info.error] = resolved;\n  }\n  info.block.p(child_ctx, dirty);\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/each.js\n\n\n\n// general each functions:\n\nfunction each_ensure_array_like(array_like_or_iterator) {\n  return array_like_or_iterator?.length !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nfunction destroy_block(block, lookup) {\n  block.d(1);\n  lookup.delete(block.key);\n}\n\n/** @returns {void} */\nfunction outro_and_destroy_block(block, lookup) {\n  transitions_transition_out(block, 1, 1, () => {\n    lookup.delete(block.key);\n  });\n}\n\n/** @returns {void} */\nfunction fix_and_destroy_block(block, lookup) {\n  block.f();\n  destroy_block(block, lookup);\n}\n\n/** @returns {void} */\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n  block.f();\n  outro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n  let o = old_blocks.length;\n  let n = list.length;\n  let i = o;\n  const old_indexes = {};\n  while (i--) old_indexes[old_blocks[i].key] = i;\n  const new_blocks = [];\n  const new_lookup = new Map();\n  const deltas = new Map();\n  const updates = [];\n  i = n;\n  while (i--) {\n    const child_ctx = get_context(ctx, list, i);\n    const key = get_key(child_ctx);\n    let block = lookup.get(key);\n    if (!block) {\n      block = create_each_block(key, child_ctx);\n      block.c();\n    } else if (dynamic) {\n      // defer updates until all the DOM shuffling is done\n      updates.push(() => block.p(child_ctx, dirty));\n    }\n    new_lookup.set(key, new_blocks[i] = block);\n    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n  }\n  const will_move = new Set();\n  const did_move = new Set();\n  /** @returns {void} */\n  function insert(block) {\n    transitions_transition_in(block, 1);\n    block.m(node, next);\n    lookup.set(block.key, block);\n    next = block.first;\n    n--;\n  }\n  while (o && n) {\n    const new_block = new_blocks[n - 1];\n    const old_block = old_blocks[o - 1];\n    const new_key = new_block.key;\n    const old_key = old_block.key;\n    if (new_block === old_block) {\n      // do nothing\n      next = new_block.first;\n      o--;\n      n--;\n    } else if (!new_lookup.has(old_key)) {\n      // remove old block\n      destroy(old_block, lookup);\n      o--;\n    } else if (!lookup.has(new_key) || will_move.has(new_key)) {\n      insert(new_block);\n    } else if (did_move.has(old_key)) {\n      o--;\n    } else if (deltas.get(new_key) > deltas.get(old_key)) {\n      did_move.add(new_key);\n      insert(new_block);\n    } else {\n      will_move.add(old_key);\n      o--;\n    }\n  }\n  while (o--) {\n    const old_block = old_blocks[o];\n    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n  }\n  while (n) insert(new_blocks[n - 1]);\n  utils_run_all(updates);\n  return new_blocks;\n}\n\n/** @returns {void} */\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n  const keys = new Map();\n  for (let i = 0; i < list.length; i++) {\n    const key = get_key(get_context(ctx, list, i));\n    if (keys.has(key)) {\n      let value = '';\n      try {\n        value = `with value '${String(key)}' `;\n      } catch (e) {\n        // can't stringify\n      }\n      throw new Error(`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(key)} and ${i} ${value}are duplicates`);\n    }\n    keys.set(key, i);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/spread.js\n/** @returns {{}} */\nfunction get_spread_update(levels, updates) {\n  const update = {};\n  const to_null_out = {};\n  const accounted_for = {\n    $$scope: 1\n  };\n  let i = levels.length;\n  while (i--) {\n    const o = levels[i];\n    const n = updates[i];\n    if (n) {\n      for (const key in o) {\n        if (!(key in n)) to_null_out[key] = 1;\n      }\n      for (const key in n) {\n        if (!accounted_for[key]) {\n          update[key] = n[key];\n          accounted_for[key] = 1;\n        }\n      }\n      levels[i] = n;\n    } else {\n      for (const key in o) {\n        accounted_for[key] = 1;\n      }\n    }\n  }\n  for (const key in to_null_out) {\n    if (!(key in update)) update[key] = undefined;\n  }\n  return update;\n}\nfunction get_spread_object(spread_props) {\n  return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/boolean_attributes.js\nconst _boolean_attributes = /** @type {const} */['allowfullscreen', 'allowpaymentrequest', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'defer', 'disabled', 'formnovalidate', 'hidden', 'inert', 'ismap', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'selected'];\n\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n *\n * @type {Set<string>}\n */\nconst boolean_attributes_boolean_attributes = new Set([..._boolean_attributes]);\n\n/** @typedef {typeof _boolean_attributes[number]} BooleanAttributes */\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ssr.js\n\n\n\n\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\n\n/** @returns {string} */\nfunction spread(args, attrs_to_add) {\n  const attributes = Object.assign({}, ...args);\n  if (attrs_to_add) {\n    const classes_to_add = attrs_to_add.classes;\n    const styles_to_add = attrs_to_add.styles;\n    if (classes_to_add) {\n      if (attributes.class == null) {\n        attributes.class = classes_to_add;\n      } else {\n        attributes.class += ' ' + classes_to_add;\n      }\n    }\n    if (styles_to_add) {\n      if (attributes.style == null) {\n        attributes.style = style_object_to_string(styles_to_add);\n      } else {\n        attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n      }\n    }\n  }\n  let str = '';\n  Object.keys(attributes).forEach(name => {\n    if (invalid_attribute_name_character.test(name)) return;\n    const value = attributes[name];\n    if (value === true) str += ' ' + name;else if (boolean_attributes.has(name.toLowerCase())) {\n      if (value) str += ' ' + name;\n    } else if (value != null) {\n      str += ` ${name}=\"${value}\"`;\n    }\n  });\n  return str;\n}\n\n/** @returns {{}} */\nfunction merge_ssr_styles(style_attribute, style_directive) {\n  const style_object = {};\n  for (const individual_style of style_attribute.split(';')) {\n    const colon_index = individual_style.indexOf(':');\n    const name = individual_style.slice(0, colon_index).trim();\n    const value = individual_style.slice(colon_index + 1).trim();\n    if (!name) continue;\n    style_object[name] = value;\n  }\n  for (const name in style_directive) {\n    const value = style_directive[name];\n    if (value) {\n      style_object[name] = value;\n    } else {\n      delete style_object[name];\n    }\n  }\n  return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n * @param {unknown} value\n * @returns {string}\n */\nfunction ssr_escape(value, is_attr = false) {\n  const str = String(value);\n  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n  pattern.lastIndex = 0;\n  let escaped = '';\n  let last = 0;\n  while (pattern.test(str)) {\n    const i = pattern.lastIndex - 1;\n    const ch = str[i];\n    escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '\"' ? '&quot;' : '&lt;');\n    last = i + 1;\n  }\n  return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n  // keep booleans, null, and undefined for the sake of `spread`\n  const should_escape = typeof value === 'string' || value && typeof value === 'object';\n  return should_escape ? ssr_escape(value, true) : value;\n}\n\n/** @returns {{}} */\nfunction escape_object(obj) {\n  const result = {};\n  for (const key in obj) {\n    result[key] = escape_attribute_value(obj[key]);\n  }\n  return result;\n}\n\n/** @returns {string} */\nfunction each(items, fn) {\n  items = ensure_array_like(items);\n  let str = '';\n  for (let i = 0; i < items.length; i += 1) {\n    str += fn(items[i], i);\n  }\n  return str;\n}\nconst missing_component = {\n  $$render: () => ''\n};\nfunction validate_component(component, name) {\n  if (!component || !component.$$render) {\n    if (name === 'svelte:component') name += ' this={...}';\n    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n  }\n  return component;\n}\n\n/** @returns {string} */\nfunction debug(file, line, column, values) {\n  console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n  console.log(values); // eslint-disable-line no-console\n  return '';\n}\nlet on_destroy;\n\n/** @returns {{ render: (props?: {}, { $$slots, context }?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; }; $$render: (result: any, props: any, bindings: any, slots: any, context: any) => any; }} */\nfunction create_ssr_component(fn) {\n  function $$render(result, props, bindings, slots, context) {\n    const parent_component = current_component;\n    const $$ = {\n      on_destroy,\n      context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n      // these will be immediately discarded\n      on_mount: [],\n      before_update: [],\n      after_update: [],\n      callbacks: blank_object()\n    };\n    set_current_component({\n      $$\n    });\n    const html = fn(result, props, bindings, slots);\n    set_current_component(parent_component);\n    return html;\n  }\n  return {\n    render: (props = {}, {\n      $$slots = {},\n      context = new Map()\n    } = {}) => {\n      on_destroy = [];\n      const result = {\n        title: '',\n        head: '',\n        css: new Set()\n      };\n      const html = $$render(result, props, {}, $$slots, context);\n      run_all(on_destroy);\n      return {\n        html,\n        css: {\n          code: Array.from(result.css).map(css => css.code).join('\\n'),\n          map: null // TODO\n        },\n        head: result.title + result.head\n      };\n    },\n    $$render\n  };\n}\n\n/** @returns {string} */\nfunction add_attribute(name, value, boolean) {\n  if (value == null || boolean && !value) return '';\n  const assignment = boolean && value === true ? '' : `=\"${ssr_escape(value, true)}\"`;\n  return ` ${name}${assignment}`;\n}\n\n/** @returns {string} */\nfunction add_classes(classes) {\n  return classes ? ` class=\"${classes}\"` : '';\n}\n\n/** @returns {string} */\nfunction style_object_to_string(style_object) {\n  return Object.keys(style_object).filter(key => style_object[key] != null && style_object[key] !== '').map(key => `${key}: ${escape_attribute_value(style_object[key])};`).join(' ');\n}\n\n/** @returns {string} */\nfunction add_styles(style_object) {\n  const styles = style_object_to_string(style_object);\n  return styles ? ` style=\"${styles}\"` : '';\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/Component.js\n\n\n\n\n\n\n/** @returns {void} */\nfunction bind(component, name, callback) {\n  const index = component.$$.props[name];\n  if (index !== undefined) {\n    component.$$.bound[index] = callback;\n    callback(component.$$.ctx[index]);\n  }\n}\n\n/** @returns {void} */\nfunction create_component(block) {\n  block && block.c();\n}\n\n/** @returns {void} */\nfunction claim_component(block, parent_nodes) {\n  block && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nfunction mount_component(component, target, anchor) {\n  const {\n    fragment,\n    after_update\n  } = component.$$;\n  fragment && fragment.m(target, anchor);\n  // onMount happens before the initial afterUpdate\n  scheduler_add_render_callback(() => {\n    const new_on_destroy = component.$$.on_mount.map(run).filter(utils_is_function);\n    // if the component was destroyed immediately\n    // it will update the `$$.on_destroy` reference to `null`.\n    // the destructured on_destroy may still reference to the old array\n    if (component.$$.on_destroy) {\n      component.$$.on_destroy.push(...new_on_destroy);\n    } else {\n      // Edge case - component was destroyed immediately,\n      // most likely as a result of a binding initialising\n      utils_run_all(new_on_destroy);\n    }\n    component.$$.on_mount = [];\n  });\n  after_update.forEach(scheduler_add_render_callback);\n}\n\n/** @returns {void} */\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    utils_run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    // TODO null out other refs, including component.$$ (but need to\n    // preserve final state?)\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles = null, dirty = [-1]) {\n  const parent_component = lifecycle_current_component;\n  lifecycle_set_current_component(component);\n  /** @type {import('./private.js').T$$} */\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: utils_noop,\n    not_equal,\n    bound: utils_blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: utils_blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n      if (ready) make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  utils_run_all($$.before_update);\n  // `false` as a special case of no DOM component\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      // TODO: what is the correct type here?\n      // @ts-expect-error\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(dom_detach);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro) transitions_transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor);\n    end_hydrating();\n    scheduler_flush();\n  }\n  lifecycle_set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n  SvelteElement = class extends HTMLElement {\n    /** The Svelte component constructor */\n    $$ctor;\n    /** Slots */\n    $$s;\n    /** The Svelte component instance */\n    $$c;\n    /** Whether or not the custom element is connected */\n    $$cn = false;\n    /** Component props data */\n    $$d = {};\n    /** `true` if currently in the process of reflecting component props back to attributes */\n    $$r = false;\n    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n    $$p_d = {};\n    /** @type {Record<string, Function[]>} Event listeners */\n    $$l = {};\n    /** @type {Map<Function, Function>} Event listener unsubscribe functions */\n    $$l_u = new Map();\n    constructor($$componentCtor, $$slots, use_shadow_dom) {\n      super();\n      this.$$ctor = $$componentCtor;\n      this.$$s = $$slots;\n      if (use_shadow_dom) {\n        this.attachShadow({\n          mode: 'open'\n        });\n      }\n    }\n    addEventListener(type, listener, options) {\n      // We can't determine upfront if the event is a custom event or not, so we have to\n      // listen to both. If someone uses a custom event with the same name as a regular\n      // browser event, this fires twice - we can't avoid that.\n      this.$$l[type] = this.$$l[type] || [];\n      this.$$l[type].push(listener);\n      if (this.$$c) {\n        const unsub = this.$$c.$on(type, listener);\n        this.$$l_u.set(listener, unsub);\n      }\n      super.addEventListener(type, listener, options);\n    }\n    removeEventListener(type, listener, options) {\n      super.removeEventListener(type, listener, options);\n      if (this.$$c) {\n        const unsub = this.$$l_u.get(listener);\n        if (unsub) {\n          unsub();\n          this.$$l_u.delete(listener);\n        }\n      }\n    }\n    async connectedCallback() {\n      this.$$cn = true;\n      if (!this.$$c) {\n        // We wait one tick to let possible child slot elements be created/mounted\n        await Promise.resolve();\n        if (!this.$$cn || this.$$c) {\n          return;\n        }\n        function create_slot(name) {\n          return () => {\n            let node;\n            const obj = {\n              c: function create() {\n                node = dom_element('slot');\n                if (name !== 'default') {\n                  dom_attr(node, 'name', name);\n                }\n              },\n              /**\n               * @param {HTMLElement} target\n               * @param {HTMLElement} [anchor]\n               */\n              m: function mount(target, anchor) {\n                dom_insert(target, node, anchor);\n              },\n              d: function destroy(detaching) {\n                if (detaching) {\n                  dom_detach(node);\n                }\n              }\n            };\n            return obj;\n          };\n        }\n        const $$slots = {};\n        const existing_slots = get_custom_elements_slots(this);\n        for (const name of this.$$s) {\n          if (name in existing_slots) {\n            $$slots[name] = [create_slot(name)];\n          }\n        }\n        for (const attribute of this.attributes) {\n          // this.$$data takes precedence over this.attributes\n          const name = this.$$g_p(attribute.name);\n          if (!(name in this.$$d)) {\n            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n          }\n        }\n        // Port over props that were set programmatically before ce was initialized\n        for (const key in this.$$p_d) {\n          if (!(key in this.$$d) && this[key] !== undefined) {\n            this.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n            delete this[key]; // remove the property that shadows the getter/setter\n          }\n        }\n        this.$$c = new this.$$ctor({\n          target: this.shadowRoot || this,\n          props: {\n            ...this.$$d,\n            $$slots,\n            $$scope: {\n              ctx: []\n            }\n          }\n        });\n\n        // Reflect component props as attributes\n        const reflect_attributes = () => {\n          this.$$r = true;\n          for (const key in this.$$p_d) {\n            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n            if (this.$$p_d[key].reflect) {\n              const attribute_value = get_custom_element_value(key, this.$$d[key], this.$$p_d, 'toAttribute');\n              if (attribute_value == null) {\n                this.removeAttribute(this.$$p_d[key].attribute || key);\n              } else {\n                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n              }\n            }\n          }\n          this.$$r = false;\n        };\n        this.$$c.$$.after_update.push(reflect_attributes);\n        reflect_attributes(); // once initially because after_update is added too late for first render\n\n        for (const type in this.$$l) {\n          for (const listener of this.$$l[type]) {\n            const unsub = this.$$c.$on(type, listener);\n            this.$$l_u.set(listener, unsub);\n          }\n        }\n        this.$$l = {};\n      }\n    }\n\n    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n    // and setting attributes through setAttribute etc, this is helpful\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      if (this.$$r) return;\n      attr = this.$$g_p(attr);\n      this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n      this.$$c?.$set({\n        [attr]: this.$$d[attr]\n      });\n    }\n    disconnectedCallback() {\n      this.$$cn = false;\n      // In a microtask, because this could be a move within the DOM\n      Promise.resolve().then(() => {\n        if (!this.$$cn && this.$$c) {\n          this.$$c.$destroy();\n          this.$$c = undefined;\n        }\n      });\n    }\n    $$g_p(attribute_name) {\n      return Object.keys(this.$$p_d).find(key => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name) || attribute_name;\n    }\n  };\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n  const type = props_definition[prop]?.type;\n  value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n  if (!transform || !props_definition[prop]) {\n    return value;\n  } else if (transform === 'toAttribute') {\n    switch (type) {\n      case 'Object':\n      case 'Array':\n        return value == null ? null : JSON.stringify(value);\n      case 'Boolean':\n        return value ? '' : null;\n      case 'Number':\n        return value == null ? null : value;\n      default:\n        return value;\n    }\n  } else {\n    switch (type) {\n      case 'Object':\n      case 'Array':\n        return value && JSON.parse(value);\n      case 'Boolean':\n        return value;\n      // conversion already handled above\n      case 'Number':\n        return value != null ? +value : value;\n      default:\n        return value;\n    }\n  }\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nfunction create_custom_element(Component, props_definition, slots, accessors, use_shadow_dom, extend) {\n  let Class = class extends SvelteElement {\n    constructor() {\n      super(Component, slots, use_shadow_dom);\n      this.$$p_d = props_definition;\n    }\n    static get observedAttributes() {\n      return Object.keys(props_definition).map(key => (props_definition[key].attribute || key).toLowerCase());\n    }\n  };\n  Object.keys(props_definition).forEach(prop => {\n    Object.defineProperty(Class.prototype, prop, {\n      get() {\n        return this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n      },\n      set(value) {\n        value = get_custom_element_value(prop, value, props_definition);\n        this.$$d[prop] = value;\n        this.$$c?.$set({\n          [prop]: value\n        });\n      }\n    });\n  });\n  accessors.forEach(accessor => {\n    Object.defineProperty(Class.prototype, accessor, {\n      get() {\n        return this.$$c?.[accessor];\n      }\n    });\n  });\n  if (extend) {\n    // @ts-expect-error - assigning here is fine\n    Class = extend(Class);\n  }\n  Component.element = /** @type {any} */Class;\n  return Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nclass SvelteComponent {\n  /**\n   * ### PRIVATE API\n   *\n   * Do not use, may change at any time\n   *\n   * @type {any}\n   */\n  $$ = undefined;\n  /**\n   * ### PRIVATE API\n   *\n   * Do not use, may change at any time\n   *\n   * @type {any}\n   */\n  $$set = undefined;\n\n  /** @returns {void} */\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = utils_noop;\n  }\n\n  /**\n   * @template {Extract<keyof Events, string>} K\n   * @param {K} type\n   * @param {((e: Events[K]) => void) | null | undefined} callback\n   * @returns {() => void}\n   */\n  $on(type, callback) {\n    if (!utils_is_function(callback)) {\n      return utils_noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) callbacks.splice(index, 1);\n    };\n  }\n\n  /**\n   * @param {Partial<Props>} props\n   * @returns {void}\n   */\n  $set(props) {\n    if (this.$$set && !is_empty(props)) {\n      this.$$.skip_bound = true;\n      this.$$set(props);\n      this.$$.skip_bound = false;\n    }\n  }\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dev.js\n\n\n\n\n\n\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @returns {void}\n */\nfunction dispatch_dev(type, detail) {\n  document.dispatchEvent(custom_event(type, {\n    version: VERSION,\n    ...detail\n  }, {\n    bubbles: true\n  }));\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nfunction append_dev(target, node) {\n  dispatch_dev('SvelteDOMInsert', {\n    target,\n    node\n  });\n  append(target, node);\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nfunction append_hydration_dev(target, node) {\n  dispatch_dev('SvelteDOMInsert', {\n    target,\n    node\n  });\n  append_hydration(target, node);\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nfunction insert_dev(target, node, anchor) {\n  dispatch_dev('SvelteDOMInsert', {\n    target,\n    node,\n    anchor\n  });\n  insert(target, node, anchor);\n}\n\n/** @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nfunction insert_hydration_dev(target, node, anchor) {\n  dispatch_dev('SvelteDOMInsert', {\n    target,\n    node,\n    anchor\n  });\n  insert_hydration(target, node, anchor);\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nfunction detach_dev(node) {\n  dispatch_dev('SvelteDOMRemove', {\n    node\n  });\n  detach(node);\n}\n\n/**\n * @param {Node} before\n * @param {Node} after\n * @returns {void}\n */\nfunction detach_between_dev(before, after) {\n  while (before.nextSibling && before.nextSibling !== after) {\n    detach_dev(before.nextSibling);\n  }\n}\n\n/**\n * @param {Node} after\n * @returns {void}\n */\nfunction detach_before_dev(after) {\n  while (after.previousSibling) {\n    detach_dev(after.previousSibling);\n  }\n}\n\n/**\n * @param {Node} before\n * @returns {void}\n */\nfunction detach_after_dev(before) {\n  while (before.nextSibling) {\n    detach_dev(before.nextSibling);\n  }\n}\n\n/**\n * @param {Node} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @param {boolean} [has_prevent_default]\n * @param {boolean} [has_stop_propagation]\n * @param {boolean} [has_stop_immediate_propagation]\n * @returns {() => void}\n */\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n  const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n  if (has_prevent_default) modifiers.push('preventDefault');\n  if (has_stop_propagation) modifiers.push('stopPropagation');\n  if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');\n  dispatch_dev('SvelteDOMAddEventListener', {\n    node,\n    event,\n    handler,\n    modifiers\n  });\n  const dispose = listen(node, event, handler, options);\n  return () => {\n    dispatch_dev('SvelteDOMRemoveEventListener', {\n      node,\n      event,\n      handler,\n      modifiers\n    });\n    dispose();\n  };\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nfunction attr_dev(node, attribute, value) {\n  attr(node, attribute, value);\n  if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {\n    node,\n    attribute\n  });else dispatch_dev('SvelteDOMSetAttribute', {\n    node,\n    attribute,\n    value\n  });\n}\n\n/**\n * @param {Element} node\n * @param {string} property\n * @param {any} [value]\n * @returns {void}\n */\nfunction prop_dev(node, property, value) {\n  node[property] = value;\n  dispatch_dev('SvelteDOMSetProperty', {\n    node,\n    property,\n    value\n  });\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} property\n * @param {any} [value]\n * @returns {void}\n */\nfunction dataset_dev(node, property, value) {\n  node.dataset[property] = value;\n  dispatch_dev('SvelteDOMSetDataset', {\n    node,\n    property,\n    value\n  });\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data_dev(text, data) {\n  data = '' + data;\n  if (text.data === data) return;\n  dispatch_dev('SvelteDOMSetData', {\n    node: text,\n    data\n  });\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data_contenteditable_dev(text, data) {\n  data = '' + data;\n  if (text.wholeText === data) return;\n  dispatch_dev('SvelteDOMSetData', {\n    node: text,\n    data\n  });\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n  if (~contenteditable_truthy_values.indexOf(attr_value)) {\n    set_data_contenteditable_dev(text, data);\n  } else {\n    set_data_dev(text, data);\n  }\n}\nfunction ensure_array_like_dev(arg) {\n  if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg) && !(typeof Symbol === 'function' && arg && Symbol.iterator in arg)) {\n    throw new Error('{#each} only works with iterable values.');\n  }\n  return ensure_array_like(arg);\n}\n\n/**\n * @returns {void} */\nfunction validate_slots(name, slot, keys) {\n  for (const slot_key of Object.keys(slot)) {\n    if (!~keys.indexOf(slot_key)) {\n      console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n    }\n  }\n}\n\n/**\n * @param {unknown} tag\n * @returns {void}\n */\nfunction validate_dynamic_element(tag) {\n  const is_string = typeof tag === 'string';\n  if (tag && !is_string) {\n    throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n  }\n}\n\n/**\n * @param {undefined | string} tag\n * @returns {void}\n */\nfunction validate_void_dynamic_element(tag) {\n  if (tag && is_void(tag)) {\n    console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n  }\n}\nfunction construct_svelte_component_dev(component, props) {\n  const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n  try {\n    const instance = new component(props);\n    if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n      throw new Error(error_message);\n    }\n    return instance;\n  } catch (err) {\n    const {\n      message\n    } = err;\n    if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n      throw new Error(error_message);\n    } else {\n      throw err;\n    }\n  }\n}\n\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n *\n * Can be used to create strongly typed Svelte components.\n *\n * #### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponent } from \"svelte\";\n * export class MyComponent extends SvelteComponent<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * <\/script>\n * <MyComponent foo={'bar'} />\n * ```\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n * @template {Record<string, any>} [Slots=any]\n * @extends {SvelteComponent<Props, Events>}\n */\nclass SvelteComponentDev extends SvelteComponent {\n  /**\n   * For type checking capabilities only.\n   * Does not exist at runtime.\n   * ### DO NOT USE!\n   *\n   * @type {Props}\n   */\n  $$prop_def;\n  /**\n   * For type checking capabilities only.\n   * Does not exist at runtime.\n   * ### DO NOT USE!\n   *\n   * @type {Events}\n   */\n  $$events_def;\n  /**\n   * For type checking capabilities only.\n   * Does not exist at runtime.\n   * ### DO NOT USE!\n   *\n   * @type {Slots}\n   */\n  $$slot_def;\n\n  /** @param {import('./public.js').ComponentConstructorOptions<Props>} options */\n  constructor(options) {\n    if (!options || !options.target && !options.$$inline) {\n      throw new Error(\"'target' is a required option\");\n    }\n    super();\n  }\n\n  /** @returns {void} */\n  $destroy() {\n    super.$destroy();\n    this.$destroy = () => {\n      console.warn('Component was already destroyed'); // eslint-disable-line no-console\n    };\n  }\n\n  /** @returns {void} */\n  $capture_state() {}\n\n  /** @returns {void} */\n  $inject_state() {}\n}\n/**\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n * @template {Record<string, any>} [Slots=any]\n * @deprecated Use `SvelteComponent` instead. See PR for more information: https://github.com/sveltejs/svelte/pull/8512\n * @extends {SvelteComponentDev<Props, Events, Slots>}\n */\nclass SvelteComponentTyped extends (/* unused pure expression or super */ null && (SvelteComponentDev)) {}\n\n/** @returns {() => void} */\nfunction loop_guard(timeout) {\n  const start = Date.now();\n  return () => {\n    if (Date.now() - start > timeout) {\n      throw new Error('Infinite loop detected');\n    }\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLCtCQUErQixDQUFDO0lBQ2pEO0lBQ0EsS0FBSyxDQUFDLENBQUM7RUFDUjs7RUFFQTtFQUNBOG1CLFFBQVFBLENBQUEsRUFBRztJQUNWLEtBQUssQ0FBQ0EsUUFBUSxDQUFDLENBQUM7SUFDaEIsSUFBSSxDQUFDQSxRQUFRLEdBQUcsTUFBTTtNQUNyQjNELE9BQU8sQ0FBQzZHLElBQUksQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztFQUNGOztFQUVBO0VBQ0FhLGNBQWNBLENBQUEsRUFBRyxDQUFDOztFQUVsQjtFQUNBQyxhQUFhQSxDQUFBLEVBQUcsQ0FBQztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUMsb0JBQW9CLFNBQVNQLGdEQUFBQSxrQkFBa0IsR0FBQzs7QUFFN0Q7QUFDTyxTQUFTUSxVQUFVQSxDQUFDQyxPQUFPLEVBQUU7RUFDbkMsTUFBTXJiLEtBQUssR0FBR3RMLElBQUksQ0FBQ0YsR0FBRyxDQUFDLENBQUM7RUFDeEIsT0FBTyxNQUFNO0lBQ1osSUFBSUUsSUFBSSxDQUFDRixHQUFHLENBQUMsQ0FBQyxHQUFHd0wsS0FBSyxHQUFHcWIsT0FBTyxFQUFFO01BQ2pDLE1BQU0sSUFBSWpyQixLQUFLLENBQUMsd0JBQXdCLENBQUM7SUFDMUM7RUFDRCxDQUFDO0FBQ0YsQzs7QUM1V2dDO0FBQ0M7QUFDUjtBQUNRO0FBQ0o7QUFDSDtBQUNLO0FBQ0w7QUFDSztBQUNIO0FBQ0g7QUFDUTtBQUNOO0FBQ0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3V0aWxzLmpzPzk4NGUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9lbnZpcm9ubWVudC5qcz8zNmU4Iiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvbG9vcC5qcz9kNGZlIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZ2xvYmFscy5qcz9mMWQyIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uanM/ZDI1OSIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2RvbS5qcz8wZGFjIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvc3R5bGVfbWFuYWdlci5qcz85ZDE2Iiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvYW5pbWF0aW9ucy5qcz8xNjc0Iiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvbGlmZWN5Y2xlLmpzPzIxYjIiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9zY2hlZHVsZXIuanM/MTVmNyIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3RyYW5zaXRpb25zLmpzP2ViODciLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9hd2FpdF9ibG9jay5qcz8xMmZjIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZWFjaC5qcz9iMjAzIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvc3ByZWFkLmpzP2EwMmYiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc2hhcmVkL2Jvb2xlYW5fYXR0cmlidXRlcy5qcz8wYjQ3Iiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvc3NyLmpzPzM0NjgiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9Db21wb25lbnQuanM/YzRhYSIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2Rldi5qcz82NjRlIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvaW5kZXguanM/ZTEyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9ICh4KSA9PiB4O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgU1xuICogQHBhcmFtIHtUfSB0YXJcbiAqIEBwYXJhbSB7U30gc3JjXG4gKiBAcmV0dXJucyB7VCAmIFN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRmb3IgKGNvbnN0IGsgaW4gc3JjKSB0YXJba10gPSBzcmNba107XG5cdHJldHVybiAvKiogQHR5cGUge1QgJiBTfSAqLyAodGFyKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBQcm9taXNlTGlrZTxhbnk+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gKFxuXHRcdCEhdmFsdWUgJiZcblx0XHQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmXG5cdFx0dHlwZW9mICgvKiogQHR5cGUge2FueX0gKi8gKHZhbHVlKS50aGVuKSA9PT0gJ2Z1bmN0aW9uJ1xuXHQpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuXHRlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG5cdFx0bG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0cmV0dXJuIGZuKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG5cdHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZm5zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG5cdGZucy5mb3JFYWNoKHJ1bik7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRoaW5nXG4gKiBAcmV0dXJucyB7dGhpbmcgaXMgRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuXHRyZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xufVxuXG5sZXQgc3JjX3VybF9lcXVhbF9hbmNob3I7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRfc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuXHRpZiAoZWxlbWVudF9zcmMgPT09IHVybCkgcmV0dXJuIHRydWU7XG5cdGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcblx0XHRzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0fVxuXHQvLyBUaGlzIGlzIGFjdHVhbGx5IGZhc3RlciB0aGFuIGRvaW5nIFVSTCguLikuaHJlZlxuXHRzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmID0gdXJsO1xuXHRyZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0ICovXG5mdW5jdGlvbiBzcGxpdF9zcmNzZXQoc3Jjc2V0KSB7XG5cdHJldHVybiBzcmNzZXQuc3BsaXQoJywnKS5tYXAoKHNyYykgPT4gc3JjLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU291cmNlRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRfc3Jjc2V0XG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IHNyY3NldFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnRfc3Jjc2V0LCBzcmNzZXQpIHtcblx0Y29uc3QgZWxlbWVudF91cmxzID0gc3BsaXRfc3Jjc2V0KGVsZW1lbnRfc3Jjc2V0LnNyY3NldCk7XG5cdGNvbnN0IHVybHMgPSBzcGxpdF9zcmNzZXQoc3Jjc2V0IHx8ICcnKTtcblxuXHRyZXR1cm4gKFxuXHRcdHVybHMubGVuZ3RoID09PSBlbGVtZW50X3VybHMubGVuZ3RoICYmXG5cdFx0dXJscy5ldmVyeShcblx0XHRcdChbdXJsLCB3aWR0aF0sIGkpID0+XG5cdFx0XHRcdHdpZHRoID09PSBlbGVtZW50X3VybHNbaV1bMV0gJiZcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byB0ZXN0IGJvdGggd2F5cyBiZWNhdXNlIFZpdGUgd2lsbCBjcmVhdGUgYW4gYSBmdWxsIFVSTCB3aXRoXG5cdFx0XHRcdC8vIGBuZXcgVVJMKGFzc2V0LCBpbXBvcnQubWV0YS51cmwpLmhyZWZgIGZvciB0aGUgY2xpZW50IHdoZW4gYGJhc2U6ICcuLydgLCBhbmQgdGhlXG5cdFx0XHRcdC8vIHJlbGF0aXZlIFVSTHMgaW5zaWRlIHNyY3NldCBhcmUgbm90IGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgdG8gYWJzb2x1dGUgVVJMcyBieVxuXHRcdFx0XHQvLyBicm93c2VycyAoaW4gY29udHJhc3QgdG8gaW1nLnNyYykuIFRoaXMgbWVhbnMgYm90aCBTU1IgYW5kIERPTSBjb2RlIGNvdWxkXG5cdFx0XHRcdC8vIGNvbnRhaW4gcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMcy5cblx0XHRcdFx0KHNyY191cmxfZXF1YWwoZWxlbWVudF91cmxzW2ldWzBdLCB1cmwpIHx8IHNyY191cmxfZXF1YWwodXJsLCBlbGVtZW50X3VybHNbaV1bMF0pKVxuXHRcdClcblx0KTtcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG5cdGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG5cdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcblx0XHRcdGNhbGxiYWNrKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRcdHJldHVybiBub29wO1xuXHR9XG5cdGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG5cdHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSBhIHN0b3JlIGJ5IHN1YnNjcmliaW5nIGFuZCBpbW1lZGlhdGVseSB1bnN1YnNjcmliaW5nLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNnZXRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vc3RvcmUvcHVibGljLmpzJykuUmVhZGFibGU8VD59IHN0b3JlXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuXHRsZXQgdmFsdWU7XG5cdHN1YnNjcmliZShzdG9yZSwgKF8pID0+ICh2YWx1ZSA9IF8pKSgpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG5cdGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuXHRpZiAoZGVmaW5pdGlvbikge1xuXHRcdGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcblx0XHRyZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpIDogJCRzY29wZS5jdHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuXHRpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuXHRcdGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG5cdFx0aWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxldHM7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGNvbnN0IG1lcmdlZCA9IFtdO1xuXHRcdFx0Y29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRcdFx0bWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWVyZ2VkO1xuXHRcdH1cblx0XHRyZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG5cdH1cblx0cmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKFxuXHRzbG90LFxuXHRzbG90X2RlZmluaXRpb24sXG5cdGN0eCxcblx0JCRzY29wZSxcblx0c2xvdF9jaGFuZ2VzLFxuXHRnZXRfc2xvdF9jb250ZXh0X2ZuXG4pIHtcblx0aWYgKHNsb3RfY2hhbmdlcykge1xuXHRcdGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuXHRcdHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90KFxuXHRzbG90LFxuXHRzbG90X2RlZmluaXRpb24sXG5cdGN0eCxcblx0JCRzY29wZSxcblx0ZGlydHksXG5cdGdldF9zbG90X2NoYW5nZXNfZm4sXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuXHR1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdIHwgLTF9ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlKCQkc2NvcGUpIHtcblx0aWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG5cdFx0Y29uc3QgZGlydHkgPSBbXTtcblx0XHRjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkaXJ0eVtpXSA9IC0xO1xuXHRcdH1cblx0XHRyZXR1cm4gZGlydHk7XG5cdH1cblx0cmV0dXJuIC0xO1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3QgayBpbiBwcm9wcykgaWYgKGtbMF0gIT09ICckJykgcmVzdWx0W2tdID0gcHJvcHNba107XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG5cdGNvbnN0IHJlc3QgPSB7fTtcblx0a2V5cyA9IG5ldyBTZXQoa2V5cyk7XG5cdGZvciAoY29uc3QgayBpbiBwcm9wcykgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpIHJlc3Rba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3Q7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcblx0XHRyZXN1bHRba2V5XSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHsodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuKSB7XG5cdGxldCByYW4gPSBmYWxzZTtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHJhbikgcmV0dXJuO1xuXHRcdHJhbiA9IHRydWU7XG5cdFx0Zm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBjb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG5cdHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG4vKiogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7W251bWJlciwgc3RyaW5nXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG5cdGNvbnN0IHNwbGl0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5tYXRjaCgvXlxccyooLT9bXFxkLl0rKShbXlxcc10qKVxccyokLyk7XG5cdHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZSksICdweCddO1xufVxuXG5leHBvcnQgY29uc3QgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMgPSBbJycsIHRydWUsIDEsICd0cnVlJywgJ2NvbnRlbnRlZGl0YWJsZSddO1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5leHBvcnQgY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKiBAdHlwZSB7KCkgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGxldCBub3cgPSBpc19jbGllbnQgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiAoKSA9PiBEYXRlLm5vdygpO1xuXG5leHBvcnQgbGV0IHJhZiA9IGlzX2NsaWVudCA/IChjYikgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG5cbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9ub3coZm4pIHtcblx0bm93ID0gZm47XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfcmFmKGZuKSB7XG5cdHJhZiA9IGZuO1xufVxuIiwiaW1wb3J0IHsgcmFmIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5cbmNvbnN0IHRhc2tzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3dcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG5cdHRhc2tzLmZvckVhY2goKHRhc2spID0+IHtcblx0XHRpZiAoIXRhc2suYyhub3cpKSB7XG5cdFx0XHR0YXNrcy5kZWxldGUodGFzayk7XG5cdFx0XHR0YXNrLmYoKTtcblx0XHR9XG5cdH0pO1xuXHRpZiAodGFza3Muc2l6ZSAhPT0gMCkgcmFmKHJ1bl90YXNrcyk7XG59XG5cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG5cdHRhc2tzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UYXNrQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UYXNrfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuVGFza0VudHJ5fSAqL1xuXHRsZXQgdGFzaztcblx0aWYgKHRhc2tzLnNpemUgPT09IDApIHJhZihydW5fdGFza3MpO1xuXHRyZXR1cm4ge1xuXHRcdHByb21pc2U6IG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiB7XG5cdFx0XHR0YXNrcy5hZGQoKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pKTtcblx0XHR9KSxcblx0XHRhYm9ydCgpIHtcblx0XHRcdHRhc2tzLmRlbGV0ZSh0YXNrKTtcblx0XHR9XG5cdH07XG59XG4iLCIvKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzfSAqL1xuZXhwb3J0IGNvbnN0IGdsb2JhbHMgPVxuXHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXHRcdD8gd2luZG93XG5cdFx0OiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcblx0XHQ/IGdsb2JhbFRoaXNcblx0XHQ6IC8vIEB0cy1pZ25vcmUgTm9kZSB0eXBpbmdzIGhhdmUgdGhpc1xuXHRcdCAgZ2xvYmFsO1xuIiwiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5cbi8qKlxuICogUmVzaXplIG9ic2VydmVyIHNpbmdsZXRvbi5cbiAqIE9uZSBsaXN0ZW5lciBwZXIgZWxlbWVudCBvbmx5IVxuICogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9nL2JsaW5rLWRldi9jL3o2aWVuT05VYjVBL20vRjUtVmNVWnRCQUFKXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge1dlYWtNYXA8RWxlbWVudCwgaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcj59XG5cdCAqL1xuXHRfbGlzdGVuZXJzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJ9XG5cdCAqL1xuXHRfb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9ICovXG5cdG9wdGlvbnM7XG5cblx0LyoqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJPcHRpb25zfSBvcHRpb25zICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuTGlzdGVuZXJ9IGxpc3RlbmVyXG5cdCAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0b2JzZXJ2ZShlbGVtZW50LCBsaXN0ZW5lcikge1xuXHRcdHRoaXMuX2xpc3RlbmVycy5zZXQoZWxlbWVudCwgbGlzdGVuZXIpO1xuXHRcdHRoaXMuX2dldE9ic2VydmVyKCkub2JzZXJ2ZShlbGVtZW50LCB0aGlzLm9wdGlvbnMpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpOyAvLyB0aGlzIGxpbmUgY2FuIHByb2JhYmx5IGJlIHJlbW92ZWRcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0T2JzZXJ2ZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuX29ic2VydmVyID8/XG5cdFx0XHQodGhpcy5fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcblx0XHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG5cdFx0XHRcdFx0UmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcy5zZXQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XG5cdFx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzLmdldChlbnRyeS50YXJnZXQpPy4oZW50cnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSlcblx0XHQpO1xuXHR9XG59XG5cbi8vIE5lZWRzIHRvIGJlIHdyaXR0ZW4gbGlrZSB0aGlzIHRvIHBhc3MgdGhlIHRyZWUtc2hha2UtdGVzdFxuUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLCBoYXNfcHJvcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uanMnO1xuXG4vLyBUcmFjayB3aGljaCBub2RlcyBhcmUgY2xhaW1lZCBkdXJpbmcgaHlkcmF0aW9uLiBVbmNsYWltZWQgbm9kZXMgY2FuIHRoZW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbi8vIGF0IHRoZSBlbmQgb2YgaHlkcmF0aW9uIHdpdGhvdXQgdG91Y2hpbmcgdGhlIHJlbWFpbmluZyBub2Rlcy5cbmxldCBpc19oeWRyYXRpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0X2h5ZHJhdGluZygpIHtcblx0aXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG5cdGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcGFyYW0geyhpbmRleDogbnVtYmVyKSA9PiBudW1iZXJ9IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcblx0Ly8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuXHR3aGlsZSAobG93IDwgaGlnaCkge1xuXHRcdGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG5cdFx0aWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG5cdFx0XHRsb3cgPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWdoID0gbWlkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbG93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbml0X2h5ZHJhdGUodGFyZ2V0KSB7XG5cdGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KSByZXR1cm47XG5cdHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuXHQvLyBXZSBrbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgY2xhaW1fb3JkZXIgdmFsdWVzIHNpbmNlIHRoZSB1bmNsYWltZWQgaGF2ZSBiZWVuIGRldGFjaGVkIGlmIHRhcmdldCBpcyBub3QgPGhlYWQ+XG5cblx0bGV0IGNoaWxkcmVuID0gLyoqIEB0eXBlIHtBcnJheUxpa2U8Tm9kZUV4Mj59ICovICh0YXJnZXQuY2hpbGROb2Rlcyk7XG5cdC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG5cdGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuXHRcdGNvbnN0IG15X2NoaWxkcmVuID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRteV9jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjaGlsZHJlbiA9IG15X2NoaWxkcmVuO1xuXHR9XG5cdC8qXG5cdCAqIFJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkuXG5cdCAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2Zcblx0ICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3Rcblx0ICogc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgdGhhdCBhcmUgY2xhaW1lZCBpbiBvcmRlciBjYW4gYmUgZm91bmQgYnlcblx0ICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cblx0ICpcblx0ICogVGhpcyBhbGdvcml0aG0gaXMgb3B0aW1hbCBpbiBnZW5lcmF0aW5nIHRoZSBsZWFzdCBhbW91bnQgb2YgcmVvcmRlciBvcGVyYXRpb25zXG5cdCAqIHBvc3NpYmxlLlxuXHQgKlxuXHQgKiBQcm9vZjpcblx0ICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG5cdCAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuXHQgKiBtZWFuaW5nIHRoYXQgdGhleSBtdXN0IGJlIGFscmVhZHkgb3JkZXJlZCBhbW9uZyBlYWNoIG90aGVyLiBUaHVzLCB0aGUgbWF4aW1hbFxuXHQgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuXHQgKi9cblx0Ly8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Vcblx0Ly8gbTogc3Vic2VxdWVuY2UgbGVuZ3RoIGogPT4gaW5kZXggayBvZiBzbWFsbGVzdCB2YWx1ZSB0aGF0IGVuZHMgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggalxuXHRjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG5cdC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG5cdGNvbnN0IHAgPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGgpO1xuXHRtWzBdID0gLTE7XG5cdGxldCBsb25nZXN0ID0gMDtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcblx0XHQvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuXHRcdC8vIHVwcGVyX2JvdW5kIHJldHVybnMgZmlyc3QgZ3JlYXRlciB2YWx1ZSwgc28gd2Ugc3VidHJhY3Qgb25lXG5cdFx0Ly8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2Vcblx0XHRjb25zdCBzZXFfbGVuID1cblx0XHRcdChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50XG5cdFx0XHRcdD8gbG9uZ2VzdCArIDFcblx0XHRcdFx0OiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCAoaWR4KSA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuXHRcdHBbaV0gPSBtW3NlcV9sZW5dICsgMTtcblx0XHRjb25zdCBuZXdfbGVuID0gc2VxX2xlbiArIDE7XG5cdFx0Ly8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuXHRcdG1bbmV3X2xlbl0gPSBpO1xuXHRcdGxvbmdlc3QgPSBNYXRoLm1heChuZXdfbGVuLCBsb25nZXN0KTtcblx0fVxuXHQvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtOb2RlRXgyW119XG5cdCAqL1xuXHRjb25zdCBsaXMgPSBbXTtcblx0Ly8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcblxuXHQvKipcblx0ICogQHR5cGUge05vZGVFeDJbXX1cblx0ICovXG5cdGNvbnN0IHRvX21vdmUgPSBbXTtcblx0bGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuXHRmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcblx0XHRsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG5cdFx0Zm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcblx0XHRcdHRvX21vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdFx0fVxuXHRcdGxhc3QtLTtcblx0fVxuXHRmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcblx0XHR0b19tb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuXHR9XG5cdGxpcy5yZXZlcnNlKCk7XG5cdC8vIFdlIHNvcnQgdGhlIG5vZGVzIGJlaW5nIG1vdmVkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZWlyIGluc2VydGlvbiBvcmRlciBtYXRjaGVzIHRoZSBjbGFpbSBvcmRlclxuXHR0b19tb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcblx0Ly8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcblx0Zm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9fbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b19tb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuXHRcdFx0aisrO1xuXHRcdH1cblx0XHRjb25zdCBhbmNob3IgPSBqIDwgbGlzLmxlbmd0aCA/IGxpc1tqXSA6IG51bGw7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0b19tb3ZlW2ldLCBhbmNob3IpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG5cdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlX3NoZWV0X2lkXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG5cdGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcblx0aWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuXHRcdGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcblx0XHRzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuXHRcdHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuXHRcdGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge1NoYWRvd1Jvb3QgfCBEb2N1bWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG5cdGlmICghbm9kZSkgcmV0dXJuIGRvY3VtZW50O1xuXHRjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcblx0aWYgKHJvb3QgJiYgLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KTtcblx0fVxuXHRyZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge0NTU1N0eWxlU2hlZXR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG5cdGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuXHQvLyBGb3IgdHJhbnNpdGlvbnMgdG8gd29yayB3aXRob3V0ICdzdHlsZS1zcmM6IHVuc2FmZS1pbmxpbmUnIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LFxuXHQvLyB0aGVzZSBlbXB0eSB0YWdzIG5lZWQgdG8gYmUgYWxsb3dlZCB3aXRoIGEgaGFzaCBhcyBhIHdvcmthcm91bmQgdW50aWwgd2UgbW92ZSB0byB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLlxuXHQvLyBVc2luZyB0aGUgaGFzaCBmb3IgdGhlIGVtcHR5IHN0cmluZyAoZm9yIGFuIGVtcHR5IHRhZykgd29ya3MgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBTYWZhcmkuXG5cdC8vIFNvIGFzIGEgd29ya2Fyb3VuZCBmb3IgdGhlIHdvcmthcm91bmQsIHdoZW4gd2UgYXBwZW5kIGVtcHR5IHN0eWxlIHRhZ3Mgd2Ugc2V0IHRoZWlyIGNvbnRlbnQgdG8gLyogZW1wdHkgKi8uXG5cdC8vIFRoZSBoYXNoICdzaGEyNTYtOU9sTk8wRE5FZWFWekhMNFJad0NMc0JIQThXQlE4dG9CcC80RjVYVjJuYz0nIHdpbGwgdGhlbiB3b3JrIGV2ZW4gaW4gU2FmYXJpLlxuXHRzdHlsZV9lbGVtZW50LnRleHRDb250ZW50ID0gJy8qIGVtcHR5ICovJztcblx0YXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaGFkb3dSb290IHwgRG9jdW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm5zIHtDU1NTdHlsZVNoZWV0fVxuICovXG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuXHRhcHBlbmQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKG5vZGUpLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xuXHRyZXR1cm4gc3R5bGUuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlRXh9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcblx0aWYgKGlzX2h5ZHJhdGluZykge1xuXHRcdGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuXHRcdGlmIChcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpXG5cdFx0KSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuXHRcdH1cblx0XHQvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuXHRcdHdoaWxlICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0XHRpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcblx0XHRcdC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG5cdFx0XHRpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVFeH0gbm9kZVxuICogQHBhcmFtIHtOb2RlRXh9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0aWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG5cdFx0YXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcblx0aWYgKG5vZGUucGFyZW50Tm9kZSkge1xuXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGl0ZXJhdGlvbnNbaV0pIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50VGFnTmFtZU1hcFtLXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbS119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgVH0gS1xuICogQHBhcmFtIHtUfSBvYmpcbiAqIEBwYXJhbSB7S1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG5cdGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn0gKi8gKHt9KTtcblx0Zm9yIChjb25zdCBrIGluIG9iaikge1xuXHRcdGlmIChcblx0XHRcdGhhc19wcm9wKG9iaiwgaykgJiZcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHRhcmdldFtrXSA9IG9ialtrXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQoZGF0YSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gc3BhY2UoKSB7XG5cdHJldHVybiB0ZXh0KCcgJyk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoKSB7XG5cdHJldHVybiB0ZXh0KCcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KGNvbnRlbnQpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblx0cmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LmlzVHJ1c3RlZCkgZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKSBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbi8qKlxuICogTGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBzZXQgdGhyb3VnaCB0aGUgYXR0ciBtZXRob2QsXG4gKiBiZWNhdXNlIHVwZGF0aW5nIHRoZW0gdGhyb3VnaCB0aGUgcHJvcGVydHkgc2V0dGVyIGRvZXNuJ3Qgd29yayByZWxpYWJseS5cbiAqIEluIHRoZSBleGFtcGxlIG9mIGB3aWR0aGAvYGhlaWdodGAsIHRoZSBwcm9ibGVtIGlzIHRoYXQgdGhlIHNldHRlciBvbmx5XG4gKiBhY2NlcHRzIG51bWVyaWMgdmFsdWVzLCBidXQgdGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBzZXQgdG8gYSBzdHJpbmcgbGlrZSBgNTAlYC5cbiAqIElmIHRoaXMgbGlzdCBiZWNvbWVzIHRvbyBiaWcsIHJldGhpbmsgdGhpcyBhcHByb2FjaC5cbiAqL1xuY29uc3QgYWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHt7IFt4OiBzdHJpbmddOiBzdHJpbmcgfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcblx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcblx0XHRcdG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG5cdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKG5vZGUpLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldICYmXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldLnNldCAmJlxuXHRcdFx0YWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUuaW5kZXhPZihrZXkpID09PSAtMVxuXHRcdCkge1xuXHRcdFx0bm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7eyBbeDogc3RyaW5nXTogc3RyaW5nIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gZGF0YV9tYXBcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwKG5vZGUsIGRhdGFfbWFwKSB7XG5cdE9iamVjdC5rZXlzKGRhdGFfbWFwKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBrZXksIGRhdGFfbWFwW2tleV0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHRjb25zdCBsb3dlciA9IHByb3AudG9Mb3dlckNhc2UoKTsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgYmVoYXZpb3Igd2UgZG8gbG93ZXJjYXNlIGZpcnN0XG5cdGlmIChsb3dlciBpbiBub2RlKSB7XG5cdFx0bm9kZVtsb3dlcl0gPSB0eXBlb2Ygbm9kZVtsb3dlcl0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG5cdH0gZWxzZSBpZiAocHJvcCBpbiBub2RlKSB7XG5cdFx0bm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhKHRhZykge1xuXHRyZXR1cm4gLy0vLnRlc3QodGFnKSA/IHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCA6IHNldF9hdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N2ZWx0ZV9kYXRhc2V0KG5vZGUpIHtcblx0cmV0dXJuIG5vZGUuZGF0YXNldC5zdmVsdGVIO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt1bmtub3duW119ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcblx0Y29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoZ3JvdXBbaV0uY2hlY2tlZCkgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuXHR9XG5cdGlmICghY2hlY2tlZCkge1xuXHRcdHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcblx0fVxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50W119IGdyb3VwXG4gKiBAcmV0dXJucyB7eyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcigpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblx0cmV0dXJuIHtcblx0XHQvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG5cdFx0XHRfaW5wdXRzID0gaW5wdXRzO1xuXHRcdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZ3JvdXAucHVzaChpbnB1dCkpO1xuXHRcdH0sXG5cdFx0LyogcmVtb3ZlICovIHIoKSB7XG5cdFx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBncm91cC5zcGxpY2UoZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlc1xuICogQHJldHVybnMge3sgdShuZXdfaW5kZXhlczogbnVtYmVyW10pOiB2b2lkOyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcjogKCkgPT4gdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljKGdyb3VwLCBpbmRleGVzKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblxuXHRmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cChncm91cCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z3JvdXAgPSBncm91cFtpbmRleGVzW2ldXSA9IGdyb3VwW2luZGV4ZXNbaV1dIHx8IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gZ3JvdXA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHB1c2goKSB7XG5cdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gX2dyb3VwLnB1c2goaW5wdXQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IF9ncm91cC5zcGxpY2UoX2dyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHQvKiB1cGRhdGUgKi8gdShuZXdfaW5kZXhlcykge1xuXHRcdFx0aW5kZXhlcyA9IG5ld19pbmRleGVzO1xuXHRcdFx0Y29uc3QgbmV3X2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXHRcdFx0aWYgKG5ld19ncm91cCAhPT0gX2dyb3VwKSB7XG5cdFx0XHRcdHJlbW92ZSgpO1xuXHRcdFx0XHRfZ3JvdXAgPSBuZXdfZ3JvdXA7XG5cdFx0XHRcdHB1c2goKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcblx0XHRcdF9pbnB1dHMgPSBpbnB1dHM7XG5cdFx0XHRwdXNoKCk7XG5cdFx0fSxcblx0XHQvKiByZW1vdmUgKi8gcjogcmVtb3ZlXG5cdH07XG59XG5cbi8qKiBAcmV0dXJucyB7bnVtYmVyfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcblx0Y29uc3QgYXJyYXkgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuXHR9XG5cdHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcblx0cmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuXHRpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtDaGlsZE5vZGVFeH0gUlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7KG5vZGU6IENoaWxkTm9kZUV4KSA9PiBub2RlIGlzIFJ9IHByZWRpY2F0ZVxuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IENoaWxkTm9kZUV4IHwgdW5kZWZpbmVkfSBwcm9jZXNzX25vZGVcbiAqIEBwYXJhbSB7KCkgPT4gUn0gY3JlYXRlX25vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udF91cGRhdGVfbGFzdF9pbmRleFxuICogQHJldHVybnMge1J9XG4gKi9cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc19ub2RlLCBjcmVhdGVfbm9kZSwgZG9udF91cGRhdGVfbGFzdF9pbmRleCA9IGZhbHNlKSB7XG5cdC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG5cdGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG5cdGNvbnN0IHJlc3VsdF9ub2RlID0gKCgpID0+IHtcblx0XHQvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzX25vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250X3VwZGF0ZV9sYXN0X2luZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG5cdFx0Ly8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG5cdFx0Zm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZiAocHJlZGljYXRlKG5vZGUpKSB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc19ub2RlKG5vZGUpO1xuXHRcdFx0XHRpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG5vZGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZG9udF91cGRhdGVfbGFzdF9pbmRleCkge1xuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG5cdFx0cmV0dXJuIGNyZWF0ZV9ub2RlKCk7XG5cdH0pKCk7XG5cdHJlc3VsdF9ub2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0cmV0dXJuIHJlc3VsdF9ub2RlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHBhcmFtIHsobmFtZTogc3RyaW5nKSA9PiBFbGVtZW50IHwgU1ZHRWxlbWVudH0gY3JlYXRlX2VsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgRWxlbWVudCB8IFNWR0VsZW1lbnR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsXG5cdFx0LyoqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRjb25zdCByZW1vdmUgPSBbXTtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcblx0XHRcdFx0aWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuXHRcdFx0XHRcdHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVtb3ZlLmZvckVhY2goKHYpID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuXHRyZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge1RleHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBUZXh0fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLFxuXHRcdC8qKiBAcGFyYW0ge1RleHR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YV9zdHIgPSAnJyArIGRhdGE7XG5cdFx0XHRpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YV9zdHIpKSB7XG5cdFx0XHRcdGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhX3N0ci5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YV9zdHIubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5kYXRhID0gZGF0YV9zdHI7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQoKSA9PiB0ZXh0KGRhdGEpLFxuXHRcdHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG5cdCk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcblx0cmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHtDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tbWVudChub2RlcywgZGF0YSkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgQ29tbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCxcblx0XHQvKiogQHBhcmFtIHtDb21tZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjb21tZW50KGRhdGEpLFxuXHRcdHRydWVcblx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0X2NvbW1lbnRfaWR4KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuXHRmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBpc19zdmdcbiAqIEByZXR1cm5zIHtIdG1sVGFnSHlkcmF0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMsIGlzX3N2Zykge1xuXHQvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcblx0Y29uc3Qgc3RhcnRfaW5kZXggPSBnZXRfY29tbWVudF9pZHgobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuXHRjb25zdCBlbmRfaW5kZXggPSBnZXRfY29tbWVudF9pZHgobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCArIDEpO1xuXHRpZiAoc3RhcnRfaW5kZXggPT09IC0xIHx8IGVuZF9pbmRleCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnKTtcblx0fVxuXG5cdGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG5cdGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuXHRkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuXHRkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuXHRjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG5cdGlmIChjbGFpbWVkX25vZGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcpO1xuXHR9XG5cdGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG5cdFx0bi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcblx0XHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0fVxuXHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnLCBjbGFpbWVkX25vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0LmRhdGEgPT09IGRhdGEpIHJldHVybjtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpIHJldHVybjtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJfdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcblx0aWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG5cdFx0c2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpO1xuXHR9IGVsc2Uge1xuXHRcdHNldF9kYXRhKHRleHQsIGRhdGEpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuXHRpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG5cdHRyeSB7XG5cdFx0aW5wdXQudHlwZSA9IHR5cGU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBkbyBub3RoaW5nXG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0bm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuXHR9IGVsc2Uge1xuXHRcdG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcblx0XHRpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXHRpZiAoIW1vdW50aW5nIHx8IHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcblx0XHRvcHRpb24uc2VsZWN0ZWQgPSB+dmFsdWUuaW5kZXhPZihvcHRpb24uX192YWx1ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcblx0Y29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG5cdHJldHVybiBzZWxlY3RlZF9vcHRpb24gJiYgc2VsZWN0ZWRfb3B0aW9uLl9fdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfdmFsdWUoc2VsZWN0KSB7XG5cdHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgKG9wdGlvbikgPT4gb3B0aW9uLl9fdmFsdWUpO1xufVxuLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbid0IGJlIGEgY29uc3RhbnQgYXMgdGhhdCB3b3VsZG4ndCBiZSB0cmVlLXNoYWtlYWJsZVxuLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBpbnN0ZWFkXG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59ICovXG5sZXQgY3Jvc3NvcmlnaW47XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG5cdGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y3Jvc3NvcmlnaW4gPSBmYWxzZTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wYXJlbnQpIHtcblx0XHRcdFx0dm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjcm9zc29yaWdpbiA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjcm9zc29yaWdpbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG5cdGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0aWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuXHRcdG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHR9XG5cdGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuXHRpZnJhbWUuc2V0QXR0cmlidXRlKFxuXHRcdCdzdHlsZScsXG5cdFx0J2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG5cdFx0XHQnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7J1xuXHQpO1xuXHRpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cdGlmcmFtZS50YWJJbmRleCA9IC0xO1xuXHRjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0bGV0IHVuc3Vic2NyaWJlO1xuXHRpZiAoY3Jvc3NvcmlnaW4pIHtcblx0XHRpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcblx0XHR1bnN1YnNjcmliZSA9IGxpc3Rlbihcblx0XHRcdHdpbmRvdyxcblx0XHRcdCdtZXNzYWdlJyxcblx0XHRcdC8qKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnQgKi8gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KSBmbigpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0aWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG5cdFx0aWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcblx0XHRcdHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGFuIGluaXRpYWwgcmVzaXplIGV2ZW50IGlzIGZpcmVkIF9hZnRlcl8gdGhlIGlmcmFtZSBpcyBsb2FkZWQgKHdoaWNoIGlzIGFzeW5jaHJvbm91cylcblx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy80MjMzXG5cdFx0XHRmbigpO1xuXHRcdH07XG5cdH1cblx0YXBwZW5kKG5vZGUsIGlmcmFtZSk7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGNyb3Nzb3JpZ2luKSB7XG5cdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdH0gZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcblx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0fVxuXHRcdGRldGFjaChpZnJhbWUpO1xuXHR9O1xufVxuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdjb250ZW50LWJveCdcbn0pO1xuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2JvcmRlci1ib3gnXG59KTtcbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbihcblx0eyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH1cbik7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB9O1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcblx0Ly8gVGhlIGAhIWAgaXMgcmVxdWlyZWQgYmVjYXVzZSBhbiBgdW5kZWZpbmVkYCBmbGFnIG1lYW5zIGZsaXBwaW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuXHRlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUobmFtZSwgISF0b2dnbGUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtUfSBbZGV0YWlsXVxuICogQHBhcmFtIHt7IGJ1YmJsZXM/OiBib29sZWFuLCBjYW5jZWxhYmxlPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtDdXN0b21FdmVudDxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG5cdHJldHVybiBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlSWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGhlYWRcbiAqIEByZXR1cm5zIHthbnlbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlYWRfc2VsZWN0b3Iobm9kZUlkLCBoZWFkKSB7XG5cdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRsZXQgc3RhcnRlZCA9IDA7XG5cdGZvciAoY29uc3Qgbm9kZSBvZiBoZWFkLmNoaWxkTm9kZXMpIHtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8pIHtcblx0XHRcdGNvbnN0IGNvbW1lbnQgPSBub2RlLnRleHRDb250ZW50LnRyaW0oKTtcblx0XHRcdGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fRU5EYCkge1xuXHRcdFx0XHRzdGFydGVkIC09IDE7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fU1RBUlRgKSB7XG5cdFx0XHRcdHN0YXJ0ZWQgKz0gMTtcblx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzdGFydGVkID4gMCkge1xuXHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG4vKiogKi9cbmV4cG9ydCBjbGFzcyBIdG1sVGFnIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHRpc19zdmcgPSBmYWxzZTtcblx0LyoqIHBhcmVudCBmb3IgY3JlYXRpbmcgbm9kZSAqL1xuXHRlID0gdW5kZWZpbmVkO1xuXHQvKiogaHRtbCB0YWcgbm9kZXMgKi9cblx0biA9IHVuZGVmaW5lZDtcblx0LyoqIHRhcmdldCAqL1xuXHR0ID0gdW5kZWZpbmVkO1xuXHQvKiogYW5jaG9yICovXG5cdGEgPSB1bmRlZmluZWQ7XG5cdGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG5cdFx0dGhpcy5pc19zdmcgPSBpc19zdmc7XG5cdFx0dGhpcy5lID0gdGhpcy5uID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGMoaHRtbCkge1xuXHRcdHRoaXMuaChodG1sKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSBhbmNob3Jcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuXHRcdGlmICghdGhpcy5lKSB7XG5cdFx0XHRpZiAodGhpcy5pc19zdmcpXG5cdFx0XHRcdHRoaXMuZSA9IHN2Z19lbGVtZW50KC8qKiBAdHlwZSB7a2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXB9ICovICh0YXJnZXQubm9kZU5hbWUpKTtcblx0XHRcdC8qKiAjNzM2NCAgdGFyZ2V0IGZvciA8dGVtcGxhdGU+IG1heSBiZSBwcm92aWRlZCBhcyAjZG9jdW1lbnQtZnJhZ21lbnQoMTEpICovIGVsc2Vcblx0XHRcdFx0dGhpcy5lID0gZWxlbWVudChcblx0XHRcdFx0XHQvKiogQHR5cGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gKi8gKFxuXHRcdFx0XHRcdFx0dGFyZ2V0Lm5vZGVUeXBlID09PSAxMSA/ICdURU1QTEFURScgOiB0YXJnZXQubm9kZU5hbWVcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cdFx0XHR0aGlzLnQgPVxuXHRcdFx0XHR0YXJnZXQudGFnTmFtZSAhPT0gJ1RFTVBMQVRFJ1xuXHRcdFx0XHRcdD8gdGFyZ2V0XG5cdFx0XHRcdFx0OiAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovICh0YXJnZXQpLmNvbnRlbnQ7XG5cdFx0XHR0aGlzLmMoaHRtbCk7XG5cdFx0fVxuXHRcdHRoaXMuaShhbmNob3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0aChodG1sKSB7XG5cdFx0dGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0dGhpcy5uID0gQXJyYXkuZnJvbShcblx0XHRcdHRoaXMuZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJyA/IHRoaXMuZS5jb250ZW50LmNoaWxkTm9kZXMgOiB0aGlzLmUuY2hpbGROb2Rlc1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGkoYW5jaG9yKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRwKGh0bWwpIHtcblx0XHR0aGlzLmQoKTtcblx0XHR0aGlzLmgoaHRtbCk7XG5cdFx0dGhpcy5pKHRoaXMuYSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGQoKSB7XG5cdFx0dGhpcy5uLmZvckVhY2goZGV0YWNoKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuXHQvKiogQHR5cGUge0VsZW1lbnRbXX0gaHlkcmF0aW9uIGNsYWltZWQgbm9kZXMgKi9cblx0bCA9IHVuZGVmaW5lZDtcblxuXHRjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSwgY2xhaW1lZF9ub2Rlcykge1xuXHRcdHN1cGVyKGlzX3N2Zyk7XG5cdFx0dGhpcy5lID0gdGhpcy5uID0gbnVsbDtcblx0XHR0aGlzLmwgPSBjbGFpbWVkX25vZGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0YyhodG1sKSB7XG5cdFx0aWYgKHRoaXMubCkge1xuXHRcdFx0dGhpcy5uID0gdGhpcy5sO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdXBlci5jKGh0bWwpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0aShhbmNob3IpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aW5zZXJ0X2h5ZHJhdGlvbih0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05hbWVkTm9kZU1hcH0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG5cdFx0cmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBlc2NhcGVkID0ge1xuXHQnXCInOiAnJnF1b3Q7Jyxcblx0JyYnOiAnJmFtcDsnLFxuXHQnPCc6ICcmbHQ7J1xufTtcblxuY29uc3QgcmVnZXhfYXR0cmlidXRlX2NoYXJhY3RlcnNfdG9fZXNjYXBlID0gL1tcIiY8XS9nO1xuXG4vKipcbiAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIGl0c2VsZiBzaG91bGQgYmUgc3Vycm91bmRlZCBpbiBkb3VibGUgcXVvdGVzXG4gKiBAcGFyYW0ge2FueX0gYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG5cdHJldHVybiBTdHJpbmcoYXR0cmlidXRlKS5yZXBsYWNlKHJlZ2V4X2F0dHJpYnV0ZV9jaGFyYWN0ZXJzX3RvX2VzY2FwZSwgKG1hdGNoKSA9PiBlc2NhcGVkW21hdGNoXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBhdHRyaWJ1dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlfc3ByZWFkKGF0dHJpYnV0ZXMpIHtcblx0bGV0IHN0ciA9ICcgJztcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGlmIChhdHRyaWJ1dGVzW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0c3RyICs9IGAke2tleX09XCIke2VzY2FwZV9hdHRyaWJ1dGUoYXR0cmlidXRlc1trZXldKX1cIiBgO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovIChub2RlKSA9PiB7XG5cdFx0XHRyZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuXHRcdH1cblx0KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcblx0cmV0dXJuIG5ldyBjb21wb25lbnQocHJvcHMpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtOb2RlICYge1xuICogXHRjbGFpbV9vcmRlcj86IG51bWJlcjtcbiAqIFx0aHlkcmF0ZV9pbml0PzogdHJ1ZTtcbiAqIFx0YWN0dWFsX2VuZF9jaGlsZD86IE5vZGVFeDtcbiAqIFx0Y2hpbGROb2RlczogTm9kZUxpc3RPZjxOb2RlRXg+O1xuICogfX0gTm9kZUV4XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtDaGlsZE5vZGUgJiBOb2RlRXh9IENoaWxkTm9kZUV4ICovXG5cbi8qKiBAdHlwZWRlZiB7Tm9kZUV4ICYgeyBjbGFpbV9vcmRlcjogbnVtYmVyIH19IE5vZGVFeDIgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q2hpbGROb2RlRXhbXSAmIHtcbiAqIFx0Y2xhaW1faW5mbz86IHtcbiAqIFx0XHRsYXN0X2luZGV4OiBudW1iZXI7XG4gKiBcdFx0dG90YWxfY2xhaW1lZDogbnVtYmVyO1xuICogXHR9O1xuICogfX0gQ2hpbGROb2RlQXJyYXlcbiAqL1xuIiwiaW1wb3J0IHsgYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQsIGRldGFjaCwgZ2V0X3Jvb3RfZm9yX3N0eWxlIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgcmFmIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5cbi8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGZvciBtdWx0aXBsZSBkb2N1bWVudHMgYmVjYXVzZSBhIFN2ZWx0ZSBhcHBsaWNhdGlvbiBjb3VsZCBhbHNvIGNvbnRhaW4gaWZyYW1lc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMzYyNFxuLyoqIEB0eXBlIHtNYXA8RG9jdW1lbnQgfCBTaGFkb3dSb290LCBpbXBvcnQoJy4vcHJpdmF0ZS5kLnRzJykuU3R5bGVJbmZvcm1hdGlvbj59ICovXG5jb25zdCBtYW5hZ2VkX3N0eWxlcyA9IG5ldyBNYXAoKTtcblxubGV0IGFjdGl2ZSA9IDA7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG5cdGxldCBoYXNoID0gNTM4MTtcblx0bGV0IGkgPSBzdHIubGVuZ3RoO1xuXHR3aGlsZSAoaS0tKSBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcblx0cmV0dXJuIGhhc2ggPj4+IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEb2N1bWVudCB8IFNoYWRvd1Jvb3R9IGRvY1xuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcmV0dXJucyB7eyBzdHlsZXNoZWV0OiBhbnk7IHJ1bGVzOiB7fTsgfX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSkge1xuXHRjb25zdCBpbmZvID0geyBzdHlsZXNoZWV0OiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSwgcnVsZXM6IHt9IH07XG5cdG1hbmFnZWRfc3R5bGVzLnNldChkb2MsIGluZm8pO1xuXHRyZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXlcbiAqIEBwYXJhbSB7KHQ6IG51bWJlcikgPT4gbnVtYmVyfSBlYXNlXG4gKiBAcGFyYW0geyh0OiBudW1iZXIsIHU6IG51bWJlcikgPT4gc3RyaW5nfSBmblxuICogQHBhcmFtIHtudW1iZXJ9IHVpZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcblx0Y29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuXHRsZXQga2V5ZnJhbWVzID0gJ3tcXG4nO1xuXHRmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcblx0XHRjb25zdCB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuXHRcdGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG5cdH1cblx0Y29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG5cdGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuXHRjb25zdCBkb2MgPSBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSk7XG5cdGNvbnN0IHsgc3R5bGVzaGVldCwgcnVsZXMgfSA9IG1hbmFnZWRfc3R5bGVzLmdldChkb2MpIHx8IGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpO1xuXHRpZiAoIXJ1bGVzW25hbWVdKSB7XG5cdFx0cnVsZXNbbmFtZV0gPSB0cnVlO1xuXHRcdHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShgQGtleWZyYW1lcyAke25hbWV9ICR7cnVsZX1gLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG5cdH1cblx0Y29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG5cdG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gYCR7XG5cdFx0YW5pbWF0aW9uID8gYCR7YW5pbWF0aW9ufSwgYCA6ICcnXG5cdH0ke25hbWV9ICR7ZHVyYXRpb259bXMgbGluZWFyICR7ZGVsYXl9bXMgMSBib3RoYDtcblx0YWN0aXZlICs9IDE7XG5cdHJldHVybiBuYW1lO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG5cdGNvbnN0IHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcblx0Y29uc3QgbmV4dCA9IHByZXZpb3VzLmZpbHRlcihcblx0XHRuYW1lXG5cdFx0XHQ/IChhbmltKSA9PiBhbmltLmluZGV4T2YobmFtZSkgPCAwIC8vIHJlbW92ZSBzcGVjaWZpYyBhbmltYXRpb25cblx0XHRcdDogKGFuaW0pID0+IGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTEgLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuXHQpO1xuXHRjb25zdCBkZWxldGVkID0gcHJldmlvdXMubGVuZ3RoIC0gbmV4dC5sZW5ndGg7XG5cdGlmIChkZWxldGVkKSB7XG5cdFx0bm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG5cdFx0YWN0aXZlIC09IGRlbGV0ZWQ7XG5cdFx0aWYgKCFhY3RpdmUpIGNsZWFyX3J1bGVzKCk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyX3J1bGVzKCkge1xuXHRyYWYoKCkgPT4ge1xuXHRcdGlmIChhY3RpdmUpIHJldHVybjtcblx0XHRtYW5hZ2VkX3N0eWxlcy5mb3JFYWNoKChpbmZvKSA9PiB7XG5cdFx0XHRjb25zdCB7IG93bmVyTm9kZSB9ID0gaW5mby5zdHlsZXNoZWV0O1xuXHRcdFx0Ly8gdGhlcmUgaXMgbm8gb3duZXJOb2RlIGlmIGl0IHJ1bnMgb24ganNkb20uXG5cdFx0XHRpZiAob3duZXJOb2RlKSBkZXRhY2gob3duZXJOb2RlKTtcblx0XHR9KTtcblx0XHRtYW5hZ2VkX3N0eWxlcy5jbGVhcigpO1xuXHR9KTtcbn1cbiIsImltcG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciwgbm9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBsb29wIH0gZnJvbSAnLi9sb29wLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ydWxlLCBkZWxldGVfcnVsZSB9IGZyb20gJy4vc3R5bGVfbWFuYWdlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuUG9zaXRpb25SZWN0fSBmcm9tXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuQW5pbWF0aW9uRm59IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfYW5pbWF0aW9uKG5vZGUsIGZyb20sIGZuLCBwYXJhbXMpIHtcblx0aWYgKCFmcm9tKSByZXR1cm4gbm9vcDtcblx0Y29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRpZiAoXG5cdFx0ZnJvbS5sZWZ0ID09PSB0by5sZWZ0ICYmXG5cdFx0ZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiZcblx0XHRmcm9tLnRvcCA9PT0gdG8udG9wICYmXG5cdFx0ZnJvbS5ib3R0b20gPT09IHRvLmJvdHRvbVxuXHQpXG5cdFx0cmV0dXJuIG5vb3A7XG5cdGNvbnN0IHtcblx0XHRkZWxheSA9IDAsXG5cdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdC8vIEB0cy1pZ25vcmUgdG9kbzogc2hvdWxkIHRoaXMgYmUgc2VwYXJhdGVkIGZyb20gZGVzdHJ1Y3R1cmluZz8gT3Igc3RhcnQvZW5kIGFkZGVkIHRvIHB1YmxpYyBhcGkgYW5kIGRvY3VtZW50YXRpb24/XG5cdFx0c3RhcnQ6IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5LFxuXHRcdC8vIEB0cy1pZ25vcmUgdG9kbzpcblx0XHRlbmQgPSBzdGFydF90aW1lICsgZHVyYXRpb24sXG5cdFx0dGljayA9IG5vb3AsXG5cdFx0Y3NzXG5cdH0gPSBmbihub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyk7XG5cdGxldCBydW5uaW5nID0gdHJ1ZTtcblx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0bGV0IG5hbWU7XG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gc3RhcnQoKSB7XG5cdFx0aWYgKGNzcykge1xuXHRcdFx0bmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuXHRcdH1cblx0XHRpZiAoIWRlbGF5KSB7XG5cdFx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBzdG9wKCkge1xuXHRcdGlmIChjc3MpIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuXHRcdHJ1bm5pbmcgPSBmYWxzZTtcblx0fVxuXHRsb29wKChub3cpID0+IHtcblx0XHRpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG5cdFx0XHR0aWNrKDEsIDApO1xuXHRcdFx0c3RvcCgpO1xuXHRcdH1cblx0XHRpZiAoIXJ1bm5pbmcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHN0YXJ0ZWQpIHtcblx0XHRcdGNvbnN0IHAgPSBub3cgLSBzdGFydF90aW1lO1xuXHRcdFx0Y29uc3QgdCA9IDAgKyAxICogZWFzaW5nKHAgLyBkdXJhdGlvbik7XG5cdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pO1xuXHRzdGFydCgpO1xuXHR0aWNrKDAsIDEpO1xuXHRyZXR1cm4gc3RvcDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRpZiAoc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHN0eWxlO1xuXHRcdGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblx0XHRhZGRfdHJhbnNmb3JtKG5vZGUsIGEpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuUG9zaXRpb25SZWN0fSBhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF90cmFuc2Zvcm0obm9kZSwgYSkge1xuXHRjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0aWYgKGEubGVmdCAhPT0gYi5sZWZ0IHx8IGEudG9wICE9PSBiLnRvcCkge1xuXHRcdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHRcdG5vZGUuc3R5bGUudHJhbnNmb3JtID0gYCR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHthLmxlZnQgLSBiLmxlZnR9cHgsICR7YS50b3AgLSBiLnRvcH1weClgO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBjdXN0b21fZXZlbnQgfSBmcm9tICcuL2RvbS5qcyc7XG5cbmV4cG9ydCBsZXQgY3VycmVudF9jb21wb25lbnQ7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkge1xuXHRpZiAoIWN1cnJlbnRfY29tcG9uZW50KSB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbicpO1xuXHRyZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVwZGF0ZWQgYWZ0ZXIgYW55IHN0YXRlIGNoYW5nZS5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGJlZm9yZSB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjYmVmb3JldXBkYXRlXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG5cbi8qKlxuICogVGhlIGBvbk1vdW50YCBmdW5jdGlvbiBzY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gYXMgc29vbiBhcyB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgdG8gdGhlIERPTS5cbiAqIEl0IG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUgY29tcG9uZW50J3MgaW5pdGlhbGlzYXRpb24gKGJ1dCBkb2Vzbid0IG5lZWQgdG8gbGl2ZSAqaW5zaWRlKiB0aGUgY29tcG9uZW50O1xuICogaXQgY2FuIGJlIGNhbGxlZCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSkuXG4gKlxuICogSWYgYSBmdW5jdGlvbiBpcyByZXR1cm5lZCBfc3luY2hyb25vdXNseV8gZnJvbSBgb25Nb3VudGAsIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogYG9uTW91bnRgIGRvZXMgbm90IHJ1biBpbnNpZGUgYSBbc2VydmVyLXNpZGUgY29tcG9uZW50XShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zZXJ2ZXItc2lkZS1jb21wb25lbnQtYXBpKS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjb25tb3VudFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Ob3RGdW5jdGlvbjxUPiB8IFByb21pc2U8aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Ob3RGdW5jdGlvbjxUPj4gfCAoKCkgPT4gYW55KX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Nb3VudChmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2FmdGVydXBkYXRlXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogT3V0IG9mIGBvbk1vdW50YCwgYGJlZm9yZVVwZGF0ZWAsIGBhZnRlclVwZGF0ZWAgYW5kIGBvbkRlc3Ryb3lgLCB0aGlzIGlzIHRoZVxuICogb25seSBvbmUgdGhhdCBydW5zIGluc2lkZSBhIHNlcnZlci1zaWRlIGNvbXBvbmVudC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjb25kZXN0cm95XG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3RlbXBsYXRlLXN5bnRheC1jb21wb25lbnQtZGlyZWN0aXZlcy1vbi1ldmVudG5hbWUpLlxuICogRXZlbnQgZGlzcGF0Y2hlcnMgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiB0YWtlIHR3byBhcmd1bWVudHM6IGBuYW1lYCBhbmQgYGRldGFpbGAuXG4gKlxuICogQ29tcG9uZW50IGV2ZW50cyBjcmVhdGVkIHdpdGggYGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcmAgY3JlYXRlIGFcbiAqIFtDdXN0b21FdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KS5cbiAqIFRoZXNlIGV2ZW50cyBkbyBub3QgW2J1YmJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0J1aWxkaW5nX2Jsb2Nrcy9FdmVudHMjRXZlbnRfYnViYmxpbmdfYW5kX2NhcHR1cmUpLlxuICogVGhlIGBkZXRhaWxgIGFyZ3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBbQ3VzdG9tRXZlbnQuZGV0YWlsXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvZGV0YWlsKVxuICogcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFueSB0eXBlIG9mIGRhdGEuXG4gKlxuICogVGhlIGV2ZW50IGRpc3BhdGNoZXIgY2FuIGJlIHR5cGVkIHRvIG5hcnJvdyB0aGUgYWxsb3dlZCBldmVudCBuYW1lcyBhbmQgdGhlIHR5cGUgb2YgdGhlIGBkZXRhaWxgIGFyZ3VtZW50OlxuICogYGBgdHNcbiAqIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyPHtcbiAqICBsb2FkZWQ6IG5ldmVyOyAvLyBkb2VzIG5vdCB0YWtlIGEgZGV0YWlsIGFyZ3VtZW50XG4gKiAgY2hhbmdlOiBzdHJpbmc7IC8vIHRha2VzIGEgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nLCB3aGljaCBpcyByZXF1aXJlZFxuICogIG9wdGlvbmFsOiBudW1iZXIgfCBudWxsOyAvLyB0YWtlcyBhbiBvcHRpb25hbCBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBudW1iZXJcbiAqIH0+KCk7XG4gKiBgYGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjY3JlYXRlZXZlbnRkaXNwYXRjaGVyXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudE1hcD1hbnldXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkV2ZW50RGlzcGF0Y2hlcjxFdmVudE1hcD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG5cdGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuXHRyZXR1cm4gKHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG5cdFx0Y29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcblx0XHRpZiAoY2FsbGJhY2tzKSB7XG5cdFx0XHQvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG5cdFx0XHQvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG5cdFx0XHRjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcblx0XHRcdGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goKGZuKSA9PiB7XG5cdFx0XHRcdGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5cbi8qKlxuICogQXNzb2NpYXRlcyBhbiBhcmJpdHJhcnkgYGNvbnRleHRgIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGNvbXBvbmVudCBhbmQgdGhlIHNwZWNpZmllZCBga2V5YFxuICogYW5kIHJldHVybnMgdGhhdCBvYmplY3QuIFRoZSBjb250ZXh0IGlzIHRoZW4gYXZhaWxhYmxlIHRvIGNoaWxkcmVuIG9mIHRoZSBjb21wb25lbnRcbiAqIChpbmNsdWRpbmcgc2xvdHRlZCBjb250ZW50KSB3aXRoIGBnZXRDb250ZXh0YC5cbiAqXG4gKiBMaWtlIGxpZmVjeWNsZSBmdW5jdGlvbnMsIHRoaXMgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjc2V0Y29udGV4dFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEBwYXJhbSB7VH0gY29udGV4dFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGNvbnRleHQgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGBrZXlgLlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjZ2V0Y29udGV4dFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjZ2V0YWxsY29udGV4dHNcbiAqIEB0ZW1wbGF0ZSB7TWFwPGFueSwgYW55Pn0gW1Q9TWFwPGFueSwgYW55Pl1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0O1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2hhc2NvbnRleHRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG5cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG4vKipcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEBwYXJhbSBldmVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuXHRjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuXHRpZiAoY2FsbGJhY2tzKSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goKGZuKSA9PiBmbi5jYWxsKHRoaXMsIGV2ZW50KSk7XG5cdH1cbn1cbiIsImltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBkaXJ0eV9jb21wb25lbnRzID0gW107XG5leHBvcnQgY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuZXhwb3J0IGNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5cbmxldCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5cbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuXG5jb25zdCByZXNvbHZlZF9wcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xuXG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuXHRpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcblx0XHR1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcblx0XHRyZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aWNrKCkge1xuXHRzY2hlZHVsZV91cGRhdGUoKTtcblx0cmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG5cdHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcblx0Zmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuXG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xuXG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaCgpIHtcblx0Ly8gRG8gbm90IHJlZW50ZXIgZmx1c2ggd2hpbGUgZGlydHkgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgYXMgdGhpcyBjYW5cblx0Ly8gcmVzdWx0IGluIGFuIGluZmluaXRlIGxvb3AuIEluc3RlYWQsIGxldCB0aGUgaW5uZXIgZmx1c2ggaGFuZGxlIGl0LlxuXHQvLyBSZWVudHJhbmN5IGlzIG9rIGFmdGVyd2FyZHMgZm9yIGJpbmRpbmdzIGV0Yy5cblx0aWYgKGZsdXNoaWR4ICE9PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRkbyB7XG5cdFx0Ly8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuXHRcdC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuXHRcdHRyeSB7XG5cdFx0XHR3aGlsZSAoZmx1c2hpZHggPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcblx0XHRcdFx0Zmx1c2hpZHgrKztcblx0XHRcdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG5cdFx0XHRcdHVwZGF0ZShjb21wb25lbnQuJCQpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIHJlc2V0IGRpcnR5IHN0YXRlIHRvIG5vdCBlbmQgdXAgaW4gYSBkZWFkbG9ja2VkIHN0YXRlIGFuZCB0aGVuIHJldGhyb3dcblx0XHRcdGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcblx0XHRcdGZsdXNoaWR4ID0gMDtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcblx0XHRkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG5cdFx0Zmx1c2hpZHggPSAwO1xuXHRcdHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG5cdFx0Ly8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG5cdFx0Ly8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuXHRcdC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuXHRcdFx0aWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG5cdFx0XHRcdC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0c2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuXHR9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG5cdHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0Zmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG5cdH1cblx0dXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuXHRzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuXHRzZXRfY3VycmVudF9jb21wb25lbnQoc2F2ZWRfY29tcG9uZW50KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG5cdGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuXHRcdCQkLnVwZGF0ZSgpO1xuXHRcdHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG5cdFx0Y29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcblx0XHQkJC5kaXJ0eSA9IFstMV07XG5cdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcblx0XHQkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcblx0fVxufVxuXG4vKipcbiAqIFVzZWZ1bCBmb3IgZXhhbXBsZSB0byBleGVjdXRlIHJlbWFpbmluZyBgYWZ0ZXJVcGRhdGVgIGNhbGxiYWNrcyBiZWZvcmUgZXhlY3V0aW5nIGBkZXN0cm95YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZm5zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoZm5zKSB7XG5cdGNvbnN0IGZpbHRlcmVkID0gW107XG5cdGNvbnN0IHRhcmdldHMgPSBbXTtcblx0cmVuZGVyX2NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiAoZm5zLmluZGV4T2YoYykgPT09IC0xID8gZmlsdGVyZWQucHVzaChjKSA6IHRhcmdldHMucHVzaChjKSkpO1xuXHR0YXJnZXRzLmZvckVhY2goKGMpID0+IGMoKSk7XG5cdHJlbmRlcl9jYWxsYmFja3MgPSBmaWx0ZXJlZDtcbn1cbiIsImltcG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciwgaXNfZnVuY3Rpb24sIG5vb3AsIHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IG5vdyB9IGZyb20gJy4vZW52aXJvbm1lbnQuanMnO1xuaW1wb3J0IHsgbG9vcCB9IGZyb20gJy4vbG9vcC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfcnVsZSwgZGVsZXRlX3J1bGUgfSBmcm9tICcuL3N0eWxlX21hbmFnZXIuanMnO1xuaW1wb3J0IHsgY3VzdG9tX2V2ZW50IH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgYWRkX3JlbmRlcl9jYWxsYmFjayB9IGZyb20gJy4vc2NoZWR1bGVyLmpzJztcblxuLyoqXG4gKiBAdHlwZSB7UHJvbWlzZTx2b2lkPiB8IG51bGx9XG4gKi9cbmxldCBwcm9taXNlO1xuXG4vKipcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5mdW5jdGlvbiB3YWl0KCkge1xuXHRpZiAoIXByb21pc2UpIHtcblx0XHRwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0cHJvbWlzZS50aGVuKCgpID0+IHtcblx0XHRcdHByb21pc2UgPSBudWxsO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBwcm9taXNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtJTlRSTyB8IE9VVFJPIHwgYm9vbGVhbn0gZGlyZWN0aW9uXG4gKiBAcGFyYW0geydzdGFydCcgfCAnZW5kJ30ga2luZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuXHRub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEB0eXBlIHtPdXRyb31cbiAqL1xubGV0IG91dHJvcztcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG5cdG91dHJvcyA9IHtcblx0XHRyOiAwLFxuXHRcdGM6IFtdLFxuXHRcdHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG5cdGlmICghb3V0cm9zLnIpIHtcblx0XHRydW5fYWxsKG91dHJvcy5jKTtcblx0fVxuXHRvdXRyb3MgPSBvdXRyb3MucDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuRnJhZ21lbnR9IGJsb2NrXG4gKiBAcGFyYW0gezAgfCAxfSBbbG9jYWxdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG5cdGlmIChibG9jayAmJiBibG9jay5pKSB7XG5cdFx0b3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcblx0XHRibG9jay5pKGxvY2FsKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5GcmFnbWVudH0gYmxvY2tcbiAqIEBwYXJhbSB7MCB8IDF9IGxvY2FsXG4gKiBAcGFyYW0gezAgfCAxfSBbZGV0YWNoXVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuXHRpZiAoYmxvY2sgJiYgYmxvY2subykge1xuXHRcdGlmIChvdXRyb2luZy5oYXMoYmxvY2spKSByZXR1cm47XG5cdFx0b3V0cm9pbmcuYWRkKGJsb2NrKTtcblx0XHRvdXRyb3MuYy5wdXNoKCgpID0+IHtcblx0XHRcdG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKGRldGFjaCkgYmxvY2suZCgxKTtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRibG9jay5vKGxvY2FsKTtcblx0fSBlbHNlIGlmIChjYWxsYmFjaykge1xuXHRcdGNhbGxiYWNrKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuLi90cmFuc2l0aW9uL3B1YmxpYy5qcycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHJldHVybnMge3sgc3RhcnQoKTogdm9pZDsgaW52YWxpZGF0ZSgpOiB2b2lkOyBlbmQoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnaW4nIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgcnVubmluZyA9IGZhbHNlO1xuXHRsZXQgYW5pbWF0aW9uX25hbWU7XG5cdGxldCB0YXNrO1xuXHRsZXQgdWlkID0gMDtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGdvKCkge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblx0XHRpZiAoY3NzKSBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcblx0XHR0aWNrKDAsIDEpO1xuXHRcdGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuXHRcdGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuXHRcdGlmICh0YXNrKSB0YXNrLmFib3J0KCk7XG5cdFx0cnVubmluZyA9IHRydWU7XG5cdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG5cdFx0dGFzayA9IGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKG5vdyA+PSBlbmRfdGltZSkge1xuXHRcdFx0XHRcdHRpY2soMSwgMCk7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuXHRcdFx0XHRcdGNsZWFudXAoKTtcblx0XHRcdFx0XHRyZXR1cm4gKHJ1bm5pbmcgPSBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG5cdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBydW5uaW5nO1xuXHRcdH0pO1xuXHR9XG5cdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdHJldHVybiB7XG5cdFx0c3RhcnQoKSB7XG5cdFx0XHRpZiAoc3RhcnRlZCkgcmV0dXJuO1xuXHRcdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0XHRkZWxldGVfcnVsZShub2RlKTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcblx0XHRcdFx0d2FpdCgpLnRoZW4oZ28pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z28oKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGludmFsaWRhdGUoKSB7XG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fSxcblx0XHRlbmQoKSB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRcdHJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEByZXR1cm5zIHt7IGVuZChyZXNldDogYW55KTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG5cdC8qKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ291dCcgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCBydW5uaW5nID0gdHJ1ZTtcblx0bGV0IGFuaW1hdGlvbl9uYW1lO1xuXHRjb25zdCBncm91cCA9IG91dHJvcztcblx0Z3JvdXAuciArPSAxO1xuXHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdGxldCBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGdvKCkge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblxuXHRcdGlmIChjc3MpIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG5cblx0XHRjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcblx0XHRjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcblx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG5cblx0XHRpZiAoJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRvcmlnaW5hbF9pbmVydF92YWx1ZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS5pbmVydDtcblx0XHRcdG5vZGUuaW5lcnQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKG5vdyA+PSBlbmRfdGltZSkge1xuXHRcdFx0XHRcdHRpY2soMCwgMSk7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcblx0XHRcdFx0XHRpZiAoIS0tZ3JvdXAucikge1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcblx0XHRcdFx0XHRcdC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuXHRcdFx0XHRcdFx0cnVuX2FsbChncm91cC5jKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuXHRcdFx0XHRcdGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuXHRcdFx0XHRcdHRpY2soMSAtIHQsIHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnVubmluZztcblx0XHR9KTtcblx0fVxuXG5cdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0d2FpdCgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuXHRcdFx0Z28oKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRnbygpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRlbmQocmVzZXQpIHtcblx0XHRcdGlmIChyZXNldCAmJiAnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdFx0bm9kZS5pbmVydCA9IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG5cdFx0XHRcdGNvbmZpZy50aWNrKDEsIDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdFx0XHRcdHJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50cm9cbiAqIEByZXR1cm5zIHt7IHJ1bihiOiAwIHwgMSk6IHZvaWQ7IGVuZCgpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuXHQvKipcblx0ICogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdib3RoJyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UHJvZ3JhbSB8IG51bGx9ICovXG5cdGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UGVuZGluZ1Byb2dyYW0gfCBudWxsfSAqL1xuXHRsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0bGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcblxuXHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdGxldCBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcblx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BlbmRpbmdQcm9ncmFtfSBwcm9ncmFtXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuXHQgKiBAcmV0dXJucyB7UHJvZ3JhbX1cblx0ICovXG5cdGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcblx0XHRjb25zdCBkID0gLyoqIEB0eXBlIHtQcm9ncmFtWydkJ119ICovIChwcm9ncmFtLmIgLSB0KTtcblx0XHRkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YTogdCxcblx0XHRcdGI6IHByb2dyYW0uYixcblx0XHRcdGQsXG5cdFx0XHRkdXJhdGlvbixcblx0XHRcdHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuXHRcdFx0ZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG5cdFx0XHRncm91cDogcHJvZ3JhbS5ncm91cFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJTlRSTyB8IE9VVFJPfSBiXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ28oYikge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtQZW5kaW5nUHJvZ3JhbX0gKi9cblx0XHRjb25zdCBwcm9ncmFtID0ge1xuXHRcdFx0c3RhcnQ6IG5vdygpICsgZGVsYXksXG5cdFx0XHRiXG5cdFx0fTtcblxuXHRcdGlmICghYikge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3Ncblx0XHRcdHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG5cdFx0XHRvdXRyb3MuciArPSAxO1xuXHRcdH1cblxuXHRcdGlmICgnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdGlmIChiKSB7XG5cdFx0XHRcdGlmIChvcmlnaW5hbF9pbmVydF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gYWJvcnRlZC9yZXZlcnNlZCBvdXRybyDigJQgcmVzdG9yZSBwcmV2aW91cyBpbmVydCB2YWx1ZVxuXHRcdFx0XHRcdG5vZGUuaW5lcnQgPSBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3JpZ2luYWxfaW5lcnRfdmFsdWUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSkuaW5lcnQ7XG5cdFx0XHRcdG5vZGUuaW5lcnQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG5cdFx0XHRwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG5cdFx0XHQvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcblx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYikgdGljaygwLCAxKTtcblx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuXHRcdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG5cdFx0XHRsb29wKChub3cpID0+IHtcblx0XHRcdFx0aWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcblx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuXHRcdFx0XHRcdHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuXHRcdFx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShcblx0XHRcdFx0XHRcdFx0bm9kZSxcblx0XHRcdFx0XHRcdFx0dCxcblx0XHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtLmIsXG5cdFx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0ZWFzaW5nLFxuXHRcdFx0XHRcdFx0XHRjb25maWcuY3NzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVubmluZ19wcm9ncmFtKSB7XG5cdFx0XHRcdFx0aWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG5cdFx0XHRcdFx0XHR0aWNrKCh0ID0gcnVubmluZ19wcm9ncmFtLmIpLCAxIC0gdCk7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuXHRcdFx0XHRcdFx0aWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcblx0XHRcdFx0XHRcdFx0Ly8gd2UncmUgZG9uZVxuXHRcdFx0XHRcdFx0XHRpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBpbnRybyDigJQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBvdXRybyDigJQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcblx0XHRcdFx0XHRcdHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuXHRcdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4ge1xuXHRcdHJ1bihiKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdFx0XHR3YWl0KCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgb3B0cyA9IHsgZGlyZWN0aW9uOiBiID8gJ2luJyA6ICdvdXQnIH07XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRzKTtcblx0XHRcdFx0XHRnbyhiKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbyhiKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGVuZCgpIHtcblx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0cnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0XHR9XG5cdH07XG59XG5cbi8qKiBAdHlwZWRlZiB7MX0gSU5UUk8gKi9cbi8qKiBAdHlwZWRlZiB7MH0gT1VUUk8gKi9cbi8qKiBAdHlwZWRlZiB7eyBkaXJlY3Rpb246ICdpbicgfCAnb3V0JyB8ICdib3RoJyB9fSBUcmFuc2l0aW9uT3B0aW9ucyAqL1xuLyoqIEB0eXBlZGVmIHsobm9kZTogRWxlbWVudCwgcGFyYW1zOiBhbnksIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zKSA9PiBpbXBvcnQoJy4uL3RyYW5zaXRpb24vcHVibGljLmpzJykuVHJhbnNpdGlvbkNvbmZpZ30gVHJhbnNpdGlvbkZuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3V0cm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9uW119IGNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZW5kaW5nUHJvZ3JhbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge0lOVFJPfE9VVFJPfSBiXG4gKiBAcHJvcGVydHkge091dHJvfSBbZ3JvdXBdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9ncmFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gYVxuICogQHByb3BlcnR5IHtJTlRST3xPVVRST30gYlxuICogQHByb3BlcnR5IHsxfC0xfSBkXG4gKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZFxuICogQHByb3BlcnR5IHtPdXRyb30gW2dyb3VwXVxuICovXG4iLCJpbXBvcnQgeyBpc19wcm9taXNlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBjaGVja19vdXRyb3MsIGdyb3VwX291dHJvcywgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQgfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcbmltcG9ydCB7IGZsdXNoIH0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICcuL2xpZmVjeWNsZS5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UHJvbWlzZTxUPn0gcHJvbWlzZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlByb21pc2VJbmZvPFQ+fSBpbmZvXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9wcm9taXNlKHByb21pc2UsIGluZm8pIHtcblx0Y29uc3QgdG9rZW4gPSAoaW5mby50b2tlbiA9IHt9KTtcblx0LyoqXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5GcmFnbWVudEZhY3Rvcnl9IHR5cGVcblx0ICogQHBhcmFtIHswIHwgMSB8IDJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBba2V5XVxuXHQgKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZSh0eXBlLCBpbmRleCwga2V5LCB2YWx1ZSkge1xuXHRcdGlmIChpbmZvLnRva2VuICE9PSB0b2tlbikgcmV0dXJuO1xuXHRcdGluZm8ucmVzb2x2ZWQgPSB2YWx1ZTtcblx0XHRsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG5cdFx0aWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjaGlsZF9jdHggPSBjaGlsZF9jdHguc2xpY2UoKTtcblx0XHRcdGNoaWxkX2N0eFtrZXldID0gdmFsdWU7XG5cdFx0fVxuXHRcdGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcblx0XHRsZXQgbmVlZHNfZmx1c2ggPSBmYWxzZTtcblx0XHRpZiAoaW5mby5ibG9jaykge1xuXHRcdFx0aWYgKGluZm8uYmxvY2tzKSB7XG5cdFx0XHRcdGluZm8uYmxvY2tzLmZvckVhY2goKGJsb2NrLCBpKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGkgIT09IGluZGV4ICYmIGJsb2NrKSB7XG5cdFx0XHRcdFx0XHRncm91cF9vdXRyb3MoKTtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmZvLmJsb2Nrc1tpXSA9PT0gYmxvY2spIHtcblx0XHRcdFx0XHRcdFx0XHRpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0Y2hlY2tfb3V0cm9zKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluZm8uYmxvY2suZCgxKTtcblx0XHRcdH1cblx0XHRcdGJsb2NrLmMoKTtcblx0XHRcdHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuXHRcdFx0YmxvY2subShpbmZvLm1vdW50KCksIGluZm8uYW5jaG9yKTtcblx0XHRcdG5lZWRzX2ZsdXNoID0gdHJ1ZTtcblx0XHR9XG5cdFx0aW5mby5ibG9jayA9IGJsb2NrO1xuXHRcdGlmIChpbmZvLmJsb2NrcykgaW5mby5ibG9ja3NbaW5kZXhdID0gYmxvY2s7XG5cdFx0aWYgKG5lZWRzX2ZsdXNoKSB7XG5cdFx0XHRmbHVzaCgpO1xuXHRcdH1cblx0fVxuXHRpZiAoaXNfcHJvbWlzZShwcm9taXNlKSkge1xuXHRcdGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG5cdFx0cHJvbWlzZS50aGVuKFxuXHRcdFx0KHZhbHVlKSA9PiB7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG5cdFx0XHRcdHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHZhbHVlKTtcblx0XHRcdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuXHRcdFx0fSxcblx0XHRcdChlcnJvcikgPT4ge1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuXHRcdFx0XHR1cGRhdGUoaW5mby5jYXRjaCwgMiwgaW5mby5lcnJvciwgZXJyb3IpO1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG5cdFx0XHRcdGlmICghaW5mby5oYXNDYXRjaCkge1xuXHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblx0XHQvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBhIHRoZW4vY2F0Y2ggYmxvY2ssIGRlc3Ryb3kgaXRcblx0XHRpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcblx0XHRcdHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuXHRcdFx0dXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aW5mby5yZXNvbHZlZCA9IC8qKiBAdHlwZSB7VH0gKi8gKHByb21pc2UpO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoKGluZm8sIGN0eCwgZGlydHkpIHtcblx0Y29uc3QgY2hpbGRfY3R4ID0gY3R4LnNsaWNlKCk7XG5cdGNvbnN0IHsgcmVzb2x2ZWQgfSA9IGluZm87XG5cdGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8udGhlbikge1xuXHRcdGNoaWxkX2N0eFtpbmZvLnZhbHVlXSA9IHJlc29sdmVkO1xuXHR9XG5cdGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8uY2F0Y2gpIHtcblx0XHRjaGlsZF9jdHhbaW5mby5lcnJvcl0gPSByZXNvbHZlZDtcblx0fVxuXHRpbmZvLmJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG59XG4iLCJpbXBvcnQgeyB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vLyBnZW5lcmFsIGVhY2ggZnVuY3Rpb25zOlxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlX2FycmF5X2xpa2UoYXJyYXlfbGlrZV9vcl9pdGVyYXRvcikge1xuXHRyZXR1cm4gYXJyYXlfbGlrZV9vcl9pdGVyYXRvcj8ubGVuZ3RoICE9PSB1bmRlZmluZWRcblx0XHQ/IGFycmF5X2xpa2Vfb3JfaXRlcmF0b3Jcblx0XHQ6IEFycmF5LmZyb20oYXJyYXlfbGlrZV9vcl9pdGVyYXRvcik7XG59XG5cbi8vIGtleWVkIGVhY2ggZnVuY3Rpb25zOlxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmQoMSk7XG5cdGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0dHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcblx0XHRsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG5cdH0pO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZigpO1xuXHRkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmYoKTtcblx0b3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W119ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2goXG5cdG9sZF9ibG9ja3MsXG5cdGRpcnR5LFxuXHRnZXRfa2V5LFxuXHRkeW5hbWljLFxuXHRjdHgsXG5cdGxpc3QsXG5cdGxvb2t1cCxcblx0bm9kZSxcblx0ZGVzdHJveSxcblx0Y3JlYXRlX2VhY2hfYmxvY2ssXG5cdG5leHQsXG5cdGdldF9jb250ZXh0XG4pIHtcblx0bGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcblx0bGV0IG4gPSBsaXN0Lmxlbmd0aDtcblx0bGV0IGkgPSBvO1xuXHRjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuXHR3aGlsZSAoaS0tKSBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuXHRjb25zdCBuZXdfYmxvY2tzID0gW107XG5cdGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG5cdGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcblx0Y29uc3QgdXBkYXRlcyA9IFtdO1xuXHRpID0gbjtcblx0d2hpbGUgKGktLSkge1xuXHRcdGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG5cdFx0Y29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuXHRcdGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcblx0XHRpZiAoIWJsb2NrKSB7XG5cdFx0XHRibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcblx0XHRcdGJsb2NrLmMoKTtcblx0XHR9IGVsc2UgaWYgKGR5bmFtaWMpIHtcblx0XHRcdC8vIGRlZmVyIHVwZGF0ZXMgdW50aWwgYWxsIHRoZSBET00gc2h1ZmZsaW5nIGlzIGRvbmVcblx0XHRcdHVwZGF0ZXMucHVzaCgoKSA9PiBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpKTtcblx0XHR9XG5cdFx0bmV3X2xvb2t1cC5zZXQoa2V5LCAobmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKSk7XG5cdFx0aWYgKGtleSBpbiBvbGRfaW5kZXhlcykgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG5cdH1cblx0Y29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuXHRjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcblx0XHR0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcblx0XHRibG9jay5tKG5vZGUsIG5leHQpO1xuXHRcdGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG5cdFx0bmV4dCA9IGJsb2NrLmZpcnN0O1xuXHRcdG4tLTtcblx0fVxuXHR3aGlsZSAobyAmJiBuKSB7XG5cdFx0Y29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG5cdFx0Y29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG5cdFx0Y29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG5cdFx0Y29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG5cdFx0aWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG5cdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuXHRcdFx0by0tO1xuXHRcdFx0bi0tO1xuXHRcdH0gZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG5cdFx0XHQvLyByZW1vdmUgb2xkIGJsb2NrXG5cdFx0XHRkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcblx0XHRcdG8tLTtcblx0XHR9IGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcblx0XHRcdGluc2VydChuZXdfYmxvY2spO1xuXHRcdH0gZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG5cdFx0XHRvLS07XG5cdFx0fSBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuXHRcdFx0ZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuXHRcdFx0aW5zZXJ0KG5ld19ibG9jayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG5cdFx0XHRvLS07XG5cdFx0fVxuXHR9XG5cdHdoaWxlIChvLS0pIHtcblx0XHRjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuXHRcdGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuXHR9XG5cdHdoaWxlIChuKSBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuXHRydW5fYWxsKHVwZGF0ZXMpO1xuXHRyZXR1cm4gbmV3X2Jsb2Nrcztcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG5cdGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG5cdFx0aWYgKGtleXMuaGFzKGtleSkpIHtcblx0XHRcdGxldCB2YWx1ZSA9ICcnO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFsdWUgPSBgd2l0aCB2YWx1ZSAnJHtTdHJpbmcoa2V5KX0nIGA7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIGNhbid0IHN0cmluZ2lmeVxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRgQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoOiBLZXlzIGF0IGluZGV4ICR7a2V5cy5nZXQoXG5cdFx0XHRcdFx0a2V5XG5cdFx0XHRcdCl9IGFuZCAke2l9ICR7dmFsdWV9YXJlIGR1cGxpY2F0ZXNgXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRrZXlzLnNldChrZXksIGkpO1xuXHR9XG59XG4iLCIvKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zcHJlYWRfdXBkYXRlKGxldmVscywgdXBkYXRlcykge1xuXHRjb25zdCB1cGRhdGUgPSB7fTtcblx0Y29uc3QgdG9fbnVsbF9vdXQgPSB7fTtcblx0Y29uc3QgYWNjb3VudGVkX2ZvciA9IHsgJCRzY29wZTogMSB9O1xuXHRsZXQgaSA9IGxldmVscy5sZW5ndGg7XG5cdHdoaWxlIChpLS0pIHtcblx0XHRjb25zdCBvID0gbGV2ZWxzW2ldO1xuXHRcdGNvbnN0IG4gPSB1cGRhdGVzW2ldO1xuXHRcdGlmIChuKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG5cdFx0XHRcdGlmICghKGtleSBpbiBuKSkgdG9fbnVsbF9vdXRba2V5XSA9IDE7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG5cdFx0XHRcdGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG5cdFx0XHRcdFx0dXBkYXRlW2tleV0gPSBuW2tleV07XG5cdFx0XHRcdFx0YWNjb3VudGVkX2ZvcltrZXldID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGV2ZWxzW2ldID0gbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gbykge1xuXHRcdFx0XHRhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuXHRcdGlmICghKGtleSBpbiB1cGRhdGUpKSB1cGRhdGVba2V5XSA9IHVuZGVmaW5lZDtcblx0fVxuXHRyZXR1cm4gdXBkYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG5cdHJldHVybiB0eXBlb2Ygc3ByZWFkX3Byb3BzID09PSAnb2JqZWN0JyAmJiBzcHJlYWRfcHJvcHMgIT09IG51bGwgPyBzcHJlYWRfcHJvcHMgOiB7fTtcbn1cbiIsImNvbnN0IF9ib29sZWFuX2F0dHJpYnV0ZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FsbG93cGF5bWVudHJlcXVlc3QnLFxuXHQnYXN5bmMnLFxuXHQnYXV0b2ZvY3VzJyxcblx0J2F1dG9wbGF5Jyxcblx0J2NoZWNrZWQnLFxuXHQnY29udHJvbHMnLFxuXHQnZGVmYXVsdCcsXG5cdCdkZWZlcicsXG5cdCdkaXNhYmxlZCcsXG5cdCdmb3Jtbm92YWxpZGF0ZScsXG5cdCdoaWRkZW4nLFxuXHQnaW5lcnQnLFxuXHQnaXNtYXAnLFxuXHQnbG9vcCcsXG5cdCdtdWx0aXBsZScsXG5cdCdtdXRlZCcsXG5cdCdub21vZHVsZScsXG5cdCdub3ZhbGlkYXRlJyxcblx0J29wZW4nLFxuXHQncGxheXNpbmxpbmUnLFxuXHQncmVhZG9ubHknLFxuXHQncmVxdWlyZWQnLFxuXHQncmV2ZXJzZWQnLFxuXHQnc2VsZWN0ZWQnXG5dKTtcblxuLyoqXG4gKiBMaXN0IG9mIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzIChlLmcuIGA8aW5wdXQgZGlzYWJsZWQ+YCkuXG4gKiBTb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuICpcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoWy4uLl9ib29sZWFuX2F0dHJpYnV0ZXNdKTtcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgX2Jvb2xlYW5fYXR0cmlidXRlc1tudW1iZXJdfSBCb29sZWFuQXR0cmlidXRlcyAqL1xuIiwiaW1wb3J0IHsgc2V0X2N1cnJlbnRfY29tcG9uZW50LCBjdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IHJ1bl9hbGwsIGJsYW5rX29iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgYm9vbGVhbl9hdHRyaWJ1dGVzIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Jvb2xlYW5fYXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVfYXJyYXlfbGlrZSB9IGZyb20gJy4vZWFjaC5qcyc7XG5leHBvcnQgeyBpc192b2lkIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL25hbWVzLmpzJztcblxuZXhwb3J0IGNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID1cblx0L1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWQoYXJncywgYXR0cnNfdG9fYWRkKSB7XG5cdGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcblx0aWYgKGF0dHJzX3RvX2FkZCkge1xuXHRcdGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG5cdFx0Y29uc3Qgc3R5bGVzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5zdHlsZXM7XG5cdFx0aWYgKGNsYXNzZXNfdG9fYWRkKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlcy5jbGFzcyA9PSBudWxsKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzX3RvX2FkZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMuY2xhc3MgKz0gJyAnICsgY2xhc3Nlc190b19hZGQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzdHlsZXNfdG9fYWRkKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlc190b19hZGQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoXG5cdFx0XHRcdFx0bWVyZ2Vfc3NyX3N0eWxlcyhhdHRyaWJ1dGVzLnN0eWxlLCBzdHlsZXNfdG9fYWRkKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRsZXQgc3RyID0gJyc7XG5cdE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKG5hbWUpID0+IHtcblx0XHRpZiAoaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIudGVzdChuYW1lKSkgcmV0dXJuO1xuXHRcdGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IHRydWUpIHN0ciArPSAnICcgKyBuYW1lO1xuXHRcdGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0aWYgKHZhbHVlKSBzdHIgKz0gJyAnICsgbmFtZTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gc3RyO1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlX3Nzcl9zdHlsZXMoc3R5bGVfYXR0cmlidXRlLCBzdHlsZV9kaXJlY3RpdmUpIHtcblx0Y29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG5cdGZvciAoY29uc3QgaW5kaXZpZHVhbF9zdHlsZSBvZiBzdHlsZV9hdHRyaWJ1dGUuc3BsaXQoJzsnKSkge1xuXHRcdGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG5cdFx0Y29uc3QgbmFtZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoMCwgY29sb25faW5kZXgpLnRyaW0oKTtcblx0XHRjb25zdCB2YWx1ZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoY29sb25faW5kZXggKyAxKS50cmltKCk7XG5cdFx0aWYgKCFuYW1lKSBjb250aW51ZTtcblx0XHRzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0fVxuXHRmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHlsZV9kaXJlY3RpdmVbbmFtZV07XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRzdHlsZV9vYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0eWxlX29iamVjdDtcbn1cblxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG5cbi8qKlxuICogTm90ZTogdGhpcyBtZXRob2QgaXMgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlIGFuZCBoYXMgYmVlbiBvcHRpbWl6ZWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC81NzAxXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlKHZhbHVlLCBpc19hdHRyID0gZmFsc2UpIHtcblx0Y29uc3Qgc3RyID0gU3RyaW5nKHZhbHVlKTtcblx0Y29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcblx0cGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXHRsZXQgZXNjYXBlZCA9ICcnO1xuXHRsZXQgbGFzdCA9IDA7XG5cdHdoaWxlIChwYXR0ZXJuLnRlc3Qoc3RyKSkge1xuXHRcdGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG5cdFx0Y29uc3QgY2ggPSBzdHJbaV07XG5cdFx0ZXNjYXBlZCArPSBzdHIuc3Vic3RyaW5nKGxhc3QsIGkpICsgKGNoID09PSAnJicgPyAnJmFtcDsnIDogY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7Jyk7XG5cdFx0bGFzdCA9IGkgKyAxO1xuXHR9XG5cdHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcblx0Ly8ga2VlcCBib29sZWFucywgbnVsbCwgYW5kIHVuZGVmaW5lZCBmb3IgdGhlIHNha2Ugb2YgYHNwcmVhZGBcblx0Y29uc3Qgc2hvdWxkX2VzY2FwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpO1xuXHRyZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVfb2JqZWN0KG9iaikge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG5cdFx0cmVzdWx0W2tleV0gPSBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKG9ialtrZXldKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuXHRpdGVtcyA9IGVuc3VyZV9hcnJheV9saWtlKGl0ZW1zKTtcblx0bGV0IHN0ciA9ICcnO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0c3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgY29uc3QgbWlzc2luZ19jb21wb25lbnQgPSB7XG5cdCQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcblx0aWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuXHRcdGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpIG5hbWUgKz0gJyB0aGlzPXsuLi59Jztcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXMuIE90aGVyd2lzZSB5b3UgbWF5IG5lZWQgdG8gZml4IGEgPCR7bmFtZX0+LmBcblx0XHQpO1xuXHR9XG5cdHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG5cdGNvbnNvbGUubG9nKGB7QGRlYnVnfSAke2ZpbGUgPyBmaWxlICsgJyAnIDogJyd9KCR7bGluZX06JHtjb2x1bW59KWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0Y29uc29sZS5sb2codmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdHJldHVybiAnJztcbn1cblxubGV0IG9uX2Rlc3Ryb3k7XG5cbi8qKiBAcmV0dXJucyB7eyByZW5kZXI6IChwcm9wcz86IHt9LCB7ICQkc2xvdHMsIGNvbnRleHQgfT86IHsgJCRzbG90cz86IHt9OyBjb250ZXh0PzogTWFwPGFueSwgYW55PjsgfSkgPT4geyBodG1sOiBhbnk7IGNzczogeyBjb2RlOiBzdHJpbmc7IG1hcDogYW55OyB9OyBoZWFkOiBzdHJpbmc7IH07ICQkcmVuZGVyOiAocmVzdWx0OiBhbnksIHByb3BzOiBhbnksIGJpbmRpbmdzOiBhbnksIHNsb3RzOiBhbnksIGNvbnRleHQ6IGFueSkgPT4gYW55OyB9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9zc3JfY29tcG9uZW50KGZuKSB7XG5cdGZ1bmN0aW9uICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cywgY29udGV4dCkge1xuXHRcdGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcblx0XHRjb25zdCAkJCA9IHtcblx0XHRcdG9uX2Rlc3Ryb3ksXG5cdFx0XHRjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuXHRcdFx0Ly8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcblx0XHRcdG9uX21vdW50OiBbXSxcblx0XHRcdGJlZm9yZV91cGRhdGU6IFtdLFxuXHRcdFx0YWZ0ZXJfdXBkYXRlOiBbXSxcblx0XHRcdGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcblx0XHR9O1xuXHRcdHNldF9jdXJyZW50X2NvbXBvbmVudCh7ICQkIH0pO1xuXHRcdGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuXHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcblx0XHRyZXR1cm4gaHRtbDtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuXHRcdFx0b25fZGVzdHJveSA9IFtdO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuXHRcdFx0Y29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcblx0XHRcdHJ1bl9hbGwob25fZGVzdHJveSk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRodG1sLFxuXHRcdFx0XHRjc3M6IHtcblx0XHRcdFx0XHRjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpXG5cdFx0XHRcdFx0XHQubWFwKChjc3MpID0+IGNzcy5jb2RlKVxuXHRcdFx0XHRcdFx0LmpvaW4oJ1xcbicpLFxuXHRcdFx0XHRcdG1hcDogbnVsbCAvLyBUT0RPXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGhlYWQ6IHJlc3VsdC50aXRsZSArIHJlc3VsdC5oZWFkXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0JCRyZW5kZXJcblx0fTtcbn1cblxuLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuXHRpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKSByZXR1cm4gJyc7XG5cdGNvbnN0IGFzc2lnbm1lbnQgPSBib29sZWFuICYmIHZhbHVlID09PSB0cnVlID8gJycgOiBgPVwiJHtlc2NhcGUodmFsdWUsIHRydWUpfVwiYDtcblx0cmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfY2xhc3NlcyhjbGFzc2VzKSB7XG5cdHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cblxuLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5mdW5jdGlvbiBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVfb2JqZWN0KVxuXHRcdC5maWx0ZXIoKGtleSkgPT4gc3R5bGVfb2JqZWN0W2tleV0gIT0gbnVsbCAmJiBzdHlsZV9vYmplY3Rba2V5XSAhPT0gJycpXG5cdFx0Lm1hcCgoa2V5KSA9PiBgJHtrZXl9OiAke2VzY2FwZV9hdHRyaWJ1dGVfdmFsdWUoc3R5bGVfb2JqZWN0W2tleV0pfTtgKVxuXHRcdC5qb2luKCcgJyk7XG59XG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9zdHlsZXMoc3R5bGVfb2JqZWN0KSB7XG5cdGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KTtcblx0cmV0dXJuIHN0eWxlcyA/IGAgc3R5bGU9XCIke3N0eWxlc31cImAgOiAnJztcbn1cbiIsImltcG9ydCB7XG5cdGFkZF9yZW5kZXJfY2FsbGJhY2ssXG5cdGZsdXNoLFxuXHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzLFxuXHRzY2hlZHVsZV91cGRhdGUsXG5cdGRpcnR5X2NvbXBvbmVudHNcbn0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IGJsYW5rX29iamVjdCwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBydW4sIHJ1bl9hbGwsIG5vb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGNoaWxkcmVuLFxuXHRkZXRhY2gsXG5cdHN0YXJ0X2h5ZHJhdGluZyxcblx0ZW5kX2h5ZHJhdGluZyxcblx0Z2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyxcblx0aW5zZXJ0LFxuXHRlbGVtZW50LFxuXHRhdHRyXG59IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IHRyYW5zaXRpb25faW4gfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuXHRjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcblx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG5cdGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG5cdGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yKSB7XG5cdGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuXHRmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcblx0Ly8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuXHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcblx0XHRjb25zdCBuZXdfb25fZGVzdHJveSA9IGNvbXBvbmVudC4kJC5vbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuXHRcdC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuXHRcdC8vIGl0IHdpbGwgdXBkYXRlIHRoZSBgJCQub25fZGVzdHJveWAgcmVmZXJlbmNlIHRvIGBudWxsYC5cblx0XHQvLyB0aGUgZGVzdHJ1Y3R1cmVkIG9uX2Rlc3Ryb3kgbWF5IHN0aWxsIHJlZmVyZW5jZSB0byB0aGUgb2xkIGFycmF5XG5cdFx0aWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG5cdFx0XHRjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG5cdFx0XHRydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcblx0XHR9XG5cdFx0Y29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG5cdH0pO1xuXHRhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG5cdGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuXHRpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKCQkLmFmdGVyX3VwZGF0ZSk7XG5cdFx0cnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG5cdFx0Ly8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuXHRcdC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcblx0XHQkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuXHRcdCQkLmN0eCA9IFtdO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG5cdGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG5cdFx0ZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cdFx0c2NoZWR1bGVfdXBkYXRlKCk7XG5cdFx0Y29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG5cdH1cblx0Y29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gMSA8PCBpICUgMzE7XG59XG5cbi8vIFRPRE86IERvY3VtZW50IHRoZSBvdGhlciBwYXJhbXNcbi8qKlxuICogQHBhcmFtIHtTdmVsdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zfSBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vdXRpbHMuanMnKVsnbm90X2VxdWFsJ119IG5vdF9lcXVhbCBVc2VkIHRvIGNvbXBhcmUgcHJvcHMgYW5kIHN0YXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7KHRhcmdldDogRWxlbWVudCB8IFNoYWRvd1Jvb3QpID0+IHZvaWR9IFthcHBlbmRfc3R5bGVzXSBGdW5jdGlvbiB0aGF0IGFwcGVuZHMgc3R5bGVzIHRvIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGlzIGZpcnN0IGluaXRpYWxpc2VkLlxuICogVGhpcyB3aWxsIGJlIHRoZSBgYWRkX2Nzc2AgZnVuY3Rpb24gZnJvbSB0aGUgY29tcGlsZWQgY29tcG9uZW50LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChcblx0Y29tcG9uZW50LFxuXHRvcHRpb25zLFxuXHRpbnN0YW5jZSxcblx0Y3JlYXRlX2ZyYWdtZW50LFxuXHRub3RfZXF1YWwsXG5cdHByb3BzLFxuXHRhcHBlbmRfc3R5bGVzID0gbnVsbCxcblx0ZGlydHkgPSBbLTFdXG4pIHtcblx0Y29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlQkJH0gKi9cblx0Y29uc3QgJCQgPSAoY29tcG9uZW50LiQkID0ge1xuXHRcdGZyYWdtZW50OiBudWxsLFxuXHRcdGN0eDogW10sXG5cdFx0Ly8gc3RhdGVcblx0XHRwcm9wcyxcblx0XHR1cGRhdGU6IG5vb3AsXG5cdFx0bm90X2VxdWFsLFxuXHRcdGJvdW5kOiBibGFua19vYmplY3QoKSxcblx0XHQvLyBsaWZlY3ljbGVcblx0XHRvbl9tb3VudDogW10sXG5cdFx0b25fZGVzdHJveTogW10sXG5cdFx0b25fZGlzY29ubmVjdDogW10sXG5cdFx0YmVmb3JlX3VwZGF0ZTogW10sXG5cdFx0YWZ0ZXJfdXBkYXRlOiBbXSxcblx0XHRjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG5cdFx0Ly8gZXZlcnl0aGluZyBlbHNlXG5cdFx0Y2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcblx0XHRkaXJ0eSxcblx0XHRza2lwX2JvdW5kOiBmYWxzZSxcblx0XHRyb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3Rcblx0fSk7XG5cdGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcblx0bGV0IHJlYWR5ID0gZmFsc2U7XG5cdCQkLmN0eCA9IGluc3RhbmNlXG5cdFx0PyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG5cdFx0XHRcdGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgKCQkLmN0eFtpXSA9IHZhbHVlKSkpIHtcblx0XHRcdFx0XHRpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pICQkLmJvdW5kW2ldKHZhbHVlKTtcblx0XHRcdFx0XHRpZiAocmVhZHkpIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdCAgfSlcblx0XHQ6IFtdO1xuXHQkJC51cGRhdGUoKTtcblx0cmVhZHkgPSB0cnVlO1xuXHRydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuXHQvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcblx0JCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuXHRpZiAob3B0aW9ucy50YXJnZXQpIHtcblx0XHRpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG5cdFx0XHRzdGFydF9oeWRyYXRpbmcoKTtcblx0XHRcdC8vIFRPRE86IHdoYXQgaXMgdGhlIGNvcnJlY3QgdHlwZSBoZXJlP1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0Y29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG5cdFx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcblx0XHRcdG5vZGVzLmZvckVhY2goZGV0YWNoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW50cm8pIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcblx0XHRtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IpO1xuXHRcdGVuZF9oeWRyYXRpbmcoKTtcblx0XHRmbHVzaCgpO1xuXHR9XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cblxuZXhwb3J0IGxldCBTdmVsdGVFbGVtZW50O1xuXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcblx0XHQvKiogVGhlIFN2ZWx0ZSBjb21wb25lbnQgY29uc3RydWN0b3IgKi9cblx0XHQkJGN0b3I7XG5cdFx0LyoqIFNsb3RzICovXG5cdFx0JCRzO1xuXHRcdC8qKiBUaGUgU3ZlbHRlIGNvbXBvbmVudCBpbnN0YW5jZSAqL1xuXHRcdCQkYztcblx0XHQvKiogV2hldGhlciBvciBub3QgdGhlIGN1c3RvbSBlbGVtZW50IGlzIGNvbm5lY3RlZCAqL1xuXHRcdCQkY24gPSBmYWxzZTtcblx0XHQvKiogQ29tcG9uZW50IHByb3BzIGRhdGEgKi9cblx0XHQkJGQgPSB7fTtcblx0XHQvKiogYHRydWVgIGlmIGN1cnJlbnRseSBpbiB0aGUgcHJvY2VzcyBvZiByZWZsZWN0aW5nIGNvbXBvbmVudCBwcm9wcyBiYWNrIHRvIGF0dHJpYnV0ZXMgKi9cblx0XHQkJHIgPSBmYWxzZTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IFByb3BzIGRlZmluaXRpb24gKG5hbWUsIHJlZmxlY3RlZCwgdHlwZSBldGMpICovXG5cdFx0JCRwX2QgPSB7fTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uW10+fSBFdmVudCBsaXN0ZW5lcnMgKi9cblx0XHQkJGwgPSB7fTtcblx0XHQvKiogQHR5cGUge01hcDxGdW5jdGlvbiwgRnVuY3Rpb24+fSBFdmVudCBsaXN0ZW5lciB1bnN1YnNjcmliZSBmdW5jdGlvbnMgKi9cblx0XHQkJGxfdSA9IG5ldyBNYXAoKTtcblxuXHRcdGNvbnN0cnVjdG9yKCQkY29tcG9uZW50Q3RvciwgJCRzbG90cywgdXNlX3NoYWRvd19kb20pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLiQkY3RvciA9ICQkY29tcG9uZW50Q3Rvcjtcblx0XHRcdHRoaXMuJCRzID0gJCRzbG90cztcblx0XHRcdGlmICh1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdFx0XHQvLyBXZSBjYW4ndCBkZXRlcm1pbmUgdXBmcm9udCBpZiB0aGUgZXZlbnQgaXMgYSBjdXN0b20gZXZlbnQgb3Igbm90LCBzbyB3ZSBoYXZlIHRvXG5cdFx0XHQvLyBsaXN0ZW4gdG8gYm90aC4gSWYgc29tZW9uZSB1c2VzIGEgY3VzdG9tIGV2ZW50IHdpdGggdGhlIHNhbWUgbmFtZSBhcyBhIHJlZ3VsYXJcblx0XHRcdC8vIGJyb3dzZXIgZXZlbnQsIHRoaXMgZmlyZXMgdHdpY2UgLSB3ZSBjYW4ndCBhdm9pZCB0aGF0LlxuXHRcdFx0dGhpcy4kJGxbdHlwZV0gPSB0aGlzLiQkbFt0eXBlXSB8fCBbXTtcblx0XHRcdHRoaXMuJCRsW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0dGhpcy4kJGxfdS5zZXQobGlzdGVuZXIsIHVuc3ViKTtcblx0XHRcdH1cblx0XHRcdHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGxfdS5nZXQobGlzdGVuZXIpO1xuXHRcdFx0XHRpZiAodW5zdWIpIHtcblx0XHRcdFx0XHR1bnN1YigpO1xuXHRcdFx0XHRcdHRoaXMuJCRsX3UuZGVsZXRlKGxpc3RlbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNuID0gdHJ1ZTtcblx0XHRcdGlmICghdGhpcy4kJGMpIHtcblx0XHRcdFx0Ly8gV2Ugd2FpdCBvbmUgdGljayB0byBsZXQgcG9zc2libGUgY2hpbGQgc2xvdCBlbGVtZW50cyBiZSBjcmVhdGVkL21vdW50ZWRcblx0XHRcdFx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNuIHx8IHRoaXMuJCRjKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGNyZWF0ZV9zbG90KG5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IG5vZGU7XG5cdFx0XHRcdFx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRcdFx0XHRcdGM6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbWVudCgnc2xvdCcpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChuYW1lICE9PSAnZGVmYXVsdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGF0dHIobm9kZSwgJ25hbWUnLCBuYW1lKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2FuY2hvcl1cblx0XHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRcdG06IGZ1bmN0aW9uIG1vdW50KHRhcmdldCwgYW5jaG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZDogZnVuY3Rpb24gZGVzdHJveShkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGV0YWNoaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZXRhY2gobm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0ICQkc2xvdHMgPSB7fTtcblx0XHRcdFx0Y29uc3QgZXhpc3Rpbmdfc2xvdHMgPSBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKHRoaXMpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy4kJHMpIHtcblx0XHRcdFx0XHRpZiAobmFtZSBpbiBleGlzdGluZ19zbG90cykge1xuXHRcdFx0XHRcdFx0JCRzbG90c1tuYW1lXSA9IFtjcmVhdGVfc2xvdChuYW1lKV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIHRoaXMuYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdC8vIHRoaXMuJCRkYXRhIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzLmF0dHJpYnV0ZXNcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdGhpcy4kJGdfcChhdHRyaWJ1dGUubmFtZSk7XG5cdFx0XHRcdFx0aWYgKCEobmFtZSBpbiB0aGlzLiQkZCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW25hbWVdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKG5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgdGhpcy4kJHBfZCwgJ3RvUHJvcCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBQb3J0IG92ZXIgcHJvcHMgdGhhdCB3ZXJlIHNldCBwcm9ncmFtbWF0aWNhbGx5IGJlZm9yZSBjZSB3YXMgaW5pdGlhbGl6ZWRcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdGlmICghKGtleSBpbiB0aGlzLiQkZCkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0gPSB0aGlzW2tleV07IC8vIGRvbid0IHRyYW5zZm9ybSwgdGhlc2Ugd2VyZSBzZXQgdGhyb3VnaCBKYXZhU2NyaXB0XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpc1trZXldOyAvLyByZW1vdmUgdGhlIHByb3BlcnR5IHRoYXQgc2hhZG93cyB0aGUgZ2V0dGVyL3NldHRlclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkYyA9IG5ldyB0aGlzLiQkY3Rvcih7XG5cdFx0XHRcdFx0dGFyZ2V0OiB0aGlzLnNoYWRvd1Jvb3QgfHwgdGhpcyxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0Li4udGhpcy4kJGQsXG5cdFx0XHRcdFx0XHQkJHNsb3RzLFxuXHRcdFx0XHRcdFx0JCRzY29wZToge1xuXHRcdFx0XHRcdFx0XHRjdHg6IFtdXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBSZWZsZWN0IGNvbXBvbmVudCBwcm9wcyBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdGNvbnN0IHJlZmxlY3RfYXR0cmlidXRlcyA9ICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiQkciA9IHRydWU7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSA9IHRoaXMuJCRjLiQkLmN0eFt0aGlzLiQkYy4kJC5wcm9wc1trZXldXTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLiQkcF9kW2tleV0ucmVmbGVjdCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVfdmFsdWUgPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoXG5cdFx0XHRcdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0sXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4kJHBfZCxcblx0XHRcdFx0XHRcdFx0XHQndG9BdHRyaWJ1dGUnXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGlmIChhdHRyaWJ1dGVfdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgfHwga2V5KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSh0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlIHx8IGtleSwgYXR0cmlidXRlX3ZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLiQkciA9IGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLiQkYy4kJC5hZnRlcl91cGRhdGUucHVzaChyZWZsZWN0X2F0dHJpYnV0ZXMpO1xuXHRcdFx0XHRyZWZsZWN0X2F0dHJpYnV0ZXMoKTsgLy8gb25jZSBpbml0aWFsbHkgYmVjYXVzZSBhZnRlcl91cGRhdGUgaXMgYWRkZWQgdG9vIGxhdGUgZm9yIGZpcnN0IHJlbmRlclxuXG5cdFx0XHRcdGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLiQkbCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4kJGxbdHlwZV0pIHtcblx0XHRcdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRsID0ge307XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0aGlzIHdoZW4gd29ya2luZyB3aXRoaW4gU3ZlbHRlIGNvZGUsIGJ1dCBmb3IgY29tcGF0aWJpbGl0eSBvZiBwZW9wbGUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIFN2ZWx0ZVxuXHRcdC8vIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgdGhyb3VnaCBzZXRBdHRyaWJ1dGUgZXRjLCB0aGlzIGlzIGhlbHBmdWxcblx0XHRhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuJCRyKSByZXR1cm47XG5cdFx0XHRhdHRyID0gdGhpcy4kJGdfcChhdHRyKTtcblx0XHRcdHRoaXMuJCRkW2F0dHJdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKGF0dHIsIG5ld1ZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHR0aGlzLiQkYz8uJHNldCh7IFthdHRyXTogdGhpcy4kJGRbYXR0cl0gfSk7XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSBmYWxzZTtcblx0XHRcdC8vIEluIGEgbWljcm90YXNrLCBiZWNhdXNlIHRoaXMgY291bGQgYmUgYSBtb3ZlIHdpdGhpbiB0aGUgRE9NXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24gJiYgdGhpcy4kJGMpIHtcblx0XHRcdFx0XHR0aGlzLiQkYy4kZGVzdHJveSgpO1xuXHRcdFx0XHRcdHRoaXMuJCRjID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJGdfcChhdHRyaWJ1dGVfbmFtZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0T2JqZWN0LmtleXModGhpcy4kJHBfZCkuZmluZChcblx0XHRcdFx0XHQoa2V5KSA9PlxuXHRcdFx0XHRcdFx0dGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSA9PT0gYXR0cmlidXRlX25hbWUgfHxcblx0XHRcdFx0XHRcdCghdGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gYXR0cmlidXRlX25hbWUpXG5cdFx0XHRcdCkgfHwgYXR0cmlidXRlX25hbWVcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvblxuICogQHBhcmFtIHsndG9BdHRyaWJ1dGUnIHwgJ3RvUHJvcCd9IFt0cmFuc2Zvcm1dXG4gKi9cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbiwgdHJhbnNmb3JtKSB7XG5cdGNvbnN0IHR5cGUgPSBwcm9wc19kZWZpbml0aW9uW3Byb3BdPy50eXBlO1xuXHR2YWx1ZSA9IHR5cGUgPT09ICdCb29sZWFuJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyA/IHZhbHVlICE9IG51bGwgOiB2YWx1ZTtcblx0aWYgKCF0cmFuc2Zvcm0gfHwgIXByb3BzX2RlZmluaXRpb25bcHJvcF0pIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAndG9BdHRyaWJ1dGUnKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJycgOiBudWxsO1xuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTsgLy8gY29udmVyc2lvbiBhbHJlYWR5IGhhbmRsZWQgYWJvdmVcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAhPSBudWxsID8gK3ZhbHVlIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogVHVybiBhIFN2ZWx0ZSBjb21wb25lbnQgaW50byBhIGN1c3RvbSBlbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50VHlwZX0gQ29tcG9uZW50ICBBIFN2ZWx0ZSBjb21wb25lbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvbiAgVGhlIHByb3BzIHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHNsb3RzICBUaGUgc2xvdHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2Nlc3NvcnMgIE90aGVyIGFjY2Vzc29ycyBiZXNpZGVzIHRoZSBvbmVzIGZvciBwcm9wcyB0aGUgY29tcG9uZW50IGhhc1xuICogQHBhcmFtIHtib29sZWFufSB1c2Vfc2hhZG93X2RvbSAgV2hldGhlciB0byB1c2Ugc2hhZG93IERPTVxuICogQHBhcmFtIHsoY2U6IG5ldyAoKSA9PiBIVE1MRWxlbWVudCkgPT4gbmV3ICgpID0+IEhUTUxFbGVtZW50fSBbZXh0ZW5kXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9lbGVtZW50KFxuXHRDb21wb25lbnQsXG5cdHByb3BzX2RlZmluaXRpb24sXG5cdHNsb3RzLFxuXHRhY2Nlc3NvcnMsXG5cdHVzZV9zaGFkb3dfZG9tLFxuXHRleHRlbmRcbikge1xuXHRsZXQgQ2xhc3MgPSBjbGFzcyBleHRlbmRzIFN2ZWx0ZUVsZW1lbnQge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoQ29tcG9uZW50LCBzbG90cywgdXNlX3NoYWRvd19kb20pO1xuXHRcdFx0dGhpcy4kJHBfZCA9IHByb3BzX2RlZmluaXRpb247XG5cdFx0fVxuXHRcdHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLm1hcCgoa2V5KSA9PlxuXHRcdFx0XHQocHJvcHNfZGVmaW5pdGlvbltrZXldLmF0dHJpYnV0ZSB8fCBrZXkpLnRvTG93ZXJDYXNlKClcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuXHRPYmplY3Qua2V5cyhwcm9wc19kZWZpbml0aW9uKS5mb3JFYWNoKChwcm9wKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgcHJvcCwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGMgJiYgcHJvcCBpbiB0aGlzLiQkYyA/IHRoaXMuJCRjW3Byb3BdIDogdGhpcy4kJGRbcHJvcF07XG5cdFx0XHR9LFxuXHRcdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uKTtcblx0XHRcdFx0dGhpcy4kJGRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy4kJGM/LiRzZXQoeyBbcHJvcF06IHZhbHVlIH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0YWNjZXNzb3JzLmZvckVhY2goKGFjY2Vzc29yKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgYWNjZXNzb3IsIHtcblx0XHRcdGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRjPy5bYWNjZXNzb3JdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0aWYgKGV4dGVuZCkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgLSBhc3NpZ25pbmcgaGVyZSBpcyBmaW5lXG5cdFx0Q2xhc3MgPSBleHRlbmQoQ2xhc3MpO1xuXHR9XG5cdENvbXBvbmVudC5lbGVtZW50ID0gLyoqIEB0eXBlIHthbnl9ICovIChDbGFzcyk7XG5cdHJldHVybiBDbGFzcztcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtQcm9wcz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudHM9YW55XVxuICovXG5leHBvcnQgY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJCA9IHVuZGVmaW5lZDtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJHNldCA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdCRkZXN0cm95KCkge1xuXHRcdGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuXHRcdHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSB7RXh0cmFjdDxrZXlvZiBFdmVudHMsIHN0cmluZz59IEtcblx0ICogQHBhcmFtIHtLfSB0eXBlXG5cdCAqIEBwYXJhbSB7KChlOiBFdmVudHNbS10pID0+IHZvaWQpIHwgbnVsbCB8IHVuZGVmaW5lZH0gY2FsbGJhY2tcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHQkb24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0cmV0dXJuIG5vb3A7XG5cdFx0fVxuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKTtcblx0XHRjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BhcnRpYWw8UHJvcHM+fSBwcm9wc1xuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdCRzZXQocHJvcHMpIHtcblx0XHRpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkocHJvcHMpKSB7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuXHRcdFx0dGhpcy4kJHNldChwcm9wcyk7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmlidXRlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVmbGVjdF1cbiAqIEBwcm9wZXJ0eSB7J1N0cmluZyd8J0Jvb2xlYW4nfCdOdW1iZXInfCdBcnJheSd8J09iamVjdCd9IFt0eXBlXVxuICovXG4iLCJpbXBvcnQge1xuXHRjdXN0b21fZXZlbnQsXG5cdGFwcGVuZCxcblx0YXBwZW5kX2h5ZHJhdGlvbixcblx0aW5zZXJ0LFxuXHRpbnNlcnRfaHlkcmF0aW9uLFxuXHRkZXRhY2gsXG5cdGxpc3Rlbixcblx0YXR0clxufSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBTdmVsdGVDb21wb25lbnQgfSBmcm9tICcuL0NvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBpc192b2lkIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzL25hbWVzLmpzJztcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tICcuLi8uLi9zaGFyZWQvdmVyc2lvbi5qcyc7XG5pbXBvcnQgeyBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlX2FycmF5X2xpa2UgfSBmcm9tICcuL2VhY2guanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtUfSBbZGV0YWlsXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG5cdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KHR5cGUsIHsgdmVyc2lvbjogVkVSU0lPTiwgLi4uZGV0YWlsIH0sIHsgYnViYmxlczogdHJ1ZSB9KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfZGV2KHRhcmdldCwgbm9kZSkge1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuXHRhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuXHRhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcblx0aW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cblxuLyoqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuXHRpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoX2Rldihub2RlKSB7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuXHRkZXRhY2gobm9kZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBiZWZvcmVcbiAqIEBwYXJhbSB7Tm9kZX0gYWZ0ZXJcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoX2JldHdlZW5fZGV2KGJlZm9yZSwgYWZ0ZXIpIHtcblx0d2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG5cdFx0ZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBhZnRlclxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuXHR3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG5cdFx0ZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBiZWZvcmVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoX2FmdGVyX2RldihiZWZvcmUpIHtcblx0d2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuXHRcdGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbaGFzX3ByZXZlbnRfZGVmYXVsdF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhc19zdG9wX3Byb3BhZ2F0aW9uXVxuICogQHBhcmFtIHtib29sZWFufSBbaGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uXVxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5fZGV2KFxuXHRub2RlLFxuXHRldmVudCxcblx0aGFuZGxlcixcblx0b3B0aW9ucyxcblx0aGFzX3ByZXZlbnRfZGVmYXVsdCxcblx0aGFzX3N0b3BfcHJvcGFnYXRpb24sXG5cdGhhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvblxuKSB7XG5cdGNvbnN0IG1vZGlmaWVycyA9XG5cdFx0b3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG5cdGlmIChoYXNfcHJldmVudF9kZWZhdWx0KSBtb2RpZmllcnMucHVzaCgncHJldmVudERlZmF1bHQnKTtcblx0aWYgKGhhc19zdG9wX3Byb3BhZ2F0aW9uKSBtb2RpZmllcnMucHVzaCgnc3RvcFByb3BhZ2F0aW9uJyk7XG5cdGlmIChoYXNfc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24pIG1vZGlmaWVycy5wdXNoKCdzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24nKTtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuXHRjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG5cdFx0ZGlzcG9zZSgpO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcblx0ZWxzZSBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG5cdG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0UHJvcGVydHknLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7YW55fSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFzZXRfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuXHRub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0LmRhdGEgPT09IGRhdGEpIHJldHVybjtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpIHJldHVybjtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cl92YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcblx0aWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG5cdFx0c2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhKTtcblx0fSBlbHNlIHtcblx0XHRzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZV9hcnJheV9saWtlX2RldihhcmcpIHtcblx0aWYgKFxuXHRcdHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmXG5cdFx0IShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSAmJlxuXHRcdCEodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZylcblx0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd7I2VhY2h9IG9ubHkgd29ya3Mgd2l0aCBpdGVyYWJsZSB2YWx1ZXMuJyk7XG5cdH1cblx0cmV0dXJuIGVuc3VyZV9hcnJheV9saWtlKGFyZyk7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc2xvdHMobmFtZSwgc2xvdCwga2V5cykge1xuXHRmb3IgKGNvbnN0IHNsb3Rfa2V5IG9mIE9iamVjdC5rZXlzKHNsb3QpKSB7XG5cdFx0aWYgKCF+a2V5cy5pbmRleE9mKHNsb3Rfa2V5KSkge1xuXHRcdFx0Y29uc29sZS53YXJuKGA8JHtuYW1lfT4gcmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBzbG90IFwiJHtzbG90X2tleX1cIi5gKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IHRhZ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQodGFnKSB7XG5cdGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuXHRpZiAodGFnICYmICFpc19zdHJpbmcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJzxzdmVsdGU6ZWxlbWVudD4gZXhwZWN0cyBcInRoaXNcIiBhdHRyaWJ1dGUgdG8gYmUgYSBzdHJpbmcuJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8IHN0cmluZ30gdGFnXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50KHRhZykge1xuXHRpZiAodGFnICYmIGlzX3ZvaWQodGFnKSkge1xuXHRcdGNvbnNvbGUud2FybihgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIke3RhZ31cIj4gaXMgc2VsZi1jbG9zaW5nIGFuZCBjYW5ub3QgaGF2ZSBjb250ZW50LmApO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudF9kZXYoY29tcG9uZW50LCBwcm9wcykge1xuXHRjb25zdCBlcnJvcl9tZXNzYWdlID0gJ3RoaXM9ey4uLn0gb2YgPHN2ZWx0ZTpjb21wb25lbnQ+IHNob3VsZCBzcGVjaWZ5IGEgU3ZlbHRlIGNvbXBvbmVudC4nO1xuXHR0cnkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gbmV3IGNvbXBvbmVudChwcm9wcyk7XG5cdFx0aWYgKCFpbnN0YW5jZS4kJCB8fCAhaW5zdGFuY2UuJHNldCB8fCAhaW5zdGFuY2UuJG9uIHx8ICFpbnN0YW5jZS4kZGVzdHJveSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yX21lc3NhZ2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyO1xuXHRcdGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZS5pbmRleE9mKCdpcyBub3QgYSBjb25zdHJ1Y3RvcicpICE9PSAtMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yX21lc3NhZ2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMgd2l0aCBzb21lIG1pbm9yIGRldi1lbmhhbmNlbWVudHMuIFVzZWQgd2hlbiBkZXY9dHJ1ZS5cbiAqXG4gKiBDYW4gYmUgdXNlZCB0byBjcmVhdGUgc3Ryb25nbHkgdHlwZWQgU3ZlbHRlIGNvbXBvbmVudHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGBgYFxuICogVHlwaW5nIHRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIElERXMgbGlrZSBWUyBDb2RlIHdpdGggdGhlIFN2ZWx0ZSBleHRlbnNpb25cbiAqIHRvIHByb3ZpZGUgaW50ZWxsaXNlbnNlIGFuZCB0byB1c2UgdGhlIGNvbXBvbmVudCBsaWtlIHRoaXMgaW4gYSBTdmVsdGUgZmlsZVxuICogd2l0aCBUeXBlU2NyaXB0OlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICogXHRpbXBvcnQgeyBNeUNvbXBvbmVudCB9IGZyb20gXCJjb21wb25lbnQtbGlicmFyeVwiO1xuICogPC9zY3JpcHQ+XG4gKiA8TXlDb21wb25lbnQgZm9vPXsnYmFyJ30gLz5cbiAqIGBgYFxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbUHJvcHM9YW55XVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Nsb3RzPWFueV1cbiAqIEBleHRlbmRzIHtTdmVsdGVDb21wb25lbnQ8UHJvcHMsIEV2ZW50cz59XG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuXHQvKipcblx0ICogRm9yIHR5cGUgY2hlY2tpbmcgY2FwYWJpbGl0aWVzIG9ubHkuXG5cdCAqIERvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWUuXG5cdCAqICMjIyBETyBOT1QgVVNFIVxuXHQgKlxuXHQgKiBAdHlwZSB7UHJvcHN9XG5cdCAqL1xuXHQkJHByb3BfZGVmO1xuXHQvKipcblx0ICogRm9yIHR5cGUgY2hlY2tpbmcgY2FwYWJpbGl0aWVzIG9ubHkuXG5cdCAqIERvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWUuXG5cdCAqICMjIyBETyBOT1QgVVNFIVxuXHQgKlxuXHQgKiBAdHlwZSB7RXZlbnRzfVxuXHQgKi9cblx0JCRldmVudHNfZGVmO1xuXHQvKipcblx0ICogRm9yIHR5cGUgY2hlY2tpbmcgY2FwYWJpbGl0aWVzIG9ubHkuXG5cdCAqIERvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWUuXG5cdCAqICMjIyBETyBOT1QgVVNFIVxuXHQgKlxuXHQgKiBAdHlwZSB7U2xvdHN9XG5cdCAqL1xuXHQkJHNsb3RfZGVmO1xuXG5cdC8qKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRDb25zdHJ1Y3Rvck9wdGlvbnM8UHJvcHM+fSBvcHRpb25zICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMgfHwgKCFvcHRpb25zLnRhcmdldCAmJiAhb3B0aW9ucy4kJGlubGluZSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIid0YXJnZXQnIGlzIGEgcmVxdWlyZWQgb3B0aW9uXCIpO1xuXHRcdH1cblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHQkZGVzdHJveSgpIHtcblx0XHRzdXBlci4kZGVzdHJveSgpO1xuXHRcdHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0fTtcblx0fVxuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGNhcHR1cmVfc3RhdGUoKSB7fVxuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGluamVjdF9zdGF0ZSgpIHt9XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Byb3BzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50cz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtTbG90cz1hbnldXG4gKiBAZGVwcmVjYXRlZCBVc2UgYFN2ZWx0ZUNvbXBvbmVudGAgaW5zdGVhZC4gU2VlIFBSIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvODUxMlxuICogQGV4dGVuZHMge1N2ZWx0ZUNvbXBvbmVudERldjxQcm9wcywgRXZlbnRzLCBTbG90cz59XG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7fVxuXG4vKiogQHJldHVybnMgeygpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG5cdGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIGRldGVjdGVkJyk7XG5cdFx0fVxuXHR9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9hbmltYXRpb25zLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYXdhaXRfYmxvY2suanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kb20uanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2dsb2JhbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lYWNoLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbG9vcC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NwcmVhZC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3Nzci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db21wb25lbnQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kZXYuanMnO1xuIl0sIm5hbWVzIjpbIm5vb3AiLCJpZGVudGl0eSIsIngiLCJhc3NpZ24iLCJ0YXIiLCJzcmMiLCJrIiwiaXNfcHJvbWlzZSIsInZhbHVlIiwidGhlbiIsImFkZF9sb2NhdGlvbiIsImVsZW1lbnQiLCJmaWxlIiwibGluZSIsImNvbHVtbiIsImNoYXIiLCJfX3N2ZWx0ZV9tZXRhIiwibG9jIiwicnVuIiwiZm4iLCJibGFua19vYmplY3QiLCJPYmplY3QiLCJjcmVhdGUiLCJydW5fYWxsIiwiZm5zIiwiZm9yRWFjaCIsImlzX2Z1bmN0aW9uIiwidGhpbmciLCJzYWZlX25vdF9lcXVhbCIsImEiLCJiIiwic3JjX3VybF9lcXVhbF9hbmNob3IiLCJzcmNfdXJsX2VxdWFsIiwiZWxlbWVudF9zcmMiLCJ1cmwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwic3BsaXRfc3Jjc2V0Iiwic3Jjc2V0Iiwic3BsaXQiLCJtYXAiLCJ0cmltIiwiZmlsdGVyIiwiQm9vbGVhbiIsInNyY3NldF91cmxfZXF1YWwiLCJlbGVtZW50X3NyY3NldCIsImVsZW1lbnRfdXJscyIsInVybHMiLCJsZW5ndGgiLCJldmVyeSIsIndpZHRoIiwiaSIsIm5vdF9lcXVhbCIsImlzX2VtcHR5Iiwib2JqIiwia2V5cyIsInZhbGlkYXRlX3N0b3JlIiwic3RvcmUiLCJuYW1lIiwic3Vic2NyaWJlIiwiRXJyb3IiLCJjYWxsYmFja3MiLCJjYWxsYmFjayIsInVuZGVmaW5lZCIsInVuc3ViIiwidW5zdWJzY3JpYmUiLCJnZXRfc3RvcmVfdmFsdWUiLCJfIiwiY29tcG9uZW50X3N1YnNjcmliZSIsImNvbXBvbmVudCIsIiQkIiwib25fZGVzdHJveSIsInB1c2giLCJjcmVhdGVfc2xvdCIsImRlZmluaXRpb24iLCJjdHgiLCIkJHNjb3BlIiwic2xvdF9jdHgiLCJnZXRfc2xvdF9jb250ZXh0Iiwic2xpY2UiLCJnZXRfc2xvdF9jaGFuZ2VzIiwiZGlydHkiLCJsZXRzIiwibWVyZ2VkIiwibGVuIiwiTWF0aCIsIm1heCIsInVwZGF0ZV9zbG90X2Jhc2UiLCJzbG90Iiwic2xvdF9kZWZpbml0aW9uIiwic2xvdF9jaGFuZ2VzIiwiZ2V0X3Nsb3RfY29udGV4dF9mbiIsInNsb3RfY29udGV4dCIsInAiLCJ1cGRhdGVfc2xvdCIsImdldF9zbG90X2NoYW5nZXNfZm4iLCJnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUiLCJleGNsdWRlX2ludGVybmFsX3Byb3BzIiwicHJvcHMiLCJyZXN1bHQiLCJjb21wdXRlX3Jlc3RfcHJvcHMiLCJyZXN0IiwiU2V0IiwiaGFzIiwiY29tcHV0ZV9zbG90cyIsInNsb3RzIiwia2V5Iiwib25jZSIsInJhbiIsImFyZ3MiLCJjYWxsIiwibnVsbF90b19lbXB0eSIsInNldF9zdG9yZV92YWx1ZSIsInJldCIsInNldCIsImhhc19wcm9wIiwicHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiYWN0aW9uX2Rlc3Ryb3llciIsImFjdGlvbl9yZXN1bHQiLCJkZXN0cm95Iiwic3BsaXRfY3NzX3VuaXQiLCJtYXRjaCIsInBhcnNlRmxvYXQiLCJjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcyIsImlzX2NsaWVudCIsIndpbmRvdyIsIm5vdyIsInBlcmZvcm1hbmNlIiwiRGF0ZSIsInJhZiIsImNiIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0X25vdyIsInNldF9yYWYiLCJ0YXNrcyIsInJ1bl90YXNrcyIsInRhc2siLCJjIiwiZGVsZXRlIiwiZiIsInNpemUiLCJjbGVhcl9sb29wcyIsImNsZWFyIiwibG9vcCIsInByb21pc2UiLCJQcm9taXNlIiwiZnVsZmlsbCIsImFkZCIsImFib3J0IiwiZ2xvYmFscyIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJSZXNpemVPYnNlcnZlclNpbmdsZXRvbiIsIl9saXN0ZW5lcnMiLCJXZWFrTWFwIiwiX29ic2VydmVyIiwib3B0aW9ucyIsImNvbnN0cnVjdG9yIiwib2JzZXJ2ZSIsImxpc3RlbmVyIiwiX2dldE9ic2VydmVyIiwidW5vYnNlcnZlIiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZW50cnkiLCJ0YXJnZXQiLCJnZXQiLCJpc19oeWRyYXRpbmciLCJzdGFydF9oeWRyYXRpbmciLCJlbmRfaHlkcmF0aW5nIiwidXBwZXJfYm91bmQiLCJsb3ciLCJoaWdoIiwibWlkIiwiaW5pdF9oeWRyYXRlIiwiaHlkcmF0ZV9pbml0IiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwibm9kZU5hbWUiLCJteV9jaGlsZHJlbiIsIm5vZGUiLCJjbGFpbV9vcmRlciIsIm0iLCJJbnQzMkFycmF5IiwibG9uZ2VzdCIsImN1cnJlbnQiLCJzZXFfbGVuIiwiaWR4IiwibmV3X2xlbiIsImxpcyIsInRvX21vdmUiLCJsYXN0IiwiY3VyIiwicmV2ZXJzZSIsInNvcnQiLCJqIiwiYW5jaG9yIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRfc3R5bGVzIiwic3R5bGVfc2hlZXRfaWQiLCJzdHlsZXMiLCJhcHBlbmRfc3R5bGVzX3RvIiwiZ2V0X3Jvb3RfZm9yX3N0eWxlIiwiZ2V0RWxlbWVudEJ5SWQiLCJzdHlsZSIsImlkIiwidGV4dENvbnRlbnQiLCJhcHBlbmRfc3R5bGVzaGVldCIsInJvb3QiLCJnZXRSb290Tm9kZSIsIm93bmVyRG9jdW1lbnQiLCJob3N0IiwiYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQiLCJzdHlsZV9lbGVtZW50Iiwic2hlZXQiLCJoZWFkIiwiYXBwZW5kX2h5ZHJhdGlvbiIsImFjdHVhbF9lbmRfY2hpbGQiLCJwYXJlbnROb2RlIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0IiwiaW5zZXJ0X2h5ZHJhdGlvbiIsImRldGFjaCIsInJlbW92ZUNoaWxkIiwiZGVzdHJveV9lYWNoIiwiaXRlcmF0aW9ucyIsImRldGFjaGluZyIsImQiLCJlbGVtZW50X2lzIiwiaXMiLCJvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzIiwiZXhjbHVkZSIsImluZGV4T2YiLCJzdmdfZWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInRleHQiLCJkYXRhIiwiY3JlYXRlVGV4dE5vZGUiLCJzcGFjZSIsImVtcHR5IiwiY29tbWVudCIsImNvbnRlbnQiLCJjcmVhdGVDb21tZW50IiwibGlzdGVuIiwiZXZlbnQiLCJoYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwcmV2ZW50X2RlZmF1bHQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BfcHJvcGFnYXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInNlbGYiLCJ0cnVzdGVkIiwiaXNUcnVzdGVkIiwiYXR0ciIsImF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlIiwic2V0X2F0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiZGVzY3JpcHRvcnMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiX19wcm90b19fIiwiY3NzVGV4dCIsInNldF9zdmdfYXR0cmlidXRlcyIsInNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCIsImRhdGFfbWFwIiwic2V0X2N1c3RvbV9lbGVtZW50X2RhdGEiLCJsb3dlciIsInRvTG93ZXJDYXNlIiwic2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhIiwidGFnIiwidGVzdCIsInhsaW5rX2F0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsImdldF9zdmVsdGVfZGF0YXNldCIsImRhdGFzZXQiLCJzdmVsdGVIIiwiZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUiLCJncm91cCIsIl9fdmFsdWUiLCJjaGVja2VkIiwiQXJyYXkiLCJmcm9tIiwiaW5pdF9iaW5kaW5nX2dyb3VwIiwiX2lucHV0cyIsImlucHV0cyIsImlucHV0IiwiciIsInNwbGljZSIsImluaXRfYmluZGluZ19ncm91cF9keW5hbWljIiwiaW5kZXhlcyIsIl9ncm91cCIsImdldF9iaW5kaW5nX2dyb3VwIiwicmVtb3ZlIiwidSIsIm5ld19pbmRleGVzIiwibmV3X2dyb3VwIiwidG9fbnVtYmVyIiwidGltZV9yYW5nZXNfdG9fYXJyYXkiLCJyYW5nZXMiLCJhcnJheSIsInN0YXJ0IiwiZW5kIiwiaW5pdF9jbGFpbV9pbmZvIiwibm9kZXMiLCJjbGFpbV9pbmZvIiwibGFzdF9pbmRleCIsInRvdGFsX2NsYWltZWQiLCJjbGFpbV9ub2RlIiwicHJlZGljYXRlIiwicHJvY2Vzc19ub2RlIiwiY3JlYXRlX25vZGUiLCJkb250X3VwZGF0ZV9sYXN0X2luZGV4IiwicmVzdWx0X25vZGUiLCJyZXBsYWNlbWVudCIsImNsYWltX2VsZW1lbnRfYmFzZSIsImNyZWF0ZV9lbGVtZW50IiwidiIsImNsYWltX2VsZW1lbnQiLCJjbGFpbV9zdmdfZWxlbWVudCIsImNsYWltX3RleHQiLCJub2RlVHlwZSIsImRhdGFfc3RyIiwic3RhcnRzV2l0aCIsInNwbGl0VGV4dCIsImNsYWltX3NwYWNlIiwiY2xhaW1fY29tbWVudCIsImdldF9jb21tZW50X2lkeCIsImNsYWltX2h0bWxfdGFnIiwiaXNfc3ZnIiwic3RhcnRfaW5kZXgiLCJlbmRfaW5kZXgiLCJIdG1sVGFnSHlkcmF0aW9uIiwiaHRtbF90YWdfbm9kZXMiLCJjbGFpbWVkX25vZGVzIiwibiIsInNldF9kYXRhIiwic2V0X2RhdGFfY29udGVudGVkaXRhYmxlIiwid2hvbGVUZXh0Iiwic2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlIiwiYXR0cl92YWx1ZSIsInNldF9pbnB1dF92YWx1ZSIsInNldF9pbnB1dF90eXBlIiwidHlwZSIsImUiLCJzZXRfc3R5bGUiLCJpbXBvcnRhbnQiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5Iiwic2VsZWN0X29wdGlvbiIsInNlbGVjdCIsIm1vdW50aW5nIiwib3B0aW9uIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4Iiwic2VsZWN0X29wdGlvbnMiLCJzZWxlY3RfdmFsdWUiLCJzZWxlY3RlZF9vcHRpb24iLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0X211bHRpcGxlX3ZhbHVlIiwicXVlcnlTZWxlY3RvckFsbCIsImNyb3Nzb3JpZ2luIiwiaXNfY3Jvc3NvcmlnaW4iLCJwYXJlbnQiLCJlcnJvciIsImFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyIiwiY29tcHV0ZWRfc3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJpZnJhbWUiLCJ0YWJJbmRleCIsInNvdXJjZSIsImNvbnRlbnRXaW5kb3ciLCJvbmxvYWQiLCJyZXNpemVfb2JzZXJ2ZXJfY29udGVudF9ib3giLCJib3giLCJyZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveCIsInJlc2l6ZV9vYnNlcnZlcl9kZXZpY2VfcGl4ZWxfY29udGVudF9ib3giLCJ0b2dnbGVfY2xhc3MiLCJ0b2dnbGUiLCJjbGFzc0xpc3QiLCJjdXN0b21fZXZlbnQiLCJkZXRhaWwiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsIkN1c3RvbUV2ZW50IiwicXVlcnlfc2VsZWN0b3JfYWxsIiwic2VsZWN0b3IiLCJib2R5IiwiaGVhZF9zZWxlY3RvciIsIm5vZGVJZCIsInN0YXJ0ZWQiLCJIdG1sVGFnIiwidCIsImh0bWwiLCJoIiwidGFnTmFtZSIsImlubmVySFRNTCIsImwiLCJhdHRyaWJ1dGVfdG9fb2JqZWN0IiwiZXNjYXBlZCIsInJlZ2V4X2F0dHJpYnV0ZV9jaGFyYWN0ZXJzX3RvX2VzY2FwZSIsImVzY2FwZV9hdHRyaWJ1dGUiLCJTdHJpbmciLCJyZXBsYWNlIiwic3RyaW5naWZ5X3NwcmVhZCIsInN0ciIsImdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMiLCJjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudCIsIm1hbmFnZWRfc3R5bGVzIiwiTWFwIiwiYWN0aXZlIiwiaGFzaCIsImNoYXJDb2RlQXQiLCJjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24iLCJkb2MiLCJpbmZvIiwic3R5bGVzaGVldCIsInJ1bGVzIiwiY3JlYXRlX3J1bGUiLCJkdXJhdGlvbiIsImRlbGF5IiwiZWFzZSIsInVpZCIsInN0ZXAiLCJrZXlmcmFtZXMiLCJydWxlIiwiaW5zZXJ0UnVsZSIsImNzc1J1bGVzIiwiYW5pbWF0aW9uIiwiZGVsZXRlX3J1bGUiLCJwcmV2aW91cyIsIm5leHQiLCJhbmltIiwiZGVsZXRlZCIsImpvaW4iLCJjbGVhcl9ydWxlcyIsIm93bmVyTm9kZSIsImxpbmVhciIsImNyZWF0ZV9hbmltYXRpb24iLCJwYXJhbXMiLCJ0byIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImVhc2luZyIsInN0YXJ0X3RpbWUiLCJ0aWNrIiwiY3NzIiwicnVubmluZyIsInN0b3AiLCJmaXhfcG9zaXRpb24iLCJoZWlnaHQiLCJhZGRfdHJhbnNmb3JtIiwidHJhbnNmb3JtIiwiY3VycmVudF9jb21wb25lbnQiLCJzZXRfY3VycmVudF9jb21wb25lbnQiLCJnZXRfY3VycmVudF9jb21wb25lbnQiLCJiZWZvcmVVcGRhdGUiLCJiZWZvcmVfdXBkYXRlIiwib25Nb3VudCIsIm9uX21vdW50IiwiYWZ0ZXJVcGRhdGUiLCJhZnRlcl91cGRhdGUiLCJvbkRlc3Ryb3kiLCJjcmVhdGVFdmVudERpc3BhdGNoZXIiLCJkZWZhdWx0UHJldmVudGVkIiwic2V0Q29udGV4dCIsImNvbnRleHQiLCJnZXRDb250ZXh0IiwiZ2V0QWxsQ29udGV4dHMiLCJoYXNDb250ZXh0IiwiYnViYmxlIiwiZGlydHlfY29tcG9uZW50cyIsImludHJvcyIsImVuYWJsZWQiLCJiaW5kaW5nX2NhbGxiYWNrcyIsInJlbmRlcl9jYWxsYmFja3MiLCJmbHVzaF9jYWxsYmFja3MiLCJyZXNvbHZlZF9wcm9taXNlIiwicmVzb2x2ZSIsInVwZGF0ZV9zY2hlZHVsZWQiLCJzY2hlZHVsZV91cGRhdGUiLCJmbHVzaCIsImFkZF9yZW5kZXJfY2FsbGJhY2siLCJhZGRfZmx1c2hfY2FsbGJhY2siLCJzZWVuX2NhbGxiYWNrcyIsImZsdXNoaWR4Iiwic2F2ZWRfY29tcG9uZW50IiwidXBkYXRlIiwicG9wIiwiZnJhZ21lbnQiLCJmbHVzaF9yZW5kZXJfY2FsbGJhY2tzIiwiZmlsdGVyZWQiLCJ0YXJnZXRzIiwid2FpdCIsImRpc3BhdGNoIiwiZGlyZWN0aW9uIiwia2luZCIsImRpc3BhdGNoRXZlbnQiLCJvdXRyb2luZyIsIm91dHJvcyIsImdyb3VwX291dHJvcyIsImNoZWNrX291dHJvcyIsInRyYW5zaXRpb25faW4iLCJibG9jayIsImxvY2FsIiwidHJhbnNpdGlvbl9vdXQiLCJvIiwibnVsbF90cmFuc2l0aW9uIiwiY3JlYXRlX2luX3RyYW5zaXRpb24iLCJjb25maWciLCJhbmltYXRpb25fbmFtZSIsImNsZWFudXAiLCJnbyIsImVuZF90aW1lIiwiaW52YWxpZGF0ZSIsImNyZWF0ZV9vdXRfdHJhbnNpdGlvbiIsIm9yaWdpbmFsX2luZXJ0X3ZhbHVlIiwiaW5lcnQiLCJyZXNldCIsImNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24iLCJpbnRybyIsInJ1bm5pbmdfcHJvZ3JhbSIsInBlbmRpbmdfcHJvZ3JhbSIsImNsZWFyX2FuaW1hdGlvbiIsImluaXQiLCJwcm9ncmFtIiwiYWJzIiwib3B0cyIsImhhbmRsZV9wcm9taXNlIiwidG9rZW4iLCJpbmRleCIsInJlc29sdmVkIiwiY2hpbGRfY3R4IiwibmVlZHNfZmx1c2giLCJibG9ja3MiLCJtb3VudCIsImNhdGNoIiwiaGFzQ2F0Y2giLCJwZW5kaW5nIiwidXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaCIsImVuc3VyZV9hcnJheV9saWtlIiwiYXJyYXlfbGlrZV9vcl9pdGVyYXRvciIsImRlc3Ryb3lfYmxvY2siLCJsb29rdXAiLCJvdXRyb19hbmRfZGVzdHJveV9ibG9jayIsImZpeF9hbmRfZGVzdHJveV9ibG9jayIsImZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2siLCJ1cGRhdGVfa2V5ZWRfZWFjaCIsIm9sZF9ibG9ja3MiLCJnZXRfa2V5IiwiZHluYW1pYyIsImxpc3QiLCJjcmVhdGVfZWFjaF9ibG9jayIsImdldF9jb250ZXh0Iiwib2xkX2luZGV4ZXMiLCJuZXdfYmxvY2tzIiwibmV3X2xvb2t1cCIsImRlbHRhcyIsInVwZGF0ZXMiLCJ3aWxsX21vdmUiLCJkaWRfbW92ZSIsImZpcnN0IiwibmV3X2Jsb2NrIiwib2xkX2Jsb2NrIiwibmV3X2tleSIsIm9sZF9rZXkiLCJ2YWxpZGF0ZV9lYWNoX2tleXMiLCJnZXRfc3ByZWFkX3VwZGF0ZSIsImxldmVscyIsInRvX251bGxfb3V0IiwiYWNjb3VudGVkX2ZvciIsImdldF9zcHJlYWRfb2JqZWN0Iiwic3ByZWFkX3Byb3BzIiwiX2Jvb2xlYW5fYXR0cmlidXRlcyIsImJvb2xlYW5fYXR0cmlidXRlcyIsImlzX3ZvaWQiLCJpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciIsInNwcmVhZCIsImF0dHJzX3RvX2FkZCIsImNsYXNzZXNfdG9fYWRkIiwiY2xhc3NlcyIsInN0eWxlc190b19hZGQiLCJjbGFzcyIsInN0eWxlX29iamVjdF90b19zdHJpbmciLCJtZXJnZV9zc3Jfc3R5bGVzIiwic3R5bGVfYXR0cmlidXRlIiwic3R5bGVfZGlyZWN0aXZlIiwic3R5bGVfb2JqZWN0IiwiaW5kaXZpZHVhbF9zdHlsZSIsImNvbG9uX2luZGV4IiwiQVRUUl9SRUdFWCIsIkNPTlRFTlRfUkVHRVgiLCJlc2NhcGUiLCJpc19hdHRyIiwicGF0dGVybiIsImxhc3RJbmRleCIsImNoIiwic3Vic3RyaW5nIiwiZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSIsInNob3VsZF9lc2NhcGUiLCJlc2NhcGVfb2JqZWN0IiwiZWFjaCIsIml0ZW1zIiwibWlzc2luZ19jb21wb25lbnQiLCIkJHJlbmRlciIsInZhbGlkYXRlX2NvbXBvbmVudCIsImRlYnVnIiwidmFsdWVzIiwiY29uc29sZSIsImxvZyIsImNyZWF0ZV9zc3JfY29tcG9uZW50IiwiYmluZGluZ3MiLCJwYXJlbnRfY29tcG9uZW50IiwicmVuZGVyIiwiJCRzbG90cyIsInRpdGxlIiwiY29kZSIsImFkZF9hdHRyaWJ1dGUiLCJib29sZWFuIiwiYXNzaWdubWVudCIsImFkZF9jbGFzc2VzIiwiYWRkX3N0eWxlcyIsImJpbmQiLCJib3VuZCIsImNyZWF0ZV9jb21wb25lbnQiLCJjbGFpbV9jb21wb25lbnQiLCJwYXJlbnRfbm9kZXMiLCJtb3VudF9jb21wb25lbnQiLCJuZXdfb25fZGVzdHJveSIsImRlc3Ryb3lfY29tcG9uZW50IiwibWFrZV9kaXJ0eSIsImZpbGwiLCJpbnN0YW5jZSIsImNyZWF0ZV9mcmFnbWVudCIsIm9uX2Rpc2Nvbm5lY3QiLCJza2lwX2JvdW5kIiwicmVhZHkiLCJoeWRyYXRlIiwiU3ZlbHRlRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiJCRjdG9yIiwiJCRzIiwiJCRjIiwiJCRjbiIsIiQkZCIsIiQkciIsIiQkcF9kIiwiJCRsIiwiJCRsX3UiLCIkJGNvbXBvbmVudEN0b3IiLCJ1c2Vfc2hhZG93X2RvbSIsImF0dGFjaFNoYWRvdyIsIm1vZGUiLCIkb24iLCJjb25uZWN0ZWRDYWxsYmFjayIsImV4aXN0aW5nX3Nsb3RzIiwiJCRnX3AiLCJnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUiLCJzaGFkb3dSb290IiwicmVmbGVjdF9hdHRyaWJ1dGVzIiwicmVmbGVjdCIsImF0dHJpYnV0ZV92YWx1ZSIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsIl9vbGRWYWx1ZSIsIm5ld1ZhbHVlIiwiJHNldCIsImRpc2Nvbm5lY3RlZENhbGxiYWNrIiwiJGRlc3Ryb3kiLCJhdHRyaWJ1dGVfbmFtZSIsImZpbmQiLCJwcm9wc19kZWZpbml0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlIiwiY3JlYXRlX2N1c3RvbV9lbGVtZW50IiwiQ29tcG9uZW50IiwiYWNjZXNzb3JzIiwiZXh0ZW5kIiwiQ2xhc3MiLCJvYnNlcnZlZEF0dHJpYnV0ZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImFjY2Vzc29yIiwiU3ZlbHRlQ29tcG9uZW50IiwiJCRzZXQiLCJWRVJTSU9OIiwiZGlzcGF0Y2hfZGV2IiwidmVyc2lvbiIsImFwcGVuZF9kZXYiLCJhcHBlbmRfaHlkcmF0aW9uX2RldiIsImluc2VydF9kZXYiLCJpbnNlcnRfaHlkcmF0aW9uX2RldiIsImRldGFjaF9kZXYiLCJkZXRhY2hfYmV0d2Vlbl9kZXYiLCJiZWZvcmUiLCJhZnRlciIsImRldGFjaF9iZWZvcmVfZGV2IiwicHJldmlvdXNTaWJsaW5nIiwiZGV0YWNoX2FmdGVyX2RldiIsImxpc3Rlbl9kZXYiLCJoYXNfcHJldmVudF9kZWZhdWx0IiwiaGFzX3N0b3BfcHJvcGFnYXRpb24iLCJoYXNfc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24iLCJtb2RpZmllcnMiLCJkaXNwb3NlIiwiYXR0cl9kZXYiLCJwcm9wX2RldiIsInByb3BlcnR5IiwiZGF0YXNldF9kZXYiLCJzZXRfZGF0YV9kZXYiLCJzZXRfZGF0YV9jb250ZW50ZWRpdGFibGVfZGV2Iiwic2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlX2RldiIsImVuc3VyZV9hcnJheV9saWtlX2RldiIsImFyZyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidmFsaWRhdGVfc2xvdHMiLCJzbG90X2tleSIsIndhcm4iLCJ2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQiLCJpc19zdHJpbmciLCJ2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCIsImNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2RldiIsImVycm9yX21lc3NhZ2UiLCJlcnIiLCJtZXNzYWdlIiwiU3ZlbHRlQ29tcG9uZW50RGV2IiwiJCRwcm9wX2RlZiIsIiQkZXZlbnRzX2RlZiIsIiQkc2xvdF9kZWYiLCIkJGlubGluZSIsIiRjYXB0dXJlX3N0YXRlIiwiJGluamVjdF9zdGF0ZSIsIlN2ZWx0ZUNvbXBvbmVudFR5cGVkIiwibG9vcF9ndWFyZCIsInRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3267\n")},6100:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  o: function() { return /* reexport */ spring; }\n});\n\n// UNUSED EXPORTS: tweened\n\n// EXTERNAL MODULE: ./node_modules/svelte/src/runtime/internal/index.js + 18 modules\nvar internal = __webpack_require__(3267);\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/store/index.js\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nfunction readable(value, start) {\n  return {\n    subscribe: store_writable(value, start).subscribe\n  };\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nfunction store_writable(value, start = internal/* noop */.lQ1) {\n  /** @type {import('./public.js').Unsubscriber} */\n  let stop;\n  /** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n  const subscribers = new Set();\n  /** @param {T} new_value\n   * @returns {void}\n   */\n  function set(new_value) {\n    if ((0,internal/* safe_not_equal */.jXN)(value, new_value)) {\n      value = new_value;\n      if (stop) {\n        // store is ready\n        const run_queue = !subscriber_queue.length;\n        for (const subscriber of subscribers) {\n          subscriber[1]();\n          subscriber_queue.push(subscriber, value);\n        }\n        if (run_queue) {\n          for (let i = 0; i < subscriber_queue.length; i += 2) {\n            subscriber_queue[i][0](subscriber_queue[i + 1]);\n          }\n          subscriber_queue.length = 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import('./public.js').Updater<T>} fn\n   * @returns {void}\n   */\n  function update(fn) {\n    set(fn(value));\n  }\n\n  /**\n   * @param {import('./public.js').Subscriber<T>} run\n   * @param {import('./private.js').Invalidator<T>} [invalidate]\n   * @returns {import('./public.js').Unsubscriber}\n   */\n  function subscribe(run, invalidate = internal/* noop */.lQ1) {\n    /** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n    const subscriber = [run, invalidate];\n    subscribers.add(subscriber);\n    if (subscribers.size === 1) {\n      stop = start(set, update) || internal/* noop */.lQ1;\n    }\n    run(value);\n    return () => {\n      subscribers.delete(subscriber);\n      if (subscribers.size === 0 && stop) {\n        stop();\n        stop = null;\n      }\n    };\n  }\n  return {\n    set,\n    update,\n    subscribe\n  };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nfunction derived(stores, fn, initial_value) {\n  const single = !Array.isArray(stores);\n  /** @type {Array<import('./public.js').Readable<any>>} */\n  const stores_array = single ? [stores] : stores;\n  if (!stores_array.every(Boolean)) {\n    throw new Error('derived() expects stores as input, got a falsy value');\n  }\n  const auto = fn.length < 2;\n  return readable(initial_value, (set, update) => {\n    let started = false;\n    const values = [];\n    let pending = 0;\n    let cleanup = noop;\n    const sync = () => {\n      if (pending) {\n        return;\n      }\n      cleanup();\n      const result = fn(single ? values[0] : values, set, update);\n      if (auto) {\n        set(result);\n      } else {\n        cleanup = is_function(result) ? result : noop;\n      }\n    };\n    const unsubscribers = stores_array.map((store, i) => subscribe(store, value => {\n      values[i] = value;\n      pending &= ~(1 << i);\n      if (started) {\n        sync();\n      }\n    }, () => {\n      pending |= 1 << i;\n    }));\n    started = true;\n    sync();\n    return function stop() {\n      run_all(unsubscribers);\n      cleanup();\n      // We need to set this to false because callbacks can still happen despite having unsubscribed:\n      // Callbacks might already be placed in the queue which doesn't know it should no longer\n      // invoke this derived store.\n      started = false;\n    };\n  });\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nfunction readonly(store) {\n  return {\n    subscribe: store.subscribe.bind(store)\n  };\n}\n\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/motion/utils.js\n/**\n * @param {any} obj\n * @returns {boolean}\n */\nfunction utils_is_date(obj) {\n  return Object.prototype.toString.call(obj) === '[object Date]';\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/motion/spring.js\n\n\n\n\n/**\n * @template T\n * @param {import('./private.js').TickContext<T>} ctx\n * @param {T} last_value\n * @param {T} current_value\n * @param {T} target_value\n * @returns {T}\n */\nfunction tick_spring(ctx, last_value, current_value, target_value) {\n  if (typeof current_value === 'number' || utils_is_date(current_value)) {\n    // @ts-ignore\n    const delta = target_value - current_value;\n    // @ts-ignore\n    const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0\n    const spring = ctx.opts.stiffness * delta;\n    const damper = ctx.opts.damping * velocity;\n    const acceleration = (spring - damper) * ctx.inv_mass;\n    const d = (velocity + acceleration) * ctx.dt;\n    if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {\n      return target_value; // settled\n    } else {\n      ctx.settled = false; // signal loop to keep ticking\n      // @ts-ignore\n      return utils_is_date(current_value) ? new Date(current_value.getTime() + d) : current_value + d;\n    }\n  } else if (Array.isArray(current_value)) {\n    // @ts-ignore\n    return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));\n  } else if (typeof current_value === 'object') {\n    const next_value = {};\n    for (const k in current_value) {\n      // @ts-ignore\n      next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);\n    }\n    // @ts-ignore\n    return next_value;\n  } else {\n    throw new Error(`Cannot spring ${typeof current_value} values`);\n  }\n}\n\n/**\n * The spring function in Svelte creates a store whose value is animated, with a motion that simulates the behavior of a spring. This means when the value changes, instead of transitioning at a steady rate, it \"bounces\" like a spring would, depending on the physics parameters provided. This adds a level of realism to the transitions and can enhance the user experience.\n *\n * https://svelte.dev/docs/svelte-motion#spring\n * @template [T=any]\n * @param {T} [value]\n * @param {import('./private.js').SpringOpts} [opts]\n * @returns {import('./public.js').Spring<T>}\n */\nfunction spring(value, opts = {}) {\n  const store = store_writable(value);\n  const {\n    stiffness = 0.15,\n    damping = 0.8,\n    precision = 0.01\n  } = opts;\n  /** @type {number} */\n  let last_time;\n  /** @type {import('../internal/private.js').Task} */\n  let task;\n  /** @type {object} */\n  let current_token;\n  /** @type {T} */\n  let last_value = value;\n  /** @type {T} */\n  let target_value = value;\n  let inv_mass = 1;\n  let inv_mass_recovery_rate = 0;\n  let cancel_task = false;\n  /**\n   * @param {T} new_value\n   * @param {import('./private.js').SpringUpdateOpts} opts\n   * @returns {Promise<void>}\n   */\n  function set(new_value, opts = {}) {\n    target_value = new_value;\n    const token = current_token = {};\n    if (value == null || opts.hard || spring.stiffness >= 1 && spring.damping >= 1) {\n      cancel_task = true; // cancel any running animation\n      last_time = (0,internal/* now */.tB5)();\n      last_value = new_value;\n      store.set(value = target_value);\n      return Promise.resolve();\n    } else if (opts.soft) {\n      const rate = opts.soft === true ? 0.5 : +opts.soft;\n      inv_mass_recovery_rate = 1 / (rate * 60);\n      inv_mass = 0; // infinite mass, unaffected by spring forces\n    }\n    if (!task) {\n      last_time = (0,internal/* now */.tB5)();\n      cancel_task = false;\n      task = (0,internal/* loop */.HWo)(now => {\n        if (cancel_task) {\n          cancel_task = false;\n          task = null;\n          return false;\n        }\n        inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);\n        const ctx = {\n          inv_mass,\n          opts: spring,\n          settled: true,\n          dt: (now - last_time) * 60 / 1000\n        };\n        const next_value = tick_spring(ctx, last_value, value, target_value);\n        last_time = now;\n        last_value = value;\n        store.set(value = next_value);\n        if (ctx.settled) {\n          task = null;\n        }\n        return !ctx.settled;\n      });\n    }\n    return new Promise(fulfil => {\n      task.promise.then(() => {\n        if (token === current_token) fulfil();\n      });\n    });\n  }\n  /** @type {import('./public.js').Spring<T>} */\n  const spring = {\n    set,\n    update: (fn, opts) => set(fn(target_value, value), opts),\n    subscribe: store.subscribe,\n    stiffness,\n    damping,\n    precision\n  };\n  return spring;\n}\n// EXTERNAL MODULE: ./node_modules/svelte/src/runtime/easing/index.js\nvar easing = __webpack_require__(3450);\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/motion/tweened.js\n\n\n\n\n\n/** @returns {(t: any) => any} */\nfunction get_interpolator(a, b) {\n  if (a === b || a !== a) return () => a;\n  const type = typeof a;\n  if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {\n    throw new Error('Cannot interpolate values of different type');\n  }\n  if (Array.isArray(a)) {\n    const arr = b.map((bi, i) => {\n      return get_interpolator(a[i], bi);\n    });\n    return t => arr.map(fn => fn(t));\n  }\n  if (type === 'object') {\n    if (!a || !b) throw new Error('Object cannot be null');\n    if (is_date(a) && is_date(b)) {\n      a = a.getTime();\n      b = b.getTime();\n      const delta = b - a;\n      return t => new Date(a + t * delta);\n    }\n    const keys = Object.keys(b);\n    const interpolators = {};\n    keys.forEach(key => {\n      interpolators[key] = get_interpolator(a[key], b[key]);\n    });\n    return t => {\n      const result = {};\n      keys.forEach(key => {\n        result[key] = interpolators[key](t);\n      });\n      return result;\n    };\n  }\n  if (type === 'number') {\n    const delta = b - a;\n    return t => a + t * delta;\n  }\n  throw new Error(`Cannot interpolate ${type} values`);\n}\n\n/**\n * A tweened store in Svelte is a special type of store that provides smooth transitions between state values over time.\n *\n * https://svelte.dev/docs/svelte-motion#tweened\n * @template T\n * @param {T} [value]\n * @param {import('./private.js').TweenedOptions<T>} [defaults]\n * @returns {import('./public.js').Tweened<T>}\n */\nfunction tweened(value, defaults = {}) {\n  const store = writable(value);\n  /** @type {import('../internal/private.js').Task} */\n  let task;\n  let target_value = value;\n  /**\n   * @param {T} new_value\n   * @param {import('./private.js').TweenedOptions<T>} [opts]\n   */\n  function set(new_value, opts) {\n    if (value == null) {\n      store.set(value = new_value);\n      return Promise.resolve();\n    }\n    target_value = new_value;\n    let previous_task = task;\n    let started = false;\n    let {\n      delay = 0,\n      duration = 400,\n      easing = linear,\n      interpolate = get_interpolator\n    } = assign(assign({}, defaults), opts);\n    if (duration === 0) {\n      if (previous_task) {\n        previous_task.abort();\n        previous_task = null;\n      }\n      store.set(value = target_value);\n      return Promise.resolve();\n    }\n    const start = now() + delay;\n    let fn;\n    task = loop(now => {\n      if (now < start) return true;\n      if (!started) {\n        fn = interpolate(value, new_value);\n        if (typeof duration === 'function') duration = duration(value, new_value);\n        started = true;\n      }\n      if (previous_task) {\n        previous_task.abort();\n        previous_task = null;\n      }\n      const elapsed = now - start;\n      if (elapsed > ( /** @type {number} */duration)) {\n        store.set(value = new_value);\n        return false;\n      }\n      // @ts-ignore\n      store.set(value = fn(easing(elapsed / duration)));\n      return true;\n    });\n    return task.promise;\n  }\n  return {\n    set,\n    update: (fn, opts) => set(fn(target_value, value), opts),\n    subscribe: store.subscribe\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/motion/index.js\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRThDLEtBQUssQ0FBQzlDO0VBQ2xCLENBQUM7QUFDRixDOztBQ25INEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL3N0b3JlL2luZGV4LmpzP2ZiMjgiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9tb3Rpb24vdXRpbHMuanM/YzQ3YyIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL21vdGlvbi9zcHJpbmcuanM/NDc1NiIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL21vdGlvbi90d2VlbmVkLmpzP2MwMTgiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9tb3Rpb24vaW5kZXguanM/ZDc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRydW5fYWxsLFxuXHRzdWJzY3JpYmUsXG5cdG5vb3AsXG5cdHNhZmVfbm90X2VxdWFsLFxuXHRpc19mdW5jdGlvbixcblx0Z2V0X3N0b3JlX3ZhbHVlXG59IGZyb20gJy4uL2ludGVybmFsL2luZGV4LmpzJztcblxuY29uc3Qgc3Vic2NyaWJlcl9xdWV1ZSA9IFtdO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNyZWFkYWJsZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5TdGFydFN0b3BOb3RpZmllcjxUPn0gW3N0YXJ0XVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlKHZhbHVlLCBzdGFydCkge1xuXHRyZXR1cm4ge1xuXHRcdHN1YnNjcmliZTogd3JpdGFibGUodmFsdWUsIHN0YXJ0KS5zdWJzY3JpYmVcblx0fTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgV3JpdGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIGJvdGggdXBkYXRpbmcgYW5kIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSN3cml0YWJsZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5TdGFydFN0b3BOb3RpZmllcjxUPn0gW3N0YXJ0XVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Xcml0YWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRhYmxlKHZhbHVlLCBzdGFydCA9IG5vb3ApIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHVibGljLmpzJykuVW5zdWJzY3JpYmVyfSAqL1xuXHRsZXQgc3RvcDtcblx0LyoqIEB0eXBlIHtTZXQ8aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGU8VD4+fSAqL1xuXHRjb25zdCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcblx0LyoqIEBwYXJhbSB7VH0gbmV3X3ZhbHVlXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuXHRcdGlmIChzYWZlX25vdF9lcXVhbCh2YWx1ZSwgbmV3X3ZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0XHRpZiAoc3RvcCkge1xuXHRcdFx0XHQvLyBzdG9yZSBpcyByZWFkeVxuXHRcdFx0XHRjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic2NyaWJlciBvZiBzdWJzY3JpYmVycykge1xuXHRcdFx0XHRcdHN1YnNjcmliZXJbMV0oKTtcblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLnB1c2goc3Vic2NyaWJlciwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5fcXVldWUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuVXBkYXRlcjxUPn0gZm5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGUoZm4pIHtcblx0XHRzZXQoZm4odmFsdWUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5TdWJzY3JpYmVyPFQ+fSBydW5cblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkludmFsaWRhdG9yPFQ+fSBbaW52YWxpZGF0ZV1cblx0ICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5VbnN1YnNjcmliZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiBzdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlID0gbm9vcCkge1xuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGU8VD59ICovXG5cdFx0Y29uc3Qgc3Vic2NyaWJlciA9IFtydW4sIGludmFsaWRhdGVdO1xuXHRcdHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcblx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMSkge1xuXHRcdFx0c3RvcCA9IHN0YXJ0KHNldCwgdXBkYXRlKSB8fCBub29wO1xuXHRcdH1cblx0XHRydW4odmFsdWUpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cdFx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCAmJiBzdG9wKSB7XG5cdFx0XHRcdHN0b3AoKTtcblx0XHRcdFx0c3RvcCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG59XG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjZGVyaXZlZFxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXMgLSBpbnB1dCBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXNWYWx1ZXM8Uz4sIHNldDogKHZhbHVlOiBUKSA9PiB2b2lkLCB1cGRhdGU6IChmbjogaW1wb3J0KCcuL3B1YmxpYy5qcycpLlVwZGF0ZXI8VD4pID0+IHZvaWQpID0+IGltcG9ydCgnLi9wdWJsaWMuanMnKS5VbnN1YnNjcmliZXIgfCB2b2lkfSBmbiAtIGZ1bmN0aW9uIGNhbGxiYWNrIHRoYXQgYWdncmVnYXRlcyB0aGUgdmFsdWVzXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXSAtIGluaXRpYWwgdmFsdWVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cblxuLyoqXG4gKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxuICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNkZXJpdmVkXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N9IHN0b3JlcyAtIGlucHV0IHN0b3Jlc1xuICogQHBhcmFtIHsodmFsdWVzOiBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc1ZhbHVlczxTPikgPT4gVH0gZm4gLSBmdW5jdGlvbiBjYWxsYmFjayB0aGF0IGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlc1xuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV0gLSBpbml0aWFsIHZhbHVlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcblx0Y29uc3Qgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoc3RvcmVzKTtcblx0LyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8YW55Pj59ICovXG5cdGNvbnN0IHN0b3Jlc19hcnJheSA9IHNpbmdsZSA/IFtzdG9yZXNdIDogc3RvcmVzO1xuXHRpZiAoIXN0b3Jlc19hcnJheS5ldmVyeShCb29sZWFuKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZGVyaXZlZCgpIGV4cGVjdHMgc3RvcmVzIGFzIGlucHV0LCBnb3QgYSBmYWxzeSB2YWx1ZScpO1xuXHR9XG5cdGNvbnN0IGF1dG8gPSBmbi5sZW5ndGggPCAyO1xuXHRyZXR1cm4gcmVhZGFibGUoaW5pdGlhbF92YWx1ZSwgKHNldCwgdXBkYXRlKSA9PiB7XG5cdFx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRsZXQgcGVuZGluZyA9IDA7XG5cdFx0bGV0IGNsZWFudXAgPSBub29wO1xuXHRcdGNvbnN0IHN5bmMgPSAoKSA9PiB7XG5cdFx0XHRpZiAocGVuZGluZykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBmbihzaW5nbGUgPyB2YWx1ZXNbMF0gOiB2YWx1ZXMsIHNldCwgdXBkYXRlKTtcblx0XHRcdGlmIChhdXRvKSB7XG5cdFx0XHRcdHNldChyZXN1bHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xlYW51cCA9IGlzX2Z1bmN0aW9uKHJlc3VsdCkgPyByZXN1bHQgOiBub29wO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgdW5zdWJzY3JpYmVycyA9IHN0b3Jlc19hcnJheS5tYXAoKHN0b3JlLCBpKSA9PlxuXHRcdFx0c3Vic2NyaWJlKFxuXHRcdFx0XHRzdG9yZSxcblx0XHRcdFx0KHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dmFsdWVzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0cGVuZGluZyAmPSB+KDEgPDwgaSk7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0ZWQpIHtcblx0XHRcdFx0XHRcdHN5bmMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCgpID0+IHtcblx0XHRcdFx0XHRwZW5kaW5nIHw9IDEgPDwgaTtcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdCk7XG5cdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0c3luYygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuXHRcdFx0cnVuX2FsbCh1bnN1YnNjcmliZXJzKTtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdC8vIFdlIG5lZWQgdG8gc2V0IHRoaXMgdG8gZmFsc2UgYmVjYXVzZSBjYWxsYmFja3MgY2FuIHN0aWxsIGhhcHBlbiBkZXNwaXRlIGhhdmluZyB1bnN1YnNjcmliZWQ6XG5cdFx0XHQvLyBDYWxsYmFja3MgbWlnaHQgYWxyZWFkeSBiZSBwbGFjZWQgaW4gdGhlIHF1ZXVlIHdoaWNoIGRvZXNuJ3Qga25vdyBpdCBzaG91bGQgbm8gbG9uZ2VyXG5cdFx0XHQvLyBpbnZva2UgdGhpcyBkZXJpdmVkIHN0b3JlLlxuXHRcdFx0c3RhcnRlZCA9IGZhbHNlO1xuXHRcdH07XG5cdH0pO1xufVxuXG4vKipcbiAqIFRha2VzIGEgc3RvcmUgYW5kIHJldHVybnMgYSBuZXcgb25lIGRlcml2ZWQgZnJvbSB0aGUgb2xkIG9uZSB0aGF0IGlzIHJlYWRhYmxlLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNyZWFkb25seVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fSBzdG9yZSAgLSBzdG9yZSB0byBtYWtlIHJlYWRvbmx5XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZG9ubHkoc3RvcmUpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZS5iaW5kKHN0b3JlKVxuXHR9O1xufVxuXG5leHBvcnQgeyBnZXRfc3RvcmVfdmFsdWUgYXMgZ2V0IH07XG4iLCIvKipcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZGF0ZShvYmopIHtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG59XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJy4uL3N0b3JlL2luZGV4LmpzJztcbmltcG9ydCB7IGxvb3AsIG5vdyB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4LmpzJztcbmltcG9ydCB7IGlzX2RhdGUgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlRpY2tDb250ZXh0PFQ+fSBjdHhcbiAqIEBwYXJhbSB7VH0gbGFzdF92YWx1ZVxuICogQHBhcmFtIHtUfSBjdXJyZW50X3ZhbHVlXG4gKiBAcGFyYW0ge1R9IHRhcmdldF92YWx1ZVxuICogQHJldHVybnMge1R9XG4gKi9cbmZ1bmN0aW9uIHRpY2tfc3ByaW5nKGN0eCwgbGFzdF92YWx1ZSwgY3VycmVudF92YWx1ZSwgdGFyZ2V0X3ZhbHVlKSB7XG5cdGlmICh0eXBlb2YgY3VycmVudF92YWx1ZSA9PT0gJ251bWJlcicgfHwgaXNfZGF0ZShjdXJyZW50X3ZhbHVlKSkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRjb25zdCBkZWx0YSA9IHRhcmdldF92YWx1ZSAtIGN1cnJlbnRfdmFsdWU7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGNvbnN0IHZlbG9jaXR5ID0gKGN1cnJlbnRfdmFsdWUgLSBsYXN0X3ZhbHVlKSAvIChjdHguZHQgfHwgMSAvIDYwKTsgLy8gZ3VhcmQgZGl2IGJ5IDBcblx0XHRjb25zdCBzcHJpbmcgPSBjdHgub3B0cy5zdGlmZm5lc3MgKiBkZWx0YTtcblx0XHRjb25zdCBkYW1wZXIgPSBjdHgub3B0cy5kYW1waW5nICogdmVsb2NpdHk7XG5cdFx0Y29uc3QgYWNjZWxlcmF0aW9uID0gKHNwcmluZyAtIGRhbXBlcikgKiBjdHguaW52X21hc3M7XG5cdFx0Y29uc3QgZCA9ICh2ZWxvY2l0eSArIGFjY2VsZXJhdGlvbikgKiBjdHguZHQ7XG5cdFx0aWYgKE1hdGguYWJzKGQpIDwgY3R4Lm9wdHMucHJlY2lzaW9uICYmIE1hdGguYWJzKGRlbHRhKSA8IGN0eC5vcHRzLnByZWNpc2lvbikge1xuXHRcdFx0cmV0dXJuIHRhcmdldF92YWx1ZTsgLy8gc2V0dGxlZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguc2V0dGxlZCA9IGZhbHNlOyAvLyBzaWduYWwgbG9vcCB0byBrZWVwIHRpY2tpbmdcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHJldHVybiBpc19kYXRlKGN1cnJlbnRfdmFsdWUpID8gbmV3IERhdGUoY3VycmVudF92YWx1ZS5nZXRUaW1lKCkgKyBkKSA6IGN1cnJlbnRfdmFsdWUgKyBkO1xuXHRcdH1cblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRfdmFsdWUpKSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBjdXJyZW50X3ZhbHVlLm1hcCgoXywgaSkgPT5cblx0XHRcdHRpY2tfc3ByaW5nKGN0eCwgbGFzdF92YWx1ZVtpXSwgY3VycmVudF92YWx1ZVtpXSwgdGFyZ2V0X3ZhbHVlW2ldKVxuXHRcdCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGN1cnJlbnRfdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cdFx0Y29uc3QgbmV4dF92YWx1ZSA9IHt9O1xuXHRcdGZvciAoY29uc3QgayBpbiBjdXJyZW50X3ZhbHVlKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRuZXh0X3ZhbHVlW2tdID0gdGlja19zcHJpbmcoY3R4LCBsYXN0X3ZhbHVlW2tdLCBjdXJyZW50X3ZhbHVlW2tdLCB0YXJnZXRfdmFsdWVba10pO1xuXHRcdH1cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIG5leHRfdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3ByaW5nICR7dHlwZW9mIGN1cnJlbnRfdmFsdWV9IHZhbHVlc2ApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHNwcmluZyBmdW5jdGlvbiBpbiBTdmVsdGUgY3JlYXRlcyBhIHN0b3JlIHdob3NlIHZhbHVlIGlzIGFuaW1hdGVkLCB3aXRoIGEgbW90aW9uIHRoYXQgc2ltdWxhdGVzIHRoZSBiZWhhdmlvciBvZiBhIHNwcmluZy4gVGhpcyBtZWFucyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLCBpbnN0ZWFkIG9mIHRyYW5zaXRpb25pbmcgYXQgYSBzdGVhZHkgcmF0ZSwgaXQgXCJib3VuY2VzXCIgbGlrZSBhIHNwcmluZyB3b3VsZCwgZGVwZW5kaW5nIG9uIHRoZSBwaHlzaWNzIHBhcmFtZXRlcnMgcHJvdmlkZWQuIFRoaXMgYWRkcyBhIGxldmVsIG9mIHJlYWxpc20gdG8gdGhlIHRyYW5zaXRpb25zIGFuZCBjYW4gZW5oYW5jZSB0aGUgdXNlciBleHBlcmllbmNlLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1tb3Rpb24jc3ByaW5nXG4gKiBAdGVtcGxhdGUgW1Q9YW55XVxuICogQHBhcmFtIHtUfSBbdmFsdWVdXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3ByaW5nT3B0c30gW29wdHNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlNwcmluZzxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwcmluZyh2YWx1ZSwgb3B0cyA9IHt9KSB7XG5cdGNvbnN0IHN0b3JlID0gd3JpdGFibGUodmFsdWUpO1xuXHRjb25zdCB7IHN0aWZmbmVzcyA9IDAuMTUsIGRhbXBpbmcgPSAwLjgsIHByZWNpc2lvbiA9IDAuMDEgfSA9IG9wdHM7XG5cdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHRsZXQgbGFzdF90aW1lO1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwvcHJpdmF0ZS5qcycpLlRhc2t9ICovXG5cdGxldCB0YXNrO1xuXHQvKiogQHR5cGUge29iamVjdH0gKi9cblx0bGV0IGN1cnJlbnRfdG9rZW47XG5cdC8qKiBAdHlwZSB7VH0gKi9cblx0bGV0IGxhc3RfdmFsdWUgPSB2YWx1ZTtcblx0LyoqIEB0eXBlIHtUfSAqL1xuXHRsZXQgdGFyZ2V0X3ZhbHVlID0gdmFsdWU7XG5cdGxldCBpbnZfbWFzcyA9IDE7XG5cdGxldCBpbnZfbWFzc19yZWNvdmVyeV9yYXRlID0gMDtcblx0bGV0IGNhbmNlbF90YXNrID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R9IG5ld192YWx1ZVxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3ByaW5nVXBkYXRlT3B0c30gb3B0c1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0ICovXG5cdGZ1bmN0aW9uIHNldChuZXdfdmFsdWUsIG9wdHMgPSB7fSkge1xuXHRcdHRhcmdldF92YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRjb25zdCB0b2tlbiA9IChjdXJyZW50X3Rva2VuID0ge30pO1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IG9wdHMuaGFyZCB8fCAoc3ByaW5nLnN0aWZmbmVzcyA+PSAxICYmIHNwcmluZy5kYW1waW5nID49IDEpKSB7XG5cdFx0XHRjYW5jZWxfdGFzayA9IHRydWU7IC8vIGNhbmNlbCBhbnkgcnVubmluZyBhbmltYXRpb25cblx0XHRcdGxhc3RfdGltZSA9IG5vdygpO1xuXHRcdFx0bGFzdF92YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRcdHN0b3JlLnNldCgodmFsdWUgPSB0YXJnZXRfdmFsdWUpKTtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHR9IGVsc2UgaWYgKG9wdHMuc29mdCkge1xuXHRcdFx0Y29uc3QgcmF0ZSA9IG9wdHMuc29mdCA9PT0gdHJ1ZSA/IDAuNSA6ICtvcHRzLnNvZnQ7XG5cdFx0XHRpbnZfbWFzc19yZWNvdmVyeV9yYXRlID0gMSAvIChyYXRlICogNjApO1xuXHRcdFx0aW52X21hc3MgPSAwOyAvLyBpbmZpbml0ZSBtYXNzLCB1bmFmZmVjdGVkIGJ5IHNwcmluZyBmb3JjZXNcblx0XHR9XG5cdFx0aWYgKCF0YXNrKSB7XG5cdFx0XHRsYXN0X3RpbWUgPSBub3coKTtcblx0XHRcdGNhbmNlbF90YXNrID0gZmFsc2U7XG5cdFx0XHR0YXNrID0gbG9vcCgobm93KSA9PiB7XG5cdFx0XHRcdGlmIChjYW5jZWxfdGFzaykge1xuXHRcdFx0XHRcdGNhbmNlbF90YXNrID0gZmFsc2U7XG5cdFx0XHRcdFx0dGFzayA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGludl9tYXNzID0gTWF0aC5taW4oaW52X21hc3MgKyBpbnZfbWFzc19yZWNvdmVyeV9yYXRlLCAxKTtcblx0XHRcdFx0Y29uc3QgY3R4ID0ge1xuXHRcdFx0XHRcdGludl9tYXNzLFxuXHRcdFx0XHRcdG9wdHM6IHNwcmluZyxcblx0XHRcdFx0XHRzZXR0bGVkOiB0cnVlLFxuXHRcdFx0XHRcdGR0OiAoKG5vdyAtIGxhc3RfdGltZSkgKiA2MCkgLyAxMDAwXG5cdFx0XHRcdH07XG5cdFx0XHRcdGNvbnN0IG5leHRfdmFsdWUgPSB0aWNrX3NwcmluZyhjdHgsIGxhc3RfdmFsdWUsIHZhbHVlLCB0YXJnZXRfdmFsdWUpO1xuXHRcdFx0XHRsYXN0X3RpbWUgPSBub3c7XG5cdFx0XHRcdGxhc3RfdmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0c3RvcmUuc2V0KCh2YWx1ZSA9IG5leHRfdmFsdWUpKTtcblx0XHRcdFx0aWYgKGN0eC5zZXR0bGVkKSB7XG5cdFx0XHRcdFx0dGFzayA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICFjdHguc2V0dGxlZDtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbCkgPT4ge1xuXHRcdFx0dGFzay5wcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAodG9rZW4gPT09IGN1cnJlbnRfdG9rZW4pIGZ1bGZpbCgpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3ByaW5nPFQ+fSAqL1xuXHRjb25zdCBzcHJpbmcgPSB7XG5cdFx0c2V0LFxuXHRcdHVwZGF0ZTogKGZuLCBvcHRzKSA9PiBzZXQoZm4odGFyZ2V0X3ZhbHVlLCB2YWx1ZSksIG9wdHMpLFxuXHRcdHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLFxuXHRcdHN0aWZmbmVzcyxcblx0XHRkYW1waW5nLFxuXHRcdHByZWNpc2lvblxuXHR9O1xuXHRyZXR1cm4gc3ByaW5nO1xufVxuIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICcuLi9zdG9yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBhc3NpZ24sIGxvb3AsIG5vdyB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4LmpzJztcbmltcG9ydCB7IGxpbmVhciB9IGZyb20gJy4uL2Vhc2luZy9pbmRleC5qcyc7XG5pbXBvcnQgeyBpc19kYXRlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qKiBAcmV0dXJucyB7KHQ6IGFueSkgPT4gYW55fSAqL1xuZnVuY3Rpb24gZ2V0X2ludGVycG9sYXRvcihhLCBiKSB7XG5cdGlmIChhID09PSBiIHx8IGEgIT09IGEpIHJldHVybiAoKSA9PiBhO1xuXHRjb25zdCB0eXBlID0gdHlwZW9mIGE7XG5cdGlmICh0eXBlICE9PSB0eXBlb2YgYiB8fCBBcnJheS5pc0FycmF5KGEpICE9PSBBcnJheS5pc0FycmF5KGIpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW50ZXJwb2xhdGUgdmFsdWVzIG9mIGRpZmZlcmVudCB0eXBlJyk7XG5cdH1cblx0aWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcblx0XHRjb25zdCBhcnIgPSBiLm1hcCgoYmksIGkpID0+IHtcblx0XHRcdHJldHVybiBnZXRfaW50ZXJwb2xhdG9yKGFbaV0sIGJpKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gKHQpID0+IGFyci5tYXAoKGZuKSA9PiBmbih0KSk7XG5cdH1cblx0aWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0aWYgKCFhIHx8ICFiKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBjYW5ub3QgYmUgbnVsbCcpO1xuXHRcdGlmIChpc19kYXRlKGEpICYmIGlzX2RhdGUoYikpIHtcblx0XHRcdGEgPSBhLmdldFRpbWUoKTtcblx0XHRcdGIgPSBiLmdldFRpbWUoKTtcblx0XHRcdGNvbnN0IGRlbHRhID0gYiAtIGE7XG5cdFx0XHRyZXR1cm4gKHQpID0+IG5ldyBEYXRlKGEgKyB0ICogZGVsdGEpO1xuXHRcdH1cblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYik7XG5cdFx0Y29uc3QgaW50ZXJwb2xhdG9ycyA9IHt9O1xuXHRcdGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0XHRpbnRlcnBvbGF0b3JzW2tleV0gPSBnZXRfaW50ZXJwb2xhdG9yKGFba2V5XSwgYltrZXldKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gKHQpID0+IHtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRcdFx0a2V5cy5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRcdFx0cmVzdWx0W2tleV0gPSBpbnRlcnBvbGF0b3JzW2tleV0odCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRjb25zdCBkZWx0YSA9IGIgLSBhO1xuXHRcdHJldHVybiAodCkgPT4gYSArIHQgKiBkZWx0YTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbnRlcnBvbGF0ZSAke3R5cGV9IHZhbHVlc2ApO1xufVxuXG4vKipcbiAqIEEgdHdlZW5lZCBzdG9yZSBpbiBTdmVsdGUgaXMgYSBzcGVjaWFsIHR5cGUgb2Ygc3RvcmUgdGhhdCBwcm92aWRlcyBzbW9vdGggdHJhbnNpdGlvbnMgYmV0d2VlbiBzdGF0ZSB2YWx1ZXMgb3ZlciB0aW1lLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1tb3Rpb24jdHdlZW5lZFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlR3ZWVuZWRPcHRpb25zPFQ+fSBbZGVmYXVsdHNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlR3ZWVuZWQ8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0d2VlbmVkKHZhbHVlLCBkZWZhdWx0cyA9IHt9KSB7XG5cdGNvbnN0IHN0b3JlID0gd3JpdGFibGUodmFsdWUpO1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwvcHJpdmF0ZS5qcycpLlRhc2t9ICovXG5cdGxldCB0YXNrO1xuXHRsZXQgdGFyZ2V0X3ZhbHVlID0gdmFsdWU7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R9IG5ld192YWx1ZVxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuVHdlZW5lZE9wdGlvbnM8VD59IFtvcHRzXVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG5ld192YWx1ZSwgb3B0cykge1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRzdG9yZS5zZXQoKHZhbHVlID0gbmV3X3ZhbHVlKSk7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0fVxuXHRcdHRhcmdldF92YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRsZXQgcHJldmlvdXNfdGFzayA9IHRhc2s7XG5cdFx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHRsZXQge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSA0MDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHRpbnRlcnBvbGF0ZSA9IGdldF9pbnRlcnBvbGF0b3Jcblx0XHR9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBvcHRzKTtcblx0XHRpZiAoZHVyYXRpb24gPT09IDApIHtcblx0XHRcdGlmIChwcmV2aW91c190YXNrKSB7XG5cdFx0XHRcdHByZXZpb3VzX3Rhc2suYWJvcnQoKTtcblx0XHRcdFx0cHJldmlvdXNfdGFzayA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRzdG9yZS5zZXQoKHZhbHVlID0gdGFyZ2V0X3ZhbHVlKSk7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0fVxuXHRcdGNvbnN0IHN0YXJ0ID0gbm93KCkgKyBkZWxheTtcblx0XHRsZXQgZm47XG5cdFx0dGFzayA9IGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0aWYgKG5vdyA8IHN0YXJ0KSByZXR1cm4gdHJ1ZTtcblx0XHRcdGlmICghc3RhcnRlZCkge1xuXHRcdFx0XHRmbiA9IGludGVycG9sYXRlKHZhbHVlLCBuZXdfdmFsdWUpO1xuXHRcdFx0XHRpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nKSBkdXJhdGlvbiA9IGR1cmF0aW9uKHZhbHVlLCBuZXdfdmFsdWUpO1xuXHRcdFx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChwcmV2aW91c190YXNrKSB7XG5cdFx0XHRcdHByZXZpb3VzX3Rhc2suYWJvcnQoKTtcblx0XHRcdFx0cHJldmlvdXNfdGFzayA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBlbGFwc2VkID0gbm93IC0gc3RhcnQ7XG5cdFx0XHRpZiAoZWxhcHNlZCA+IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZHVyYXRpb24pKSB7XG5cdFx0XHRcdHN0b3JlLnNldCgodmFsdWUgPSBuZXdfdmFsdWUpKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0c3RvcmUuc2V0KCh2YWx1ZSA9IGZuKGVhc2luZyhlbGFwc2VkIC8gZHVyYXRpb24pKSkpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRhc2sucHJvbWlzZTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHNldCxcblx0XHR1cGRhdGU6IChmbiwgb3B0cykgPT4gc2V0KGZuKHRhcmdldF92YWx1ZSwgdmFsdWUpLCBvcHRzKSxcblx0XHRzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZVxuXHR9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9zcHJpbmcuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90d2VlbmVkLmpzJztcbiJdLCJuYW1lcyI6WyJydW5fYWxsIiwic3Vic2NyaWJlIiwibm9vcCIsInNhZmVfbm90X2VxdWFsIiwiaXNfZnVuY3Rpb24iLCJnZXRfc3RvcmVfdmFsdWUiLCJzdWJzY3JpYmVyX3F1ZXVlIiwicmVhZGFibGUiLCJ2YWx1ZSIsInN0YXJ0Iiwid3JpdGFibGUiLCJzdG9wIiwic3Vic2NyaWJlcnMiLCJTZXQiLCJzZXQiLCJuZXdfdmFsdWUiLCJydW5fcXVldWUiLCJsZW5ndGgiLCJzdWJzY3JpYmVyIiwicHVzaCIsImkiLCJ1cGRhdGUiLCJmbiIsInJ1biIsImludmFsaWRhdGUiLCJhZGQiLCJzaXplIiwiZGVsZXRlIiwiZGVyaXZlZCIsInN0b3JlcyIsImluaXRpYWxfdmFsdWUiLCJzaW5nbGUiLCJBcnJheSIsImlzQXJyYXkiLCJzdG9yZXNfYXJyYXkiLCJldmVyeSIsIkJvb2xlYW4iLCJFcnJvciIsImF1dG8iLCJzdGFydGVkIiwidmFsdWVzIiwicGVuZGluZyIsImNsZWFudXAiLCJzeW5jIiwicmVzdWx0IiwidW5zdWJzY3JpYmVycyIsIm1hcCIsInN0b3JlIiwicmVhZG9ubHkiLCJiaW5kIiwiZ2V0IiwiaXNfZGF0ZSIsIm9iaiIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImxvb3AiLCJub3ciLCJ0aWNrX3NwcmluZyIsImN0eCIsImxhc3RfdmFsdWUiLCJjdXJyZW50X3ZhbHVlIiwidGFyZ2V0X3ZhbHVlIiwiZGVsdGEiLCJ2ZWxvY2l0eSIsImR0Iiwic3ByaW5nIiwib3B0cyIsInN0aWZmbmVzcyIsImRhbXBlciIsImRhbXBpbmciLCJhY2NlbGVyYXRpb24iLCJpbnZfbWFzcyIsImQiLCJNYXRoIiwiYWJzIiwicHJlY2lzaW9uIiwic2V0dGxlZCIsIkRhdGUiLCJnZXRUaW1lIiwiXyIsIm5leHRfdmFsdWUiLCJrIiwibGFzdF90aW1lIiwidGFzayIsImN1cnJlbnRfdG9rZW4iLCJpbnZfbWFzc19yZWNvdmVyeV9yYXRlIiwiY2FuY2VsX3Rhc2siLCJ0b2tlbiIsImhhcmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNvZnQiLCJyYXRlIiwibWluIiwiZnVsZmlsIiwicHJvbWlzZSIsInRoZW4iLCJhc3NpZ24iLCJsaW5lYXIiLCJnZXRfaW50ZXJwb2xhdG9yIiwiYSIsImIiLCJ0eXBlIiwiYXJyIiwiYmkiLCJ0Iiwia2V5cyIsImludGVycG9sYXRvcnMiLCJmb3JFYWNoIiwia2V5IiwidHdlZW5lZCIsImRlZmF1bHRzIiwicHJldmlvdXNfdGFzayIsImRlbGF5IiwiZHVyYXRpb24iLCJlYXNpbmciLCJpbnRlcnBvbGF0ZSIsImFib3J0IiwiZWxhcHNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6100\n")},6056:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rv: function() { return /* binding */ fade; },\n/* harmony export */   _J: function() { return /* binding */ fly; }\n/* harmony export */ });\n/* unused harmony exports blur, slide, scale, draw, crossfade */\n/* harmony import */ var _easing_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3450);\n/* harmony import */ var _internal_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3267);\n\n\n\n/**\n * Animates a `blur` filter alongside an element's opacity.\n *\n * https://svelte.dev/docs/svelte-transition#blur\n * @param {Element} node\n * @param {import('./public').BlurParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction blur(node, {\n  delay = 0,\n  duration = 400,\n  easing = cubicInOut,\n  amount = 5,\n  opacity = 0\n} = {}) {\n  const style = getComputedStyle(node);\n  const target_opacity = +style.opacity;\n  const f = style.filter === 'none' ? '' : style.filter;\n  const od = target_opacity * (1 - opacity);\n  const [value, unit] = split_css_unit(amount);\n  return {\n    delay,\n    duration,\n    easing,\n    css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * value}${unit});`\n  };\n}\n\n/**\n * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.\n *\n * https://svelte.dev/docs/svelte-transition#fade\n * @param {Element} node\n * @param {import('./public').FadeParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction fade(node, {\n  delay = 0,\n  duration = 400,\n  easing = _easing_index_js__WEBPACK_IMPORTED_MODULE_0__/* .linear */ .sn\n} = {}) {\n  const o = +getComputedStyle(node).opacity;\n  return {\n    delay,\n    duration,\n    easing,\n    css: t => `opacity: ${t * o}`\n  };\n}\n\n/**\n * Animates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values.\n *\n * https://svelte.dev/docs/svelte-transition#fly\n * @param {Element} node\n * @param {import('./public').FlyParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction fly(node, {\n  delay = 0,\n  duration = 400,\n  easing = _easing_index_js__WEBPACK_IMPORTED_MODULE_0__/* .cubicOut */ .Jx,\n  x = 0,\n  y = 0,\n  opacity = 0\n} = {}) {\n  const style = getComputedStyle(node);\n  const target_opacity = +style.opacity;\n  const transform = style.transform === 'none' ? '' : style.transform;\n  const od = target_opacity * (1 - opacity);\n  const [xValue, xUnit] = (0,_internal_index_js__WEBPACK_IMPORTED_MODULE_1__/* .split_css_unit */ .AE)(x);\n  const [yValue, yUnit] = (0,_internal_index_js__WEBPACK_IMPORTED_MODULE_1__/* .split_css_unit */ .AE)(y);\n  return {\n    delay,\n    duration,\n    easing,\n    css: (t, u) => `\n\t\t\ttransform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});\n\t\t\topacity: ${target_opacity - od * u}`\n  };\n}\n\n/**\n * Slides an element in and out.\n *\n * https://svelte.dev/docs/svelte-transition#slide\n * @param {Element} node\n * @param {import('./public').SlideParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction slide(node, {\n  delay = 0,\n  duration = 400,\n  easing = cubicOut,\n  axis = 'y'\n} = {}) {\n  const style = getComputedStyle(node);\n  const opacity = +style.opacity;\n  const primary_property = axis === 'y' ? 'height' : 'width';\n  const primary_property_value = parseFloat(style[primary_property]);\n  const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];\n  const capitalized_secondary_properties = secondary_properties.map(e => `${e[0].toUpperCase()}${e.slice(1)}`);\n  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);\n  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);\n  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);\n  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);\n  const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);\n  const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);\n  return {\n    delay,\n    duration,\n    easing,\n    css: t => 'overflow: hidden;' + `opacity: ${Math.min(t * 20, 1) * opacity};` + `${primary_property}: ${t * primary_property_value}px;` + `padding-${secondary_properties[0]}: ${t * padding_start_value}px;` + `padding-${secondary_properties[1]}: ${t * padding_end_value}px;` + `margin-${secondary_properties[0]}: ${t * margin_start_value}px;` + `margin-${secondary_properties[1]}: ${t * margin_end_value}px;` + `border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` + `border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`\n  };\n}\n\n/**\n * Animates the opacity and scale of an element. `in` transitions animate from an element's current (default) values to the provided values, passed as parameters. `out` transitions animate from the provided values to an element's default values.\n *\n * https://svelte.dev/docs/svelte-transition#scale\n * @param {Element} node\n * @param {import('./public').ScaleParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction scale(node, {\n  delay = 0,\n  duration = 400,\n  easing = cubicOut,\n  start = 0,\n  opacity = 0\n} = {}) {\n  const style = getComputedStyle(node);\n  const target_opacity = +style.opacity;\n  const transform = style.transform === 'none' ? '' : style.transform;\n  const sd = 1 - start;\n  const od = target_opacity * (1 - opacity);\n  return {\n    delay,\n    duration,\n    easing,\n    css: (_t, u) => `\n\t\t\ttransform: ${transform} scale(${1 - sd * u});\n\t\t\topacity: ${target_opacity - od * u}\n\t\t`\n  };\n}\n\n/**\n * Animates the stroke of an SVG element, like a snake in a tube. `in` transitions begin with the path invisible and draw the path to the screen over time. `out` transitions start in a visible state and gradually erase the path. `draw` only works with elements that have a `getTotalLength` method, like `<path>` and `<polyline>`.\n *\n * https://svelte.dev/docs/svelte-transition#draw\n * @param {SVGElement & { getTotalLength(): number }} node\n * @param {import('./public').DrawParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction draw(node, {\n  delay = 0,\n  speed,\n  duration,\n  easing = cubicInOut\n} = {}) {\n  let len = node.getTotalLength();\n  const style = getComputedStyle(node);\n  if (style.strokeLinecap !== 'butt') {\n    len += parseInt(style.strokeWidth);\n  }\n  if (duration === undefined) {\n    if (speed === undefined) {\n      duration = 800;\n    } else {\n      duration = len / speed;\n    }\n  } else if (typeof duration === 'function') {\n    duration = duration(len);\n  }\n  return {\n    delay,\n    duration,\n    easing,\n    css: (_, u) => `\n\t\t\tstroke-dasharray: ${len};\n\t\t\tstroke-dashoffset: ${u * len};\n\t\t`\n  };\n}\n\n/**\n * The `crossfade` function creates a pair of [transitions](https://svelte.dev/docs#template-syntax-element-directives-transition-fn) called `send` and `receive`. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the `fallback` transition is used.\n *\n * https://svelte.dev/docs/svelte-transition#crossfade\n * @param {import('./public').CrossfadeParams & {\n * \tfallback?: (node: Element, params: import('./public').CrossfadeParams, intro: boolean) => import('./public').TransitionConfig;\n * }} params\n * @returns {[(node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig, (node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig]}\n */\nfunction crossfade({\n  fallback,\n  ...defaults\n}) {\n  /** @type {Map<any, Element>} */\n  const to_receive = new Map();\n  /** @type {Map<any, Element>} */\n  const to_send = new Map();\n  /**\n   * @param {Element} from_node\n   * @param {Element} node\n   * @param {import('./public').CrossfadeParams} params\n   * @returns {import('./public').TransitionConfig}\n   */\n  function crossfade(from_node, node, params) {\n    const {\n      delay = 0,\n      duration = d => Math.sqrt(d) * 30,\n      easing = cubicOut\n    } = assign(assign({}, defaults), params);\n    const from = from_node.getBoundingClientRect();\n    const to = node.getBoundingClientRect();\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    const dw = from.width / to.width;\n    const dh = from.height / to.height;\n    const d = Math.sqrt(dx * dx + dy * dy);\n    const style = getComputedStyle(node);\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const opacity = +style.opacity;\n    return {\n      delay,\n      duration: is_function(duration) ? duration(d) : duration,\n      easing,\n      css: (t, u) => `\n\t\t\t\topacity: ${t * opacity};\n\t\t\t\ttransform-origin: top left;\n\t\t\t\ttransform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});\n\t\t\t`\n    };\n  }\n\n  /**\n   * @param {Map<any, Element>} items\n   * @param {Map<any, Element>} counterparts\n   * @param {boolean} intro\n   * @returns {(node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig}\n   */\n  function transition(items, counterparts, intro) {\n    return (node, params) => {\n      items.set(params.key, node);\n      return () => {\n        if (counterparts.has(params.key)) {\n          const other_node = counterparts.get(params.key);\n          counterparts.delete(params.key);\n          return crossfade(other_node, node, params);\n        }\n        // if the node is disappearing altogether\n        // (i.e. wasn't claimed by the other list)\n        // then we need to supply an outro\n        items.delete(params.key);\n        return fallback && fallback(node, params, intro);\n      };\n    };\n  }\n  return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsQ0FBQztRQUN4QixPQUFPekIsUUFBUSxJQUFJQSxRQUFRLENBQUM1RCxJQUFJLEVBQUVrRSxNQUFNLEVBQUVpQixLQUFLLENBQUM7TUFDakQsQ0FBQztJQUNGLENBQUM7RUFDRjtFQUNBLE9BQU8sQ0FBQ0gsVUFBVSxDQUFDaEIsT0FBTyxFQUFFRixVQUFVLEVBQUUsS0FBSyxDQUFDLEVBQUVrQixVQUFVLENBQUNsQixVQUFVLEVBQUVFLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN2RiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvdHJhbnNpdGlvbi9pbmRleC5qcz83MThhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGN1YmljT3V0LCBjdWJpY0luT3V0LCBsaW5lYXIgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXguanMnO1xuaW1wb3J0IHsgYXNzaWduLCBzcGxpdF9jc3NfdW5pdCwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5qcyc7XG5cbi8qKlxuICogQW5pbWF0ZXMgYSBgYmx1cmAgZmlsdGVyIGFsb25nc2lkZSBhbiBlbGVtZW50J3Mgb3BhY2l0eS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNibHVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkJsdXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibHVyKFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljSW5PdXQsIGFtb3VudCA9IDUsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgZiA9IHN0eWxlLmZpbHRlciA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS5maWx0ZXI7XG5cdGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuXHRjb25zdCBbdmFsdWUsIHVuaXRdID0gc3BsaXRfY3NzX3VuaXQoYW1vdW50KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoX3QsIHUpID0+IGBvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fTsgZmlsdGVyOiAke2Z9IGJsdXIoJHt1ICogdmFsdWV9JHt1bml0fSk7YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgZnJvbSAwIHRvIHRoZSBjdXJyZW50IG9wYWNpdHkgZm9yIGBpbmAgdHJhbnNpdGlvbnMgYW5kIGZyb20gdGhlIGN1cnJlbnQgb3BhY2l0eSB0byAwIGZvciBgb3V0YCB0cmFuc2l0aW9ucy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNmYWRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkZhZGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gbGluZWFyIH0gPSB7fSkge1xuXHRjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCkgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSB4IGFuZCB5IHBvc2l0aW9ucyBhbmQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudC4gYGluYCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIHByb3ZpZGVkIHZhbHVlcywgcGFzc2VkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcy4gYG91dGAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIHRoZSBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNmbHlcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljJykuRmx5UGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx5KFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCB4ID0gMCwgeSA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0Y29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG5cdGNvbnN0IFt4VmFsdWUsIHhVbml0XSA9IHNwbGl0X2Nzc191bml0KHgpO1xuXHRjb25zdCBbeVZhbHVlLCB5VW5pdF0gPSBzcGxpdF9jc3NfdW5pdCh5KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7KDEgLSB0KSAqIHhWYWx1ZX0ke3hVbml0fSwgJHsoMSAtIHQpICogeVZhbHVlfSR7eVVuaXR9KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSBvZCAqIHV9YFxuXHR9O1xufVxuXG4vKipcbiAqIFNsaWRlcyBhbiBlbGVtZW50IGluIGFuZCBvdXQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXRyYW5zaXRpb24jc2xpZGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljJykuU2xpZGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGlkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBheGlzID0gJ3knIH0gPSB7fSkge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgcHJpbWFyeV9wcm9wZXJ0eSA9IGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblx0Y29uc3QgcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbcHJpbWFyeV9wcm9wZXJ0eV0pO1xuXHRjb25zdCBzZWNvbmRhcnlfcHJvcGVydGllcyA9IGF4aXMgPT09ICd5JyA/IFsndG9wJywgJ2JvdHRvbSddIDogWydsZWZ0JywgJ3JpZ2h0J107XG5cdGNvbnN0IGNhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzID0gc2Vjb25kYXJ5X3Byb3BlcnRpZXMubWFwKFxuXHRcdChlKSA9PiBgJHtlWzBdLnRvVXBwZXJDYXNlKCl9JHtlLnNsaWNlKDEpfWBcblx0KTtcblx0Y29uc3QgcGFkZGluZ19zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYHBhZGRpbmcke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfWBdKTtcblx0Y29uc3QgcGFkZGluZ19lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BwYWRkaW5nJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1gXSk7XG5cdGNvbnN0IG1hcmdpbl9zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYG1hcmdpbiR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19YF0pO1xuXHRjb25zdCBtYXJnaW5fZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgbWFyZ2luJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1gXSk7XG5cdGNvbnN0IGJvcmRlcl93aWR0aF9zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoXG5cdFx0c3R5bGVbYGJvcmRlciR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19V2lkdGhgXVxuXHQpO1xuXHRjb25zdCBib3JkZXJfd2lkdGhfZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChcblx0XHRzdHlsZVtgYm9yZGVyJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1sxXX1XaWR0aGBdXG5cdCk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKHQpID0+XG5cdFx0XHQnb3ZlcmZsb3c6IGhpZGRlbjsnICtcblx0XHRcdGBvcGFjaXR5OiAke01hdGgubWluKHQgKiAyMCwgMSkgKiBvcGFjaXR5fTtgICtcblx0XHRcdGAke3ByaW1hcnlfcHJvcGVydHl9OiAke3QgKiBwcmltYXJ5X3Byb3BlcnR5X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YHBhZGRpbmctJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX06ICR7dCAqIHBhZGRpbmdfc3RhcnRfdmFsdWV9cHg7YCArXG5cdFx0XHRgcGFkZGluZy0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfTogJHt0ICogcGFkZGluZ19lbmRfdmFsdWV9cHg7YCArXG5cdFx0XHRgbWFyZ2luLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19OiAke3QgKiBtYXJnaW5fc3RhcnRfdmFsdWV9cHg7YCArXG5cdFx0XHRgbWFyZ2luLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19OiAke3QgKiBtYXJnaW5fZW5kX3ZhbHVlfXB4O2AgK1xuXHRcdFx0YGJvcmRlci0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfS13aWR0aDogJHt0ICogYm9yZGVyX3dpZHRoX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YGJvcmRlci0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfS13aWR0aDogJHt0ICogYm9yZGVyX3dpZHRoX2VuZF92YWx1ZX1weDtgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIG9wYWNpdHkgYW5kIHNjYWxlIG9mIGFuIGVsZW1lbnQuIGBpbmAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIGFuIGVsZW1lbnQncyBjdXJyZW50IChkZWZhdWx0KSB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcywgcGFzc2VkIGFzIHBhcmFtZXRlcnMuIGBvdXRgIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSB0aGUgcHJvdmlkZWQgdmFsdWVzIHRvIGFuIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNzY2FsZVxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMnKS5TY2FsZVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBzdGFydCA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0Y29uc3Qgc2QgPSAxIC0gc3RhcnQ7XG5cdGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6IChfdCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gc2NhbGUoJHsxIC0gc2QgKiB1fSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fVxuXHRcdGBcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgc3Ryb2tlIG9mIGFuIFNWRyBlbGVtZW50LCBsaWtlIGEgc25ha2UgaW4gYSB0dWJlLiBgaW5gIHRyYW5zaXRpb25zIGJlZ2luIHdpdGggdGhlIHBhdGggaW52aXNpYmxlIGFuZCBkcmF3IHRoZSBwYXRoIHRvIHRoZSBzY3JlZW4gb3ZlciB0aW1lLiBgb3V0YCB0cmFuc2l0aW9ucyBzdGFydCBpbiBhIHZpc2libGUgc3RhdGUgYW5kIGdyYWR1YWxseSBlcmFzZSB0aGUgcGF0aC4gYGRyYXdgIG9ubHkgd29ya3Mgd2l0aCBlbGVtZW50cyB0aGF0IGhhdmUgYSBgZ2V0VG90YWxMZW5ndGhgIG1ldGhvZCwgbGlrZSBgPHBhdGg+YCBhbmQgYDxwb2x5bGluZT5gLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS10cmFuc2l0aW9uI2RyYXdcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudCAmIHsgZ2V0VG90YWxMZW5ndGgoKTogbnVtYmVyIH19IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkRyYXdQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3KG5vZGUsIHsgZGVsYXkgPSAwLCBzcGVlZCwgZHVyYXRpb24sIGVhc2luZyA9IGN1YmljSW5PdXQgfSA9IHt9KSB7XG5cdGxldCBsZW4gPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0aWYgKHN0eWxlLnN0cm9rZUxpbmVjYXAgIT09ICdidXR0Jykge1xuXHRcdGxlbiArPSBwYXJzZUludChzdHlsZS5zdHJva2VXaWR0aCk7XG5cdH1cblx0aWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZHVyYXRpb24gPSA4MDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGR1cmF0aW9uID0gbGVuIC8gc3BlZWQ7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGR1cmF0aW9uID0gZHVyYXRpb24obGVuKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6IChfLCB1KSA9PiBgXG5cdFx0XHRzdHJva2UtZGFzaGFycmF5OiAke2xlbn07XG5cdFx0XHRzdHJva2UtZGFzaG9mZnNldDogJHt1ICogbGVufTtcblx0XHRgXG5cdH07XG59XG5cbi8qKlxuICogVGhlIGBjcm9zc2ZhZGVgIGZ1bmN0aW9uIGNyZWF0ZXMgYSBwYWlyIG9mIFt0cmFuc2l0aW9uc10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjdGVtcGxhdGUtc3ludGF4LWVsZW1lbnQtZGlyZWN0aXZlcy10cmFuc2l0aW9uLWZuKSBjYWxsZWQgYHNlbmRgIGFuZCBgcmVjZWl2ZWAuIFdoZW4gYW4gZWxlbWVudCBpcyAnc2VudCcsIGl0IGxvb2tzIGZvciBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBiZWluZyAncmVjZWl2ZWQnLCBhbmQgZ2VuZXJhdGVzIGEgdHJhbnNpdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIGVsZW1lbnQgdG8gaXRzIGNvdW50ZXJwYXJ0J3MgcG9zaXRpb24gYW5kIGZhZGVzIGl0IG91dC4gV2hlbiBhbiBlbGVtZW50IGlzICdyZWNlaXZlZCcsIHRoZSByZXZlcnNlIGhhcHBlbnMuIElmIHRoZXJlIGlzIG5vIGNvdW50ZXJwYXJ0LCB0aGUgYGZhbGxiYWNrYCB0cmFuc2l0aW9uIGlzIHVzZWQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXRyYW5zaXRpb24jY3Jvc3NmYWRlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMnKS5Dcm9zc2ZhZGVQYXJhbXMgJiB7XG4gKiBcdGZhbGxiYWNrPzogKG5vZGU6IEVsZW1lbnQsIHBhcmFtczogaW1wb3J0KCcuL3B1YmxpYycpLkNyb3NzZmFkZVBhcmFtcywgaW50cm86IGJvb2xlYW4pID0+IGltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnO1xuICogfX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7Wyhub2RlOiBhbnksIHBhcmFtczogaW1wb3J0KCcuL3B1YmxpYycpLkNyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IGltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnLCAobm9kZTogYW55LCBwYXJhbXM6IGltcG9ydCgnLi9wdWJsaWMnKS5Dcm9zc2ZhZGVQYXJhbXMgJiB7IGtleTogYW55OyB9KSA9PiAoKSA9PiBpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZ119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zc2ZhZGUoeyBmYWxsYmFjaywgLi4uZGVmYXVsdHMgfSkge1xuXHQvKiogQHR5cGUge01hcDxhbnksIEVsZW1lbnQ+fSAqL1xuXHRjb25zdCB0b19yZWNlaXZlID0gbmV3IE1hcCgpO1xuXHQvKiogQHR5cGUge01hcDxhbnksIEVsZW1lbnQ+fSAqL1xuXHRjb25zdCB0b19zZW5kID0gbmV3IE1hcCgpO1xuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBmcm9tX25vZGVcblx0ICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkNyb3NzZmFkZVBhcmFtc30gcGFyYW1zXG5cdCAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZ31cblx0ICovXG5cdGZ1bmN0aW9uIGNyb3NzZmFkZShmcm9tX25vZGUsIG5vZGUsIHBhcmFtcykge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gKGQpID0+IE1hdGguc3FydChkKSAqIDMwLFxuXHRcdFx0ZWFzaW5nID0gY3ViaWNPdXRcblx0XHR9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBwYXJhbXMpO1xuXHRcdGNvbnN0IGZyb20gPSBmcm9tX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Y29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IGR4ID0gZnJvbS5sZWZ0IC0gdG8ubGVmdDtcblx0XHRjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuXHRcdGNvbnN0IGR3ID0gZnJvbS53aWR0aCAvIHRvLndpZHRoO1xuXHRcdGNvbnN0IGRoID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG5cdFx0Y29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRcdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdFx0Y29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRcdHJldHVybiB7XG5cdFx0XHRkZWxheSxcblx0XHRcdGR1cmF0aW9uOiBpc19mdW5jdGlvbihkdXJhdGlvbikgPyBkdXJhdGlvbihkKSA6IGR1cmF0aW9uLFxuXHRcdFx0ZWFzaW5nLFxuXHRcdFx0Y3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0XHRvcGFjaXR5OiAke3QgKiBvcGFjaXR5fTtcblx0XHRcdFx0dHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XG5cdFx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3UgKiBkeH1weCwke3UgKiBkeX1weCkgc2NhbGUoJHt0ICsgKDEgLSB0KSAqIGR3fSwgJHtcblx0XHRcdFx0dCArICgxIC0gdCkgKiBkaFxuXHRcdFx0fSk7XG5cdFx0XHRgXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01hcDxhbnksIEVsZW1lbnQ+fSBpdGVtc1xuXHQgKiBAcGFyYW0ge01hcDxhbnksIEVsZW1lbnQ+fSBjb3VudGVycGFydHNcblx0ICogQHBhcmFtIHtib29sZWFufSBpbnRyb1xuXHQgKiBAcmV0dXJucyB7KG5vZGU6IGFueSwgcGFyYW1zOiBpbXBvcnQoJy4vcHVibGljJykuQ3Jvc3NmYWRlUGFyYW1zICYgeyBrZXk6IGFueTsgfSkgPT4gKCkgPT4gaW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG5cdCAqL1xuXHRmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG5cdFx0cmV0dXJuIChub2RlLCBwYXJhbXMpID0+IHtcblx0XHRcdGl0ZW1zLnNldChwYXJhbXMua2V5LCBub2RlKTtcblx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdGlmIChjb3VudGVycGFydHMuaGFzKHBhcmFtcy5rZXkpKSB7XG5cdFx0XHRcdFx0Y29uc3Qgb3RoZXJfbm9kZSA9IGNvdW50ZXJwYXJ0cy5nZXQocGFyYW1zLmtleSk7XG5cdFx0XHRcdFx0Y291bnRlcnBhcnRzLmRlbGV0ZShwYXJhbXMua2V5KTtcblx0XHRcdFx0XHRyZXR1cm4gY3Jvc3NmYWRlKG90aGVyX25vZGUsIG5vZGUsIHBhcmFtcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIG5vZGUgaXMgZGlzYXBwZWFyaW5nIGFsdG9nZXRoZXJcblx0XHRcdFx0Ly8gKGkuZS4gd2Fzbid0IGNsYWltZWQgYnkgdGhlIG90aGVyIGxpc3QpXG5cdFx0XHRcdC8vIHRoZW4gd2UgbmVlZCB0byBzdXBwbHkgYW4gb3V0cm9cblx0XHRcdFx0aXRlbXMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRyZXR1cm4gZmFsbGJhY2sgJiYgZmFsbGJhY2sobm9kZSwgcGFyYW1zLCBpbnRybyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFt0cmFuc2l0aW9uKHRvX3NlbmQsIHRvX3JlY2VpdmUsIGZhbHNlKSwgdHJhbnNpdGlvbih0b19yZWNlaXZlLCB0b19zZW5kLCB0cnVlKV07XG59XG4iXSwibmFtZXMiOlsiY3ViaWNPdXQiLCJjdWJpY0luT3V0IiwibGluZWFyIiwiYXNzaWduIiwic3BsaXRfY3NzX3VuaXQiLCJpc19mdW5jdGlvbiIsImJsdXIiLCJub2RlIiwiZGVsYXkiLCJkdXJhdGlvbiIsImVhc2luZyIsImFtb3VudCIsIm9wYWNpdHkiLCJzdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJ0YXJnZXRfb3BhY2l0eSIsImYiLCJmaWx0ZXIiLCJvZCIsInZhbHVlIiwidW5pdCIsImNzcyIsIl90IiwidSIsImZhZGUiLCJvIiwidCIsImZseSIsIngiLCJ5IiwidHJhbnNmb3JtIiwieFZhbHVlIiwieFVuaXQiLCJ5VmFsdWUiLCJ5VW5pdCIsInNsaWRlIiwiYXhpcyIsInByaW1hcnlfcHJvcGVydHkiLCJwcmltYXJ5X3Byb3BlcnR5X3ZhbHVlIiwicGFyc2VGbG9hdCIsInNlY29uZGFyeV9wcm9wZXJ0aWVzIiwiY2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXMiLCJtYXAiLCJlIiwidG9VcHBlckNhc2UiLCJzbGljZSIsInBhZGRpbmdfc3RhcnRfdmFsdWUiLCJwYWRkaW5nX2VuZF92YWx1ZSIsIm1hcmdpbl9zdGFydF92YWx1ZSIsIm1hcmdpbl9lbmRfdmFsdWUiLCJib3JkZXJfd2lkdGhfc3RhcnRfdmFsdWUiLCJib3JkZXJfd2lkdGhfZW5kX3ZhbHVlIiwiTWF0aCIsIm1pbiIsInNjYWxlIiwic3RhcnQiLCJzZCIsImRyYXciLCJzcGVlZCIsImxlbiIsImdldFRvdGFsTGVuZ3RoIiwic3Ryb2tlTGluZWNhcCIsInBhcnNlSW50Iiwic3Ryb2tlV2lkdGgiLCJ1bmRlZmluZWQiLCJfIiwiY3Jvc3NmYWRlIiwiZmFsbGJhY2siLCJkZWZhdWx0cyIsInRvX3JlY2VpdmUiLCJNYXAiLCJ0b19zZW5kIiwiZnJvbV9ub2RlIiwicGFyYW1zIiwiZCIsInNxcnQiLCJmcm9tIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG8iLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsImR3Iiwid2lkdGgiLCJkaCIsImhlaWdodCIsInRyYW5zaXRpb24iLCJpdGVtcyIsImNvdW50ZXJwYXJ0cyIsImludHJvIiwic2V0Iiwia2V5IiwiaGFzIiwib3RoZXJfbm9kZSIsImdldCIsImRlbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6056\n")}}]);