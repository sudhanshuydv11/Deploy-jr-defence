(self.webpackChunkclient=self.webpackChunkclient||[]).push([[96],{666:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(459);\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n\nleaflet__WEBPACK_IMPORTED_MODULE_0__.Icon.Default.mergeOptions({\n  // Erase default options, so that they can be overridden by _initializeOptions if not supplied.\n  iconUrl: null,\n  iconRetinaUrl: null,\n  shadowUrl: null,\n  iconSize: null,\n  iconAnchor: null,\n  popupAnchor: null,\n  tooltipAnchor: null,\n  shadowSize: null,\n  // @option classNamePrefix: String = 'leaflet-default-icon-'\n  // Prefix for the classes defined in CSS that contain the Icon options.\n  // See the leaflet-defaulticon-compatibility.css file as a starter.\n  // Expected suffixes are \"icon\", \"shadow\", \"popup\" and \"tooltip\".\n  classNamePrefix: 'leaflet-default-icon-'\n});\nleaflet__WEBPACK_IMPORTED_MODULE_0__.Icon.Default.include({\n  _needsInit: true,\n  // Override to make sure options are retrieved from CSS.\n  _getIconUrl: function (name) {\n    // @option imagePath: String\n    // `Icon.Default` will try to auto-detect the location of\n    // the blue icon images. If you are placing these images in a\n    // non-standard way, set this option to point to the right\n    // path, before any marker is added to a map.\n    // Caution: do not use this option with inline base64 image(s).\n    var imagePath = this.options.imagePath || leaflet__WEBPACK_IMPORTED_MODULE_0__.Icon.Default.imagePath || '';\n    // Deprecated (IconDefault.imagePath), backwards-compatibility only\n\n    if (this._needsInit) {\n      // Modifying imagePath option after _getIconUrl has been called\n      // once in this instance of IconDefault will no longer have any\n      // effect.\n      this._initializeOptions(imagePath);\n    }\n    return imagePath + leaflet__WEBPACK_IMPORTED_MODULE_0__.Icon.prototype._getIconUrl.call(this, name);\n  },\n  // Initialize all necessary options for this instance.\n  _initializeOptions: function (imagePath) {\n    this._setOptions('icon', _detectIconOptions, imagePath);\n    this._setOptions('shadow', _detectIconOptions, imagePath);\n    this._setOptions('popup', _detectDivOverlayOptions);\n    this._setOptions('tooltip', _detectDivOverlayOptions);\n    this._needsInit = false;\n  },\n  // Retrieve values from CSS and assign to this instance options.\n  _setOptions: function (name, detectorFn, imagePath) {\n    var options = this.options,\n      prefix = options.classNamePrefix,\n      optionValues = detectorFn(prefix + name, imagePath);\n    for (var optionName in optionValues) {\n      options[name + optionName] = options[name + optionName] || optionValues[optionName];\n    }\n  }\n});\n\n// Retrieve icon option values from CSS (icon or shadow).\nfunction _detectIconOptions(className, imagePath) {\n  var el = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('div', className, document.body),\n    urlsContainer = _getBkgImageOrCursor(el),\n    urls = _extractUrls(urlsContainer, imagePath),\n    iconX = _getStyleInt(el, 'width'),\n    iconY = _getStyleInt(el, 'height'),\n    anchorNX = _getStyleInt(el, 'margin-left'),\n    anchorNY = _getStyleInt(el, 'margin-top');\n  el.parentNode.removeChild(el);\n  return {\n    Url: urls[0],\n    RetinaUrl: urls[1],\n    Size: [iconX, iconY],\n    Anchor: [-anchorNX, -anchorNY]\n  };\n}\n\n// Retrieve anchor option values from CSS (popup or tooltip).\nfunction _detectDivOverlayOptions(className) {\n  var el = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('div', className, document.body),\n    anchorX = _getStyleInt(el, 'margin-left'),\n    anchorY = _getStyleInt(el, 'margin-top');\n  el.parentNode.removeChild(el);\n  return {\n    Anchor: [anchorX, anchorY]\n  };\n}\n\n// Read the CSS url (could be path or inline base64), may be multiple.\n// First: normal icon\n// Second: Retina icon\nfunction _extractUrls(urlsContainer, imagePath) {\n  var re = /url\\(['\"]?([^\"']*?)['\"]?\\)/gi,\n    // Match anything between url( and ), possibly with single or double quotes.\n    urls = [],\n    m = re.exec(urlsContainer);\n  while (m) {\n    // Keep the entire URL from CSS rule, so that each image can have its own full URL.\n    // Except in the case imagePath is provided: remove the path part (i.e. keep only the file name).\n    urls.push(imagePath ? _stripPath(m[1]) : m[1]);\n    m = re.exec(urlsContainer);\n  }\n  return urls;\n}\n\n// Remove anything before the last slash (/) occurrence (inclusive).\n// Caution: will give unexpected result if url is inline base64 data\n// => do not specify imagePath in that case!\nfunction _stripPath(url) {\n  return url.substr(url.lastIndexOf('/') + 1);\n}\nfunction _getStyleInt(el, style) {\n  return parseInt(_getStyle(el, style), 10);\n}\n\n// Factorize style reading fallback for IE8.\nfunction _getStyle(el, style) {\n  return leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.getStyle(el, style) || leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.getStyle(el, _kebabToCamelCase(style));\n}\n\n// When Firefox high contrast (colours override) option is enabled,\n// \"background-image\" is overridden by the browser as \"none\".\n// In that case, fallback to \"cursor\". But keep \"background-image\"\n// as primary source because IE expects cursor URL as relative to HTML page\n// instead of relative to CSS file.\nfunction _getBkgImageOrCursor(el) {\n  var bkgImage = _getStyle(el, 'background-image');\n  return bkgImage && bkgImage !== 'none' ? bkgImage : _getStyle(el, 'cursor');\n}\n\n// Convert kebab-case CSS property name to camelCase for IE currentStyle.\nfunction _kebabToCamelCase(prop) {\n  return prop.replace(/-(\\w)/g, function (str, w) {\n    return w.toUpperCase();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVDLENBQUMsRUFBRTtJQUMvQyxPQUFPQSxDQUFDLENBQUNDLFdBQVcsQ0FBQyxDQUFDO0VBQ3ZCLENBQUMsQ0FBQztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2xlYWZsZXQtZGVmYXVsdGljb24tY29tcGF0aWJpbGl0eS9zcmMvSWNvbi5EZWZhdWx0LmNvbXBhdGliaWxpdHkuanM/YzdiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBMIGZyb20gJ2xlYWZsZXQnO1xuXG5cbkwuSWNvbi5EZWZhdWx0Lm1lcmdlT3B0aW9ucyh7XG5cdC8vIEVyYXNlIGRlZmF1bHQgb3B0aW9ucywgc28gdGhhdCB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGJ5IF9pbml0aWFsaXplT3B0aW9ucyBpZiBub3Qgc3VwcGxpZWQuXG5cdGljb25Vcmw6IG51bGwsXG5cdGljb25SZXRpbmFVcmw6IG51bGwsXG5cdHNoYWRvd1VybDogbnVsbCxcblx0aWNvblNpemU6IG51bGwsXG5cdGljb25BbmNob3I6IG51bGwsXG5cdHBvcHVwQW5jaG9yOiBudWxsLFxuXHR0b29sdGlwQW5jaG9yOiBudWxsLFxuXHRzaGFkb3dTaXplOiBudWxsLFxuXG5cdC8vIEBvcHRpb24gY2xhc3NOYW1lUHJlZml4OiBTdHJpbmcgPSAnbGVhZmxldC1kZWZhdWx0LWljb24tJ1xuXHQvLyBQcmVmaXggZm9yIHRoZSBjbGFzc2VzIGRlZmluZWQgaW4gQ1NTIHRoYXQgY29udGFpbiB0aGUgSWNvbiBvcHRpb25zLlxuXHQvLyBTZWUgdGhlIGxlYWZsZXQtZGVmYXVsdGljb24tY29tcGF0aWJpbGl0eS5jc3MgZmlsZSBhcyBhIHN0YXJ0ZXIuXG5cdC8vIEV4cGVjdGVkIHN1ZmZpeGVzIGFyZSBcImljb25cIiwgXCJzaGFkb3dcIiwgXCJwb3B1cFwiIGFuZCBcInRvb2x0aXBcIi5cblx0Y2xhc3NOYW1lUHJlZml4OiAnbGVhZmxldC1kZWZhdWx0LWljb24tJyxcbn0pO1xuXG5cbkwuSWNvbi5EZWZhdWx0LmluY2x1ZGUoe1xuXG5cdF9uZWVkc0luaXQ6IHRydWUsXG5cblx0Ly8gT3ZlcnJpZGUgdG8gbWFrZSBzdXJlIG9wdGlvbnMgYXJlIHJldHJpZXZlZCBmcm9tIENTUy5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZlxuXHRcdC8vIHRoZSBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGFcblx0XHQvLyBub24tc3RhbmRhcmQgd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0XG5cdFx0Ly8gcGF0aCwgYmVmb3JlIGFueSBtYXJrZXIgaXMgYWRkZWQgdG8gYSBtYXAuXG5cdFx0Ly8gQ2F1dGlvbjogZG8gbm90IHVzZSB0aGlzIG9wdGlvbiB3aXRoIGlubGluZSBiYXNlNjQgaW1hZ2UocykuXG5cdFx0dmFyIGltYWdlUGF0aCA9IHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoIHx8ICcnO1xuXHRcdC8vIERlcHJlY2F0ZWQgKEljb25EZWZhdWx0LmltYWdlUGF0aCksIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcblxuXHRcdGlmICh0aGlzLl9uZWVkc0luaXQpIHtcblx0XHRcdC8vIE1vZGlmeWluZyBpbWFnZVBhdGggb3B0aW9uIGFmdGVyIF9nZXRJY29uVXJsIGhhcyBiZWVuIGNhbGxlZFxuXHRcdFx0Ly8gb25jZSBpbiB0aGlzIGluc3RhbmNlIG9mIEljb25EZWZhdWx0IHdpbGwgbm8gbG9uZ2VyIGhhdmUgYW55XG5cdFx0XHQvLyBlZmZlY3QuXG5cdFx0XHR0aGlzLl9pbml0aWFsaXplT3B0aW9ucyhpbWFnZVBhdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZVBhdGggKyBMLkljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0Ly8gSW5pdGlhbGl6ZSBhbGwgbmVjZXNzYXJ5IG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG5cdF9pbml0aWFsaXplT3B0aW9uczogZnVuY3Rpb24gKGltYWdlUGF0aCkge1xuXHRcdHRoaXMuX3NldE9wdGlvbnMoJ2ljb24nLCBfZGV0ZWN0SWNvbk9wdGlvbnMsIGltYWdlUGF0aCk7XG5cdFx0dGhpcy5fc2V0T3B0aW9ucygnc2hhZG93JywgX2RldGVjdEljb25PcHRpb25zLCBpbWFnZVBhdGgpO1xuXHRcdHRoaXMuX3NldE9wdGlvbnMoJ3BvcHVwJywgX2RldGVjdERpdk92ZXJsYXlPcHRpb25zKTtcblx0XHR0aGlzLl9zZXRPcHRpb25zKCd0b29sdGlwJywgX2RldGVjdERpdk92ZXJsYXlPcHRpb25zKTtcblx0XHR0aGlzLl9uZWVkc0luaXQgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBSZXRyaWV2ZSB2YWx1ZXMgZnJvbSBDU1MgYW5kIGFzc2lnbiB0byB0aGlzIGluc3RhbmNlIG9wdGlvbnMuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiAobmFtZSwgZGV0ZWN0b3JGbiwgaW1hZ2VQYXRoKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0ICAgIHByZWZpeCA9IG9wdGlvbnMuY2xhc3NOYW1lUHJlZml4LFxuXHRcdCAgICBvcHRpb25WYWx1ZXMgPSBkZXRlY3RvckZuKHByZWZpeCArIG5hbWUsIGltYWdlUGF0aCk7XG5cblx0XHRmb3IgKHZhciBvcHRpb25OYW1lIGluIG9wdGlvblZhbHVlcykge1xuXHRcdFx0b3B0aW9uc1tuYW1lICsgb3B0aW9uTmFtZV0gPSBvcHRpb25zW25hbWUgKyBvcHRpb25OYW1lXSB8fCBvcHRpb25WYWx1ZXNbb3B0aW9uTmFtZV07XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG5cbi8vIFJldHJpZXZlIGljb24gb3B0aW9uIHZhbHVlcyBmcm9tIENTUyAoaWNvbiBvciBzaGFkb3cpLlxuZnVuY3Rpb24gX2RldGVjdEljb25PcHRpb25zKGNsYXNzTmFtZSwgaW1hZ2VQYXRoKSB7XG5cdHZhciBlbCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICBjbGFzc05hbWUsIGRvY3VtZW50LmJvZHkpLFxuXHQgICAgdXJsc0NvbnRhaW5lciA9IF9nZXRCa2dJbWFnZU9yQ3Vyc29yKGVsKSxcblx0ICAgIHVybHMgPSBfZXh0cmFjdFVybHModXJsc0NvbnRhaW5lciwgaW1hZ2VQYXRoKSxcblx0ICAgIGljb25YID0gX2dldFN0eWxlSW50KGVsLCAnd2lkdGgnKSxcblx0ICAgIGljb25ZID0gX2dldFN0eWxlSW50KGVsLCAnaGVpZ2h0JyksXG5cdCAgICBhbmNob3JOWCA9IF9nZXRTdHlsZUludChlbCwgJ21hcmdpbi1sZWZ0JyksXG5cdCAgICBhbmNob3JOWSA9IF9nZXRTdHlsZUludChlbCwgJ21hcmdpbi10b3AnKTtcblxuXHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcblxuXHRyZXR1cm4ge1xuXHRcdFVybDogdXJsc1swXSxcblx0XHRSZXRpbmFVcmw6IHVybHNbMV0sXG5cdFx0U2l6ZTogW2ljb25YLCBpY29uWV0sXG5cdFx0QW5jaG9yOiBbLWFuY2hvck5YLCAtYW5jaG9yTlldXG5cdH07XG59XG5cbi8vIFJldHJpZXZlIGFuY2hvciBvcHRpb24gdmFsdWVzIGZyb20gQ1NTIChwb3B1cCBvciB0b29sdGlwKS5cbmZ1bmN0aW9uIF9kZXRlY3REaXZPdmVybGF5T3B0aW9ucyhjbGFzc05hbWUpIHtcblx0dmFyIGVsID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBkb2N1bWVudC5ib2R5KSxcblx0ICAgIGFuY2hvclggPSBfZ2V0U3R5bGVJbnQoZWwsICdtYXJnaW4tbGVmdCcpLFxuXHQgICAgYW5jaG9yWSA9IF9nZXRTdHlsZUludChlbCwgJ21hcmdpbi10b3AnKTtcblxuXHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcblxuXHRyZXR1cm4ge1xuXHRcdEFuY2hvcjogW2FuY2hvclgsIGFuY2hvclldXG5cdH07XG59XG5cbi8vIFJlYWQgdGhlIENTUyB1cmwgKGNvdWxkIGJlIHBhdGggb3IgaW5saW5lIGJhc2U2NCksIG1heSBiZSBtdWx0aXBsZS5cbi8vIEZpcnN0OiBub3JtYWwgaWNvblxuLy8gU2Vjb25kOiBSZXRpbmEgaWNvblxuZnVuY3Rpb24gX2V4dHJhY3RVcmxzKHVybHNDb250YWluZXIsIGltYWdlUGF0aCkge1xuXHR2YXIgcmUgPSAvdXJsXFwoWydcIl0/KFteXCInXSo/KVsnXCJdP1xcKS9naSwgLy8gTWF0Y2ggYW55dGhpbmcgYmV0d2VlbiB1cmwoIGFuZCApLCBwb3NzaWJseSB3aXRoIHNpbmdsZSBvciBkb3VibGUgcXVvdGVzLlxuXHQgICAgdXJscyA9IFtdLFxuXHQgICAgbSA9IHJlLmV4ZWModXJsc0NvbnRhaW5lcik7XG5cblx0d2hpbGUgKG0pIHtcblx0XHQvLyBLZWVwIHRoZSBlbnRpcmUgVVJMIGZyb20gQ1NTIHJ1bGUsIHNvIHRoYXQgZWFjaCBpbWFnZSBjYW4gaGF2ZSBpdHMgb3duIGZ1bGwgVVJMLlxuXHRcdC8vIEV4Y2VwdCBpbiB0aGUgY2FzZSBpbWFnZVBhdGggaXMgcHJvdmlkZWQ6IHJlbW92ZSB0aGUgcGF0aCBwYXJ0IChpLmUuIGtlZXAgb25seSB0aGUgZmlsZSBuYW1lKS5cblx0XHR1cmxzLnB1c2goaW1hZ2VQYXRoID8gX3N0cmlwUGF0aChtWzFdKSA6IG1bMV0pO1xuXHRcdG0gPSByZS5leGVjKHVybHNDb250YWluZXIpO1xuXHR9XG5cblx0cmV0dXJuIHVybHM7XG59XG5cbi8vIFJlbW92ZSBhbnl0aGluZyBiZWZvcmUgdGhlIGxhc3Qgc2xhc2ggKC8pIG9jY3VycmVuY2UgKGluY2x1c2l2ZSkuXG4vLyBDYXV0aW9uOiB3aWxsIGdpdmUgdW5leHBlY3RlZCByZXN1bHQgaWYgdXJsIGlzIGlubGluZSBiYXNlNjQgZGF0YVxuLy8gPT4gZG8gbm90IHNwZWNpZnkgaW1hZ2VQYXRoIGluIHRoYXQgY2FzZSFcbmZ1bmN0aW9uIF9zdHJpcFBhdGgodXJsKSB7XG5cdHJldHVybiB1cmwuc3Vic3RyKHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRTdHlsZUludChlbCwgc3R5bGUpIHtcblx0cmV0dXJuIHBhcnNlSW50KF9nZXRTdHlsZShlbCwgc3R5bGUpLCAxMCk7XG59XG5cbi8vIEZhY3Rvcml6ZSBzdHlsZSByZWFkaW5nIGZhbGxiYWNrIGZvciBJRTguXG5mdW5jdGlvbiBfZ2V0U3R5bGUoZWwsIHN0eWxlKSB7XG5cdHJldHVybiBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsIHN0eWxlKSB8fCBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsIF9rZWJhYlRvQ2FtZWxDYXNlKHN0eWxlKSk7XG59XG5cbi8vIFdoZW4gRmlyZWZveCBoaWdoIGNvbnRyYXN0IChjb2xvdXJzIG92ZXJyaWRlKSBvcHRpb24gaXMgZW5hYmxlZCxcbi8vIFwiYmFja2dyb3VuZC1pbWFnZVwiIGlzIG92ZXJyaWRkZW4gYnkgdGhlIGJyb3dzZXIgYXMgXCJub25lXCIuXG4vLyBJbiB0aGF0IGNhc2UsIGZhbGxiYWNrIHRvIFwiY3Vyc29yXCIuIEJ1dCBrZWVwIFwiYmFja2dyb3VuZC1pbWFnZVwiXG4vLyBhcyBwcmltYXJ5IHNvdXJjZSBiZWNhdXNlIElFIGV4cGVjdHMgY3Vyc29yIFVSTCBhcyByZWxhdGl2ZSB0byBIVE1MIHBhZ2Vcbi8vIGluc3RlYWQgb2YgcmVsYXRpdmUgdG8gQ1NTIGZpbGUuXG5mdW5jdGlvbiBfZ2V0QmtnSW1hZ2VPckN1cnNvcihlbCkge1xuXHR2YXIgYmtnSW1hZ2UgPSBfZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJyk7XG5cblx0cmV0dXJuIGJrZ0ltYWdlICYmIGJrZ0ltYWdlICE9PSAnbm9uZScgPyBia2dJbWFnZSA6IF9nZXRTdHlsZShlbCwgJ2N1cnNvcicpO1xufVxuXG4vLyBDb252ZXJ0IGtlYmFiLWNhc2UgQ1NTIHByb3BlcnR5IG5hbWUgdG8gY2FtZWxDYXNlIGZvciBJRSBjdXJyZW50U3R5bGUuXG5mdW5jdGlvbiBfa2ViYWJUb0NhbWVsQ2FzZShwcm9wKSB7XG5cdHJldHVybiBwcm9wLnJlcGxhY2UoLy0oXFx3KS9nLCBmdW5jdGlvbiAoc3RyLCB3KSB7XG5cdFx0cmV0dXJuIHcudG9VcHBlckNhc2UoKTtcblx0fSk7XG59XG4iXSwibmFtZXMiOlsiTCIsIkljb24iLCJEZWZhdWx0IiwibWVyZ2VPcHRpb25zIiwiaWNvblVybCIsImljb25SZXRpbmFVcmwiLCJzaGFkb3dVcmwiLCJpY29uU2l6ZSIsImljb25BbmNob3IiLCJwb3B1cEFuY2hvciIsInRvb2x0aXBBbmNob3IiLCJzaGFkb3dTaXplIiwiY2xhc3NOYW1lUHJlZml4IiwiaW5jbHVkZSIsIl9uZWVkc0luaXQiLCJfZ2V0SWNvblVybCIsIm5hbWUiLCJpbWFnZVBhdGgiLCJvcHRpb25zIiwiX2luaXRpYWxpemVPcHRpb25zIiwicHJvdG90eXBlIiwiY2FsbCIsIl9zZXRPcHRpb25zIiwiX2RldGVjdEljb25PcHRpb25zIiwiX2RldGVjdERpdk92ZXJsYXlPcHRpb25zIiwiZGV0ZWN0b3JGbiIsInByZWZpeCIsIm9wdGlvblZhbHVlcyIsIm9wdGlvbk5hbWUiLCJjbGFzc05hbWUiLCJlbCIsIkRvbVV0aWwiLCJjcmVhdGUiLCJkb2N1bWVudCIsImJvZHkiLCJ1cmxzQ29udGFpbmVyIiwiX2dldEJrZ0ltYWdlT3JDdXJzb3IiLCJ1cmxzIiwiX2V4dHJhY3RVcmxzIiwiaWNvblgiLCJfZ2V0U3R5bGVJbnQiLCJpY29uWSIsImFuY2hvck5YIiwiYW5jaG9yTlkiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJVcmwiLCJSZXRpbmFVcmwiLCJTaXplIiwiQW5jaG9yIiwiYW5jaG9yWCIsImFuY2hvclkiLCJyZSIsIm0iLCJleGVjIiwicHVzaCIsIl9zdHJpcFBhdGgiLCJ1cmwiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsInN0eWxlIiwicGFyc2VJbnQiLCJfZ2V0U3R5bGUiLCJnZXRTdHlsZSIsIl9rZWJhYlRvQ2FtZWxDYXNlIiwiYmtnSW1hZ2UiLCJwcm9wIiwicmVwbGFjZSIsInN0ciIsInciLCJ0b1VwcGVyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///666\n")},459:function(__unused_webpack_module,exports){eval("/* @preserve\n * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n\n(function (global, factory) {\n   true ? factory(exports) : 0;\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.9.4\";\n\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n\n  // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n  function extend(dest) {\n    var i, j, len, src;\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n    return dest;\n  }\n\n  // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n  var create$2 = Object.create || function () {\n    function F() {}\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }();\n\n  // @function bind(fn: Function, …): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  }\n\n  // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n  var lastId = 0;\n\n  // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n  function stamp(obj) {\n    if (!('_leaflet_id' in obj)) {\n      obj['_leaflet_id'] = ++lastId;\n    }\n    return obj._leaflet_id;\n  }\n\n  // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n    later = function () {\n      // reset lock and call if queued\n      lock = false;\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n    wrapperFn = function () {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n    return wrapperFn;\n  }\n\n  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n      min = range[0],\n      d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  }\n\n  // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n  function falseFn() {\n    return false;\n  }\n\n  // @function formatNum(num: Number, precision?: Number|false): Number\n  // Returns the number `num` rounded with specified `precision`.\n  // The default `precision` value is 6 decimal places.\n  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\n  function formatNum(num, precision) {\n    if (precision === false) {\n      return num;\n    }\n    var pow = Math.pow(10, precision === undefined ? 6 : precision);\n    return Math.round(num * pow) / pow;\n  }\n\n  // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  }\n\n  // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n  function setOptions(obj, options) {\n    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\n      obj.options = obj.options ? create$2(obj.options) : {};\n    }\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n    return obj.options;\n  }\n\n  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n  var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\n\n  // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values — they will be evaluated passing `data` as an argument.\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n      return value;\n    });\n  }\n\n  // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\n\n  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n  var lastTime = 0;\n\n  // fallback for IE 7-8\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n      timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  };\n\n  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  }\n\n  // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n  var Util = {\n    __proto__: null,\n    extend: extend,\n    create: create$2,\n    bind: bind,\n    get lastId() {\n      return lastId;\n    },\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  };\n\n  // @class Class\n  // @aka L.Class\n\n  // @section\n  // @uninheritable\n\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function () {\n      setOptions(this);\n\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      }\n\n      // call all constructor hooks\n      this.callInitHooks();\n    };\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create$2(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto;\n\n    // inherit parent's statics\n    for (var i in this) {\n      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    }\n\n    // mix static properties into the class\n    if (props.statics) {\n      extend(NewClass, props.statics);\n    }\n\n    // mix includes into the prototype\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n    }\n\n    // mix given properties into the prototype\n    extend(proto, props);\n    delete proto.statics;\n    delete proto.includes;\n\n    // merge options\n    if (proto.options) {\n      proto.options = parentProto.options ? create$2(parentProto.options) : {};\n      extend(proto.options, props.options);\n    }\n    proto._initHooks = [];\n\n    // add method for calling all hooks\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n      this._initHooksCalled = true;\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n    return NewClass;\n  };\n\n  // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n  Class.include = function (props) {\n    var parentOptions = this.prototype.options;\n    extend(this.prototype, props);\n    if (props.options) {\n      this.prototype.options = parentOptions;\n      this.mergeOptions(props.options);\n    }\n    return this;\n  };\n\n  // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  };\n\n  // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n    this.prototype._initHooks.push(init);\n    return this;\n  };\n  function checkDeprecatedMixinEvents(includes) {\n    /* global L: true */\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n    includes = isArray(includes) ? includes : [includes];\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n      return this;\n    },\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function (types, fn, context) {\n      if (!arguments.length) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (typeof types === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n        var removeAll = arguments.length === 1;\n        for (var i = 0, len = types.length; i < len; i++) {\n          if (removeAll) {\n            this._off(types[i]);\n          } else {\n            this._off(types[i], fn, context);\n          }\n        }\n      }\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function (type, fn, context, _once) {\n      if (typeof fn !== 'function') {\n        console.warn('wrong listener type: ' + typeof fn);\n        return;\n      }\n\n      // check if fn already there\n      if (this._listens(type, fn, context) !== false) {\n        return;\n      }\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n      var newListener = {\n        fn: fn,\n        ctx: context\n      };\n      if (_once) {\n        newListener.once = true;\n      }\n      this._events = this._events || {};\n      this._events[type] = this._events[type] || [];\n      this._events[type].push(newListener);\n    },\n    _off: function (type, fn, context) {\n      var listeners, i, len;\n      if (!this._events) {\n        return;\n      }\n      listeners = this._events[type];\n      if (!listeners) {\n        return;\n      }\n      if (arguments.length === 1) {\n        // remove all\n        if (this._firingCount) {\n          // Set all removed listeners to noop\n          // so they are not called if remove happens in fire\n          for (i = 0, len = listeners.length; i < len; i++) {\n            listeners[i].fn = falseFn;\n          }\n        }\n        // clear all listeners for a type if function isn't specified\n        delete this._events[type];\n        return;\n      }\n      if (typeof fn !== 'function') {\n        console.warn('wrong listener type: ' + typeof fn);\n        return;\n      }\n\n      // find fn and remove it\n      var index = this._listens(type, fn, context);\n      if (index !== false) {\n        var listener = listeners[index];\n        if (this._firingCount) {\n          // set the removed listener to noop so that's not called if remove happens in fire\n          listener.fn = falseFn;\n\n          /* copy array in case events are being fired */\n          this._events[type] = listeners = listeners.slice();\n        }\n        listeners.splice(index, 1);\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide a data\n    // object — the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function (type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n      if (this._events) {\n        var listeners = this._events[type];\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            // off overwrites l.fn, so we need to copy fn to a var\n            var fn = l.fn;\n            if (l.once) {\n              this.off(type, fn, l.ctx);\n            }\n            fn.call(l.ctx || this, event);\n          }\n          this._firingCount--;\n        }\n      }\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n      return this;\n    },\n    // @method listens(type: String, propagate?: Boolean): Boolean\n    // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\n    listens: function (type, fn, context, propagate) {\n      if (typeof type !== 'string') {\n        console.warn('\"string\" type argument expected');\n      }\n\n      // we don't overwrite the input `fn` value, because we need to use it for propagation\n      var _fn = fn;\n      if (typeof fn !== 'function') {\n        propagate = !!fn;\n        _fn = undefined;\n        context = undefined;\n      }\n      var listeners = this._events && this._events[type];\n      if (listeners && listeners.length) {\n        if (this._listens(type, _fn, context) !== false) {\n          return true;\n        }\n      }\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, fn, context, propagate)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    // returns the index (number) or false\n    _listens: function (type, fn, context) {\n      if (!this._events) {\n        return false;\n      }\n      var listeners = this._events[type] || [];\n      if (!fn) {\n        return !!listeners.length;\n      }\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return i;\n        }\n      }\n      return false;\n    },\n    // @method once(…): this\n    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\n    once: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn, true);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context, true);\n        }\n      }\n      return this;\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function (obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function (obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n      return this;\n    },\n    _propagateEvent: function (e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  };\n\n  // aliases; we should ditch those eventually\n\n  // @method addEventListener(…): this\n  // Alias to [`on(…)`](#evented-on)\n  Events.addEventListener = Events.on;\n\n  // @method removeEventListener(…): this\n  // Alias to [`off(…)`](#evented-off)\n\n  // @method clearAllEventListeners(…): this\n  // Alias to [`off()`](#evented-off)\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off;\n\n  // @method addOneTimeEventListener(…): this\n  // Alias to [`once(…)`](#evented-once)\n  Events.addOneTimeEventListener = Events.once;\n\n  // @method fireEvent(…): this\n  // Alias to [`fire(…)`](#evented-fire)\n  Events.fireEvent = Events.fire;\n\n  // @method hasEventListeners(…): Boolean\n  // Alias to [`listens(…)`](#evented-listens)\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x;\n    // @property y: Number; The `y` coordinate of the point\n    this.y = round ? Math.round(y) : y;\n  }\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function () {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function (point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function (point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function (point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function (point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function (num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function (num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function (num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function (num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function (point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function (point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function () {\n      return this.clone()._round();\n    },\n    _round: function () {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function () {\n      return this.clone()._floor();\n    },\n    _floor: function () {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function () {\n      return this.clone()._ceil();\n    },\n    _ceil: function () {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function () {\n      return this.clone()._trunc();\n    },\n    _trunc: function () {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function (point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n        y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function (point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function (point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function () {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  };\n\n  // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n    if (x === undefined || x === null) {\n      return x;\n    }\n    if (typeof x === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n    return new Point(x, y, round);\n  }\n\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n    var points = b ? [a, b] : a;\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n\n    // @alternative\n    // @method extend(otherBounds: Bounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var min2, max2;\n      if (!obj) {\n        return this;\n      }\n      if (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {\n        min2 = max2 = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n        min2 = obj.min;\n        max2 = obj.max;\n        if (!min2 || !max2) {\n          return this;\n        }\n      }\n\n      // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n      if (!this.min && !this.max) {\n        this.min = min2.clone();\n        this.max = max2.clone();\n      } else {\n        this.min.x = Math.min(min2.x, this.min.x);\n        this.max.x = Math.max(max2.x, this.max.x);\n        this.min.y = Math.min(min2.y, this.min.y);\n        this.max.y = Math.max(max2.y, this.max.y);\n      }\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function (round) {\n      return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function () {\n      return toPoint(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function () {\n      // -> Point\n      return toPoint(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function () {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function () {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function () {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      var min, max;\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xIntersects = max2.x >= min.x && min2.x <= max.x,\n        yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n        max = this.max,\n        min2 = bounds.min,\n        max2 = bounds.max,\n        xOverlaps = max2.x > min.x && min2.x < max.x,\n        yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this.min && this.max);\n    },\n    // @method pad(bufferRatio: Number): Bounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var min = this.min,\n        max = this.max,\n        heightBuffer = Math.abs(min.x - max.x) * bufferRatio,\n        widthBuffer = Math.abs(min.y - max.y) * bufferRatio;\n      return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));\n    },\n    // @method equals(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle is equivalent to the given bounds.\n    equals: function (bounds) {\n      if (!bounds) {\n        return false;\n      }\n      bounds = toBounds(bounds);\n      return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());\n    }\n  };\n\n  // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n    return new Bounds(a, b);\n  }\n\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var sw = this._southWest,\n        ne = this._northEast,\n        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function () {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function () {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function () {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function () {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function () {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function () {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function () {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function () {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function () {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2,\n        ne2;\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n        lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n        ne = this._northEast,\n        sw2 = bounds.getSouthWest(),\n        ne2 = bounds.getNorthEast(),\n        latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n        lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function () {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this._southWest && this._northEast);\n    }\n  };\n\n  // TODO International date line?\n\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n    return new LatLngBounds(a, b);\n  }\n\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    }\n\n    // @property lat: Number\n    // Latitude in degrees\n    this.lat = +lat;\n\n    // @property lng: Number\n    // Longitude in degrees\n    this.lng = +lng;\n\n    // @property alt: Number\n    // Altitude in meters (optional)\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function (precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function (other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function () {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function (sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n        lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function () {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  };\n\n  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n    if (isArray(a) && typeof a[0] !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n      return null;\n    }\n    if (a === undefined || a === null) {\n      return a;\n    }\n    if (typeof a === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n    if (b === undefined) {\n      return null;\n    }\n    return new LatLng(a, b, c);\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function (latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n        scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function (point, zoom) {\n      var scale = this.scale(zoom),\n        untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function (latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function (point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function (zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function (scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function (zoom) {\n      if (this.infinite) {\n        return null;\n      }\n      var b = this.projection.bounds,\n        s = this.scale(zoom),\n        min = this.transformation.transform(b.min, s),\n        max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function (latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n        lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n        alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function (bounds) {\n      var center = bounds.getCenter(),\n        newCenter = this.wrapLatLng(center),\n        latShift = center.lat - newCenter.lat,\n        lngShift = center.lng - newCenter.lng;\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n      var sw = bounds.getSouthWest(),\n        ne = bounds.getNorthEast(),\n        newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n        newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see https://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n        lat1 = latlng1.lat * rad,\n        lat2 = latlng2.lat * rad,\n        sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n        sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n        a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n        c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection — the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function (latlng) {\n      var d = Math.PI / 180,\n        max = this.MAX_LATITUDE,\n        lat = Math.max(Math.min(max, latlng.lat), -max),\n        sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function (point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function (point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function (point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  };\n\n  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  });\n\n  // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n  function pointsToPath(rings, closed) {\n    var str = '',\n      i,\n      j,\n      len,\n      len2,\n      points,\n      p;\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      }\n\n      // closes the ring for polygons; \"x\" is VML syntax\n      str += closed ? Browser.svg ? 'z' : 'x' : '';\n    }\n\n    // SVG complains about empty path strings\n    return str || 'M0 0';\n  }\n\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n  var style = document.documentElement.style;\n\n  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n  var ie = ('ActiveXObject' in window);\n\n  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n  var ielt9 = ie && !document.addEventListener;\n\n  // @property edge: Boolean; `true` for the Edge web browser.\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);\n\n  // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n  var webkit = userAgentContains('webkit');\n\n  // @property android: Boolean\n  // **Deprecated.** `true` for any browser running on an Android platform.\n  var android = userAgentContains('android');\n\n  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);\n\n  // @property opera: Boolean; `true` for the Opera browser\n  var opera = !!window.opera;\n\n  // @property chrome: Boolean; `true` for the Chrome browser.\n  var chrome = !edge && userAgentContains('chrome');\n\n  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;\n\n  // @property safari: Boolean; `true` for the Safari browser.\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom');\n\n  // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n  var opera12 = ('OTransition' in style);\n\n  // @property win: Boolean; `true` when the browser is running in a Windows platform\n  var win = navigator.platform.indexOf('Win') === 0;\n\n  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n  var ie3d = ie && 'transition' in style;\n\n  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;\n\n  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n  var gecko3d = ('MozPerspective' in style);\n\n  // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\n\n  // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');\n\n  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n  var mobileWebkit = mobile && webkit;\n\n  // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n  var mobileWebkit3d = mobile && webkit3d;\n\n  // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n  var msPointer = !window.PointerEvent && window.MSPointerEvent;\n\n  // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n  var pointer = !!(window.PointerEvent || msPointer);\n\n  // @property touchNative: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // **This does not necessarily mean** that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;\n\n  // @property touch: Boolean\n  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\n  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\n  var touch = !window.L_NO_TOUCH && (touchNative || pointer);\n\n  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n  var mobileOpera = mobile && opera;\n\n  // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n  var mobileGecko = mobile && gecko;\n\n  // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;\n\n  // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          // eslint-disable-line getter-return\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {\n      // Errors can safely be ignored since this is only a browser support test.\n    }\n    return supportsPassiveOption;\n  }();\n\n  // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n  var canvas$1 = function () {\n    return !!document.createElement('canvas').getContext;\n  }();\n\n  // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);\n  var inlineSvg = !!svg$1 && function () {\n    var div = document.createElement('div');\n    div.innerHTML = '<svg/>';\n    return (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';\n  }();\n\n  // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n  var vml = !svg$1 && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && typeof shape.adj === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  // @property mac: Boolean; `true` when the browser is running in a Mac platform\n  var mac = navigator.platform.indexOf('Mac') === 0;\n\n  // @property mac: Boolean; `true` when the browser is running in a Linux platform\n  var linux = navigator.platform.indexOf('Linux') === 0;\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n  var Browser = {\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    touchNative: touchNative,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas$1,\n    svg: svg$1,\n    vml: vml,\n    inlineSvg: inlineSvg,\n    mac: mac,\n    linux: linux\n  };\n\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = Browser.msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = Browser.msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = Browser.msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var pEvent = {\n    touchstart: POINTER_DOWN,\n    touchmove: POINTER_MOVE,\n    touchend: POINTER_UP,\n    touchcancel: POINTER_CANCEL\n  };\n  var handle = {\n    touchstart: _onPointerStart,\n    touchmove: _handlePointer,\n    touchend: _handlePointer,\n    touchcancel: _handlePointer\n  };\n  var _pointers = {};\n  var _pointerDocListener = false;\n\n  // Provides a touch events wrapper for (ms)pointer events.\n  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler) {\n    if (type === 'touchstart') {\n      _addPointerDocListener();\n    }\n    if (!handle[type]) {\n      console.warn('wrong event specified:', type);\n      return falseFn;\n    }\n    handler = handle[type].bind(this, handler);\n    obj.addEventListener(pEvent[type], handler, false);\n    return handler;\n  }\n  function removePointerListener(obj, type, handler) {\n    if (!pEvent[type]) {\n      console.warn('wrong event specified:', type);\n      return;\n    }\n    obj.removeEventListener(pEvent[type], handler, false);\n  }\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n  }\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n  }\n  function _addPointerDocListener() {\n    // need to keep track of what pointers and how many are active to provide e.touches emulation\n    if (!_pointerDocListener) {\n      // we listen document as any drags that end by moving the touch off the screen get fired there\n      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n  function _handlePointer(handler, e) {\n    if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {\n      return;\n    }\n    e.touches = [];\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n    e.changedTouches = [e];\n    handler(e);\n  }\n  function _onPointerStart(handler, e) {\n    // IE10 specific: MsTouch needs preventDefault. See #2000\n    if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n      preventDefault(e);\n    }\n    _handlePointer(handler, e);\n  }\n\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */\n\n  function makeDblclick(event) {\n    // in modern browsers `type` cannot be just overridden:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\n    var newEvent = {},\n      prop,\n      i;\n    for (i in event) {\n      prop = event[i];\n      newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\n    }\n    event = newEvent;\n    newEvent.type = 'dblclick';\n    newEvent.detail = 2;\n    newEvent.isTrusted = false;\n    newEvent._simulated = true; // for debug purposes\n    return newEvent;\n  }\n  var delay = 200;\n  function addDoubleTapListener(obj, handler) {\n    // Most browsers handle double tap natively\n    obj.addEventListener('dblclick', handler);\n\n    // On some platforms the browser doesn't fire native dblclicks for touch events.\n    // It seems that in all such cases `detail` property of `click` event is always `1`.\n    // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\n    var last = 0,\n      detail;\n    function simDblclick(e) {\n      if (e.detail !== 1) {\n        detail = e.detail; // keep in sync to avoid false dblclick in some cases\n        return;\n      }\n      if (e.pointerType === 'mouse' || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // When clicking on an <input>, the browser generates a click on its\n      // <label> (and vice versa) triggering two clicks in quick succession.\n      // This ignores clicks on elements which are a label with a 'for'\n      // attribute (or children of such a label), but not children of\n      // a <input>.\n      var path = getPropagationPath(e);\n      if (path.some(function (el) {\n        return el instanceof HTMLLabelElement && el.attributes.for;\n      }) && !path.some(function (el) {\n        return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;\n      })) {\n        return;\n      }\n      var now = Date.now();\n      if (now - last <= delay) {\n        detail++;\n        if (detail === 2) {\n          handler(makeDblclick(e));\n        }\n      } else {\n        detail = 1;\n      }\n      last = now;\n    }\n    obj.addEventListener('click', simDblclick);\n    return {\n      dblclick: handler,\n      simDblclick: simDblclick\n    };\n  }\n  function removeDoubleTapListener(obj, handlers) {\n    obj.removeEventListener('dblclick', handlers.dblclick);\n    obj.removeEventListener('click', handlers.simDblclick);\n  }\n\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\n\n  // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\n\n  // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';\n\n  // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  }\n\n  // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n    return value === 'auto' ? null : value;\n  }\n\n  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n    if (container) {\n      container.appendChild(el);\n    }\n    return el;\n  }\n\n  // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n  function remove(el) {\n    var parent = el.parentNode;\n    if (parent) {\n      parent.removeChild(el);\n    }\n  }\n\n  // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  }\n\n  // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n  function toFront(el) {\n    var parent = el.parentNode;\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  }\n\n  // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n  function toBack(el) {\n    var parent = el.parentNode;\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  }\n\n  // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  }\n\n  // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  }\n\n  // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  }\n\n  // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  }\n\n  // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  }\n\n  // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n  function setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n  function _setOpacityIE(el, value) {\n    var filter = false,\n      filterName = 'DXImageTransform.Microsoft.Alpha';\n\n    // filters collection throws an error if we try to retrieve a filter that doesn't exist\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n    value = Math.round(value * 100);\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  }\n\n  // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n  function testProp(props) {\n    var style = document.documentElement.style;\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n    return false;\n  }\n\n  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  }\n\n  // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (Browser.any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  }\n\n  // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n\n    return el._leaflet_pos || new Point(0, 0);\n  }\n\n  // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n  var disableTextSelection;\n  var enableTextSelection;\n  var _userSelect;\n  if ('onselectstart' in document) {\n    disableTextSelection = function () {\n      on(window, 'selectstart', preventDefault);\n    };\n    enableTextSelection = function () {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n    disableTextSelection = function () {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n    enableTextSelection = function () {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  }\n\n  // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  }\n\n  // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n  var _outlineElement, _outlineStyle;\n  // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n    if (!element.style) {\n      return;\n    }\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outlineStyle;\n    element.style.outlineStyle = 'none';\n    on(window, 'keydown', restoreOutline);\n  }\n\n  // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n    _outlineElement.style.outlineStyle = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  }\n\n  // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n    return element;\n  }\n\n  // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n  var DomUtil = {\n    __proto__: null,\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    get disableTextSelection() {\n      return disableTextSelection;\n    },\n    get enableTextSelection() {\n      return enableTextSelection;\n    },\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  };\n\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n  function on(obj, types, fn, context) {\n    if (types && typeof types === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n    return this;\n  }\n  var eventsKey = '_leaflet_events';\n\n  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  // @alternative\n  // @function off(el: HTMLElement, types: String): this\n  // Removes all previously added listeners of given types.\n\n  // @alternative\n  // @function off(el: HTMLElement): this\n  // Removes all previously added listeners from given HTMLElement\n  function off(obj, types, fn, context) {\n    if (arguments.length === 1) {\n      batchRemove(obj);\n      delete obj[eventsKey];\n    } else if (types && typeof types === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n      if (arguments.length === 2) {\n        batchRemove(obj, function (type) {\n          return indexOf(types, type) !== -1;\n        });\n      } else {\n        for (var i = 0, len = types.length; i < len; i++) {\n          removeOne(obj, types[i], fn, context);\n        }\n      }\n    }\n    return this;\n  }\n  function batchRemove(obj, filterFn) {\n    for (var id in obj[eventsKey]) {\n      var type = id.split(/\\d/)[0];\n      if (!filterFn || filterFn(type)) {\n        removeOne(obj, type, null, null, id);\n      }\n    }\n  }\n  var mouseSubst = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout',\n    wheel: !('onwheel' in window) && 'mousewheel'\n  };\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n    var handler = function (e) {\n      return fn.call(context || obj, e || window.event);\n    };\n    var originalHandler = handler;\n    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      handler = addPointerListener(obj, type, handler);\n    } else if (Browser.touch && type === 'dblclick') {\n      handler = addDoubleTapListener(obj, handler);\n    } else if ('addEventListener' in obj) {\n      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {\n        obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function (e) {\n          e = e || window.event;\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n        obj.addEventListener(mouseSubst[type], handler, false);\n      } else {\n        obj.addEventListener(type, originalHandler, false);\n      }\n    } else {\n      obj.attachEvent('on' + type, handler);\n    }\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n  function removeOne(obj, type, fn, context, id) {\n    id = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');\n    var handler = obj[eventsKey] && obj[eventsKey][id];\n    if (!handler) {\n      return this;\n    }\n    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, handler);\n    } else if (Browser.touch && type === 'dblclick') {\n      removeDoubleTapListener(obj, handler);\n    } else if ('removeEventListener' in obj) {\n      obj.removeEventListener(mouseSubst[type] || type, handler, false);\n    } else {\n      obj.detachEvent('on' + type, handler);\n    }\n    obj[eventsKey][id] = null;\n  }\n\n  // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n    return this;\n  }\n\n  // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\n  function disableScrollPropagation(el) {\n    addOne(el, 'wheel', stopPropagation);\n    return this;\n  }\n\n  // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);\n    el['_leaflet_disable_click'] = true;\n    return this;\n  }\n\n  // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n    return this;\n  }\n\n  // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  }\n\n  // @function getPropagationPath(ev: DOMEvent): Array\n  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).\n  // Returns an array containing the `HTMLElement`s that the given DOM event\n  // should propagate to (if not stopped).\n  function getPropagationPath(ev) {\n    if (ev.composedPath) {\n      return ev.composedPath();\n    }\n    var path = [];\n    var el = ev.target;\n    while (el) {\n      path.push(el);\n      el = el.parentNode;\n    }\n    return path;\n  }\n\n  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n    var scale = getScale(container),\n      offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point(\n    // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  }\n\n  //  except , Safari and\n  // We need double the scroll pixels (see #7403 and #4538) for all Browsers\n  // except OSX (Mac) -> 3x, Chrome running on Linux 1x\n\n  var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;\n  // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a wheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n  function getWheelDelta(e) {\n    return Browser.edge ? e.wheelDeltaY / 2 :\n    // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor :\n    // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 :\n    // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 :\n    // Pages\n    e.deltaX || e.deltaZ ? 0 :\n    // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 :\n    // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 :\n    // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 :\n    // Legacy Moz pages\n    0;\n  }\n\n  // check if element really left/entered the event target (for mouseenter/mouseleave)\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n    if (!related) {\n      return true;\n    }\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n    return related !== el;\n  }\n  var DomEvent = {\n    __proto__: null,\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getPropagationPath: getPropagationPath,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  };\n\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);\n   *\n   * myPositionMarker.on(\"click\", function() {\n   * \tvar pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());\n   * \tpos.y -= 25;\n   * \tvar fx = new L.PosAnimation();\n   *\n   * \tfx.once('end',function() {\n   * \t\tpos.y += 25;\n   * \t\tfx.run(myPositionMarker._icon, pos, 0.8);\n   * \t});\n   *\n   * \tfx.run(myPositionMarker._icon, pos, 0.3);\n   * });\n   *\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function (el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date();\n\n      // @event start: Event\n      // Fired when the animation starts\n      this.fire('start');\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function () {\n      if (!this._inProgress) {\n        return;\n      }\n      this._step(true);\n      this._complete();\n    },\n    _animate: function () {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n      this._step();\n    },\n    _step: function (round) {\n      var elapsed = +new Date() - this._startTime,\n        duration = this._duration * 1000;\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n        this._complete();\n      }\n    },\n    _runFrame: function (progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n      if (round) {\n        pos._round();\n      }\n      setPosition(this._el, pos);\n\n      // @event step: Event\n      // Fired continuously during the animation.\n      this.fire('step');\n    },\n    _complete: function () {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false;\n      // @event end: Event\n      // Fired when the animation ends.\n      this.fire('end');\n    },\n    _easeOut: function (t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API — it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function (id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options);\n\n      // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n      this._initContainer(id);\n      this._initLayout();\n\n      // hack for https://github.com/Leaflet/Leaflet/issues/1980\n      this._onResize = bind(this._onResize, this);\n      this._initEvents();\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n      this.callInitHooks();\n\n      // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n      this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;\n\n      // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function (center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n      this._stop();\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        }\n\n        // try animating pan or zoom\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      }\n\n      // animation didn't start, just reset the map view\n      this._resetView(center, zoom, options.pan && options.pan.noMoveStart);\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function (zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function (delta, options) {\n      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function (delta, options) {\n      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function (latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n        viewHalf = this.getSize().divideBy(2),\n        containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function (bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n        swPoint = this.project(bounds.getSouthWest(), zoom),\n        nePoint = this.project(bounds.getNorthEast(), zoom),\n        center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function (bounds, options) {\n      bounds = toLatLngBounds(bounds);\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n      var target = this._getBoundsCenterZoom(bounds, options);\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function (options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function (center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function (offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      }\n      // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n        return this;\n      }\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      }\n\n      // don't fire movestart if animating inertia\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      }\n\n      // animate pan unless animate: false specified\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n        var newPos = this._getMapPanePos().subtract(offset).round();\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n        this.fire('move').fire('moveend');\n      }\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function (targetCenter, targetZoom, options) {\n      options = options || {};\n      if (options.animate === false || !Browser.any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n      this._stop();\n      var from = this.project(this.getCenter()),\n        to = this.project(targetCenter),\n        size = this.getSize(),\n        startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n        w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n        u1 = to.distanceTo(from) || 1,\n        rho = 1.42,\n        rho2 = rho * rho;\n      function r(i) {\n        var s1 = i ? -1 : 1,\n          s2 = i ? w1 : w0,\n          t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n          b1 = 2 * s2 * rho2 * u1,\n          b = t1 / b1,\n          sq = Math.sqrt(b * b + 1) - b;\n\n        // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n      var r0 = r(0);\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n      var start = Date.now(),\n        S = (r(1) - r0) / rho,\n        duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n      function frame() {\n        var t = (Date.now() - start) / duration,\n          s = easeOut(t) * S;\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n      this._moveStart(true, options.noMoveStart);\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function (bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: LatLngBounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      if (this.listens('moveend', this._panInsideMaxBounds)) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this;\n      }\n      this.options.maxBounds = bounds;\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function (zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function (zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function (bounds, options) {\n      this._enforcingBounds = true;\n      var center = this.getCenter(),\n        newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: padding options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // padding options to fit the display to more restricted bounds.\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function (latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n        pixelCenter = this.project(this.getCenter()),\n        pixelPoint = this.project(latlng),\n        pixelBounds = this.getPixelBounds(),\n        paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\n        paddedSize = paddedBounds.getSize();\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n        var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n        pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n        pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n        this.panTo(this.unproject(pixelCenter), options);\n        this._enforcingBounds = false;\n      }\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function (options) {\n      if (!this._loaded) {\n        return this;\n      }\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n        oldCenter = oldSize.divideBy(2).round(),\n        newCenter = newSize.divideBy(2).round(),\n        offset = oldCenter.subtract(newCenter);\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n        this.fire('move');\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      }\n\n      // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function () {\n      this.setZoom(this._limitZoom(this._zoom));\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function (options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false\n        // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n      }, options);\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n        return this;\n      }\n      var onResponse = bind(this._handleGeolocationResponse, this),\n        onError = bind(this._handleGeolocationError, this);\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function () {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n      return this;\n    },\n    _handleGeolocationError: function (error) {\n      if (!this._container._leaflet_id) {\n        return;\n      }\n      var c = error.code,\n        message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      }\n\n      // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function (pos) {\n      if (!this._container._leaflet_id) {\n        return;\n      }\n      var lat = pos.coords.latitude,\n        lng = pos.coords.longitude,\n        latlng = new LatLng(lat, lng),\n        bounds = latlng.toBounds(pos.coords.accuracy * 2),\n        options = this._locateOptions;\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      }\n\n      // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function (name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n      var handler = this[name] = new HandlerClass(this);\n      this._handlers.push(handler);\n      if (this.options[name]) {\n        handler.enable();\n      }\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function () {\n      this._initEvents(true);\n      if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n        this._containerId = undefined;\n      }\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n      this._stop();\n      remove(this._mapPane);\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n      this._clearHandlers();\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n      var i;\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n      for (i in this._panes) {\n        remove(this._panes[i]);\n      }\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function (name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n        pane = create$1('div', className, container || this._mapPane);\n      if (name) {\n        this._panes[name] = pane;\n      }\n      return pane;\n    },\n    // @section Methods for Getting Map State\n\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function () {\n      this._checkIfLoaded();\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter.clone();\n      }\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function () {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function () {\n      var bounds = this.getPixelBounds(),\n        sw = this.unproject(bounds.getBottomLeft()),\n        ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function () {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function () {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function (bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n        min = this.getMinZoom(),\n        max = this.getMaxZoom(),\n        nw = bounds.getNorthWest(),\n        se = bounds.getSouthEast(),\n        size = this.getSize().subtract(padding),\n        boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n        snap = Browser.any3d ? this.options.zoomSnap : 1,\n        scalex = size.x / boundsSize.x,\n        scaley = size.y / boundsSize.y,\n        scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function () {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function (center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function () {\n      this._checkIfLoaded();\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function (zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function (pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function () {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function () {\n      return this._container;\n    },\n    // @section Conversion Methods\n\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function (toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function (scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function (latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function (point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function (point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function (latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function (latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function (latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function (latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function (point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function (point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function (point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function (latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function (e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function (e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function (e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n\n    _initContainer: function (id) {\n      var container = this._container = get(id);\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function () {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\n      addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {\n        container.style.position = 'relative';\n      }\n      this._initPanes();\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function () {\n      var panes = this._panes = {};\n      this._paneRenderers = {};\n\n      // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0));\n\n      // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n      this.createPane('tilePane');\n      // @pane overlayPane: HTMLElement = 400\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n      this.createPane('overlayPane');\n      // @pane shadowPane: HTMLElement = 500\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n      this.createPane('shadowPane');\n      // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n      this.createPane('markerPane');\n      // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n      this.createPane('tooltipPane');\n      // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n      this.createPane('popupPane');\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n\n    // @section Map state change events\n    _resetView: function (center, zoom, noMoveStart) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n      this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);\n\n      // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n      this.fire('viewreset');\n\n      // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function (zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n      return this;\n    },\n    _move: function (center, zoom, data, supressEvent) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center);\n      if (!supressEvent) {\n        // @event zoom: Event\n        // Fired repeatedly during any change in zoom level,\n        // including zoom and fly animations.\n        if (zoomChanged || data && data.pinch) {\n          // Always fire 'zoom' if pinching because #3530\n          this.fire('zoom', data);\n        }\n\n        // @event move: Event\n        // Fired repeatedly during any movement of the map,\n        // including pan and fly animations.\n        this.fire('move', data);\n      } else if (data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      }\n      return this;\n    },\n    _moveEnd: function (zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map zoom changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      }\n\n      // @event moveend: Event\n      // Fired when the center of the map stops changing\n      // (e.g. user stopped dragging the map or after non-centered zoom).\n      return this.fire('moveend');\n    },\n    _stop: function () {\n      cancelAnimFrame(this._flyToFrame);\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n      return this;\n    },\n    _rawPanBy: function (offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function () {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function () {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function () {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n\n    // @section Interaction events\n    _initEvents: function (remove) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove ? off : on;\n\n      // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n      if (Browser.any3d && this.options.transform3DLimit) {\n        (remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function () {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function () {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function () {\n      var pos = this._getMapPanePos();\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function (e, type) {\n      var targets = [],\n        target,\n        isHover = type === 'mouseout' || type === 'mouseover',\n        src = e.target || e.srcElement,\n        dragging = false;\n      while (src) {\n        target = this._targets[stamp(src)];\n        if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n          targets.push(target);\n          if (isHover) {\n            break;\n          }\n        }\n        if (src === this._container) {\n          break;\n        }\n        src = src.parentNode;\n      }\n      if (!targets.length && !dragging && !isHover && this.listens(type, true)) {\n        targets = [this];\n      }\n      return targets;\n    },\n    _isClickDisabled: function (el) {\n      while (el && el !== this._container) {\n        if (el['_leaflet_disable_click']) {\n          return true;\n        }\n        el = el.parentNode;\n      }\n    },\n    _handleDOMEvent: function (e) {\n      var el = e.target || e.srcElement;\n      if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\n        return;\n      }\n      var type = e.type;\n      if (type === 'mousedown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(el);\n      }\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function (e, type, canvasTargets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n        this._fireDOMEvent(synth, synth.type, canvasTargets);\n      }\n\n      // Find the layer the event is propagating from and its parents.\n      var targets = this._findEventTargets(e, type);\n      if (canvasTargets) {\n        var filtered = []; // pick only targets with listeners\n        for (var i = 0; i < canvasTargets.length; i++) {\n          if (canvasTargets[i].listens(type, true)) {\n            filtered.push(canvasTargets[i]);\n          }\n        }\n        targets = filtered.concat(targets);\n      }\n      if (!targets.length) {\n        return;\n      }\n      if (type === 'contextmenu') {\n        preventDefault(e);\n      }\n      var target = targets[0];\n      var data = {\n        originalEvent: e\n      };\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n      for (i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function (obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function () {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function (callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n      return this;\n    },\n    // private methods for getting map state\n\n    _getMapPanePos: function () {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function () {\n      var pos = this._getMapPanePos();\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function (center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function (center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function (latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function () {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function (latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function (center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n      var centerPoint = this.project(center, zoom),\n        viewHalf = this.getSize().divideBy(2),\n        viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n        offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n\n      // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n      if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n        return center;\n      }\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function (offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n      var viewBounds = this.getPixelBounds(),\n        newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n        minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n        maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n        dx = this._rebound(minOffset.x, -maxOffset.x),\n        dy = this._rebound(minOffset.y, -maxOffset.y);\n      return new Point(dx, dy);\n    },\n    _rebound: function (left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function (zoom) {\n      var min = this.getMinZoom(),\n        max = this.getMaxZoom(),\n        snap = Browser.any3d ? this.options.zoomSnap : 1;\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function () {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function () {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function (center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc();\n\n      // don't animate too far unless animate: true specified in options\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function () {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n      this._panes.mapPane.appendChild(proxy);\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n          transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n\n        // workaround for case when transform is the same and so transitionend event is not fired\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function () {\n      remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function () {\n      var c = this.getCenter(),\n        z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function (e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function () {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function (center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n      options = options || {};\n\n      // don't animate if disabled, not supported or zoom difference is too large\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      }\n\n      // offset is the pixel coords of the zoom origin relative to the current center\n      var scale = this.getZoomScale(zoom),\n        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n\n      // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n      requestAnimFrame(function () {\n        this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function (center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n      if (startAnim) {\n        this._animatingZoom = true;\n\n        // remember what center/zoom to set after animation\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      });\n      if (!this._tempFireZoomEvent) {\n        this._tempFireZoomEvent = this._zoom !== this._animateToZoom;\n      }\n      this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n\n      // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function () {\n      if (!this._animatingZoom) {\n        return;\n      }\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n      this._animatingZoom = false;\n      this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n      if (this._tempFireZoomEvent) {\n        this.fire('zoom');\n      }\n      delete this._tempFireZoomEvent;\n      this.fire('move');\n      this._moveEnd(true);\n    }\n  });\n\n  // @section\n\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control Options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function () {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function (position) {\n      var map = this._map;\n      if (map) {\n        map.removeControl(this);\n      }\n      this.options.position = position;\n      if (map) {\n        map.addControl(this);\n      }\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function (map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n        pos = this.getPosition(),\n        corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n      this._map.on('unload', this.remove, this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function () {\n      if (!this._map) {\n        return this;\n      }\n      remove(this._container);\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n      this._map.off('unload', this.remove, this);\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function (e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n  var control = function (options) {\n    return new Control(options);\n  };\n\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function (control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function (control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function () {\n      var corners = this._controlCorners = {},\n        l = 'leaflet-',\n        container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function () {\n      for (var i in this._controlCorners) {\n        remove(this._controlCorners[i]);\n      }\n      remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function (layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function (baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n      this._preventClick = false;\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function (map) {\n      this._initLayout();\n      this._update();\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n      return this._container;\n    },\n    addTo: function (map) {\n      Control.prototype.addTo.call(this, map);\n      // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function () {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function (layer, name) {\n      this._addLayer(layer, name);\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function (layer, name) {\n      this._addLayer(layer, name, true);\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function (layer) {\n      layer.off('add remove', this._onLayerChange, this);\n      var obj = this._getLayer(stamp(layer));\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function () {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n      this._checkDisabledLayers();\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function () {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function () {\n      var className = 'leaflet-control-layers',\n        container = this._container = create$1('div', className),\n        collapsed = this.options.collapsed;\n\n      // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n        on(container, {\n          mouseenter: this._expandSafely,\n          mouseleave: this.collapse\n        }, this);\n      }\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n      link.setAttribute('role', 'button');\n      on(link, {\n        keydown: function (e) {\n          if (e.keyCode === 13) {\n            this._expandSafely();\n          }\n        },\n        // Certain screen readers intercept the key event and instead send a click event\n        click: function (e) {\n          preventDefault(e);\n          this._expandSafely();\n        }\n      }, this);\n      if (!collapsed) {\n        this.expand();\n      }\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function (id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function (layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n      this._expandIfNotCollapsed();\n    },\n    _update: function () {\n      if (!this._container) {\n        return this;\n      }\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n        overlaysPresent,\n        i,\n        obj,\n        baseLayersCount = 0;\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n        this._addItem(obj);\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      }\n\n      // Hide base layers section if there's only one layer.\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function (e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n      var obj = this._getLayer(stamp(e.target));\n\n      // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layers control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layers control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layers control](#control-layers).\n      // @namespace Control.Layers\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\n    _createRadioElement: function (name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function (obj) {\n      var label = document.createElement('label'),\n        checked = this._map.hasLayer(obj.layer),\n        input;\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n      this._layerControlInputs.push(input);\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name;\n\n      // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n      var holder = document.createElement('span');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n      this._checkDisabledLayers();\n      return label;\n    },\n    _onInputClick: function () {\n      // expanding the control on mobile with a click can cause adding a layer - we don't want this\n      if (this._preventClick) {\n        return;\n      }\n      var inputs = this._layerControlInputs,\n        input,\n        layer;\n      var addedLayers = [],\n        removedLayers = [];\n      this._handlingClick = true;\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      }\n\n      // Bugfix issue 2318: Should remove all old layers before readding new ones\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n      this._handlingClick = false;\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function () {\n      var inputs = this._layerControlInputs,\n        input,\n        layer,\n        zoom = this._map.getZoom();\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function () {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n      return this;\n    },\n    _expandSafely: function () {\n      var section = this._section;\n      this._preventClick = true;\n      on(section, 'click', preventDefault);\n      this.expand();\n      var that = this;\n      setTimeout(function () {\n        off(section, 'click', preventDefault);\n        that._preventClick = false;\n      });\n    }\n  });\n\n  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n  var layers = function (baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\n      // The text set on the 'zoom in' button.\n      zoomInText: '<span aria-hidden=\"true\">+</span>',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function (map) {\n      var zoomName = 'leaflet-control-zoom',\n        container = create$1('div', zoomName + ' leaflet-bar'),\n        options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n      this._updateDisabled();\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function () {\n      this._disabled = true;\n      this._updateDisabled();\n      return this;\n    },\n    enable: function () {\n      this._disabled = false;\n      this._updateDisabled();\n      return this;\n    },\n    _zoomIn: function (e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function (e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function (html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function () {\n      var map = this._map,\n        className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n      this._zoomInButton.setAttribute('aria-disabled', 'false');\n      this._zoomOutButton.setAttribute('aria-disabled', 'false');\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n        this._zoomOutButton.setAttribute('aria-disabled', 'true');\n      }\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n        this._zoomInButton.setAttribute('aria-disabled', 'true');\n      }\n    }\n  });\n\n  // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  });\n\n  // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n  var zoom = function (options) {\n    return new Zoom(options);\n  };\n\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true\n\n      // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n    },\n    onAdd: function (map) {\n      var className = 'leaflet-control-scale',\n        container = create$1('div', className),\n        options = this.options;\n      this._addScales(options, className + '-line', container);\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function (options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function () {\n      var map = this._map,\n        y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function (maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function (maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n        label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function (maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n        maxMiles,\n        miles,\n        feet;\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function (scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function (num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n        d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  });\n\n  // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n  var scale = function (options) {\n    return new Scale(options);\n  };\n  var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\n\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String|false = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function (map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container);\n\n      // TODO ugly, refactor\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n      this._update();\n      map.on('layeradd', this._addAttribution, this);\n      return this._container;\n    },\n    onRemove: function (map) {\n      map.off('layeradd', this._addAttribution, this);\n    },\n    _addAttribution: function (ev) {\n      if (ev.layer.getAttribution) {\n        this.addAttribution(ev.layer.getAttribution());\n        ev.layer.once('remove', function () {\n          this.removeAttribution(ev.layer.getAttribution());\n        }, this);\n      }\n    },\n    // @method setPrefix(prefix: String|false): this\n    // The HTML text shown before the attributions. Pass `false` to disable.\n    setPrefix: function (prefix) {\n      this.options.prefix = prefix;\n      this._update();\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).\n    addAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n      this._attributions[text]++;\n      this._update();\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n        this._update();\n      }\n      return this;\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n      var attribs = [];\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n      var prefixAndAttribs = [];\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n      this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\n    }\n  });\n\n  // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  });\n\n  // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n  var attribution = function (options) {\n    return new Attribution(options);\n  };\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function (map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function () {\n      if (this._enabled) {\n        return this;\n      }\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function () {\n      if (!this._enabled) {\n        return this;\n      }\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function () {\n      return !!this._enabled;\n    }\n\n    // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n  });\n\n  // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n  var Mixin = {\n    Events: Events\n  };\n\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function (element, dragStartTarget, preventOutline, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function () {\n      if (this._enabled) {\n        return;\n      }\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function () {\n      if (!this._enabled) {\n        return;\n      }\n\n      // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n      if (Draggable._dragging === this) {\n        this.finishDrag(true);\n      }\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function (e) {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      this._moved = false;\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n      if (e.touches && e.touches.length !== 1) {\n        // Finish dragging to avoid conflict with touchZoom\n        if (Draggable._dragging === this) {\n          this.finishDrag();\n        }\n        return;\n      }\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n      disableImageDrag();\n      disableTextSelection();\n      if (this._moving) {\n        return;\n      }\n\n      // @event down: Event\n      // Fired when a drag is about to start.\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n        sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY);\n      this._startPos = getPosition(this._element);\n\n      // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n      this._parentScale = getScale(sizedParent);\n      var mouseevent = e.type === 'mousedown';\n      on(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);\n      on(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);\n    },\n    _onMove: function (e) {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n        offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n      if (!offset.x && !offset.y) {\n        return;\n      }\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      }\n\n      // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement;\n        // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      this._lastEvent = e;\n      this._updatePosition();\n    },\n    _updatePosition: function () {\n      var e = {\n        originalEvent: this._lastEvent\n      };\n\n      // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos);\n\n      // @event drag: Event\n      // Fired continuously during dragging.\n      this.fire('drag', e);\n    },\n    _onUp: function () {\n      // Ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (!this._enabled) {\n        return;\n      }\n      this.finishDrag();\n    },\n    finishDrag: function (noInertia) {\n      removeClass(document.body, 'leaflet-dragging');\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n      off(document, 'mousemove touchmove', this._onMove, this);\n      off(document, 'mouseup touchend touchcancel', this._onUp, this);\n      enableImageDrag();\n      enableTextSelection();\n      var fireDragend = this._moved && this._moving;\n      this._moving = false;\n      Draggable._dragging = false;\n      if (fireDragend) {\n        // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n        this.fire('dragend', {\n          noInertia: noInertia,\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n    }\n  });\n\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n      edges = [1, 4, 2, 8],\n      i,\n      j,\n      k,\n      a,\n      b,\n      len,\n      edge,\n      p;\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    }\n\n    // for each edge (left, bottom, right, top)\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j];\n\n        // if a is inside the clip window\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n          clippedPoints.push(a);\n\n          // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n      points = clippedPoints;\n    }\n    return points;\n  }\n\n  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.\r\n   */\n  function polygonCenter(latlngs, crs) {\n    var i, j, p1, p2, f, area, x, y, center;\n    if (!latlngs || latlngs.length === 0) {\n      throw new Error('latlngs not passed');\n    }\n    if (!isFlat(latlngs)) {\n      console.warn('latlngs are not flat! Only the first ring will be used');\n      latlngs = latlngs[0];\n    }\n    var centroidLatLng = toLatLng([0, 0]);\n    var bounds = toLatLngBounds(latlngs);\n    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n    // tests showed that below 1700 rounding errors are happening\n    if (areaBounds < 1700) {\n      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n      centroidLatLng = centroid(latlngs);\n    }\n    var len = latlngs.length;\n    var points = [];\n    for (i = 0; i < len; i++) {\n      var latlng = toLatLng(latlngs[i]);\n      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\n    }\n    area = x = y = 0;\n\n    // polygon centroid algorithm;\n    for (i = 0, j = len - 1; i < len; j = i++) {\n      p1 = points[i];\n      p2 = points[j];\n      f = p1.y * p2.x - p2.y * p1.x;\n      x += (p1.x + p2.x) * f;\n      y += (p1.y + p2.y) * f;\n      area += f * 3;\n    }\n    if (area === 0) {\n      // Polygon is so small that all points are on same pixel.\n      center = points[0];\n    } else {\n      center = [x / area, y / area];\n    }\n    var latlngCenter = crs.unproject(toPoint(center));\n    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\n  }\n\n  /* @function centroid(latlngs: LatLng[]): LatLng\r\n   * Returns the 'center of mass' of the passed LatLngs.\r\n   */\n  function centroid(coords) {\n    var latSum = 0;\n    var lngSum = 0;\n    var len = 0;\n    for (var i = 0; i < coords.length; i++) {\n      var latlng = toLatLng(coords[i]);\n      latSum += latlng.lat;\n      lngSum += latlng.lng;\n      len++;\n    }\n    return toLatLng([latSum / len, lngSum / len]);\n  }\n  var PolyUtil = {\n    __proto__: null,\n    clipPolygon: clipPolygon,\n    polygonCenter: polygonCenter,\n    centroid: centroid\n  };\n\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n    var sqTolerance = tolerance * tolerance;\n\n    // stage 1: vertex reduction\n    points = _reducePoints(points, sqTolerance);\n\n    // stage 2: Douglas-Peucker simplification\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  }\n\n  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  }\n\n  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  }\n\n  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n      ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\n      markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n    var i,\n      newPoints = [];\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n    return newPoints;\n  }\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n      index,\n      i,\n      sqDist;\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  }\n\n  // reduce points that are too close to each other to a single point\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n    return reducedPoints;\n  }\n  var _lastCode;\n\n  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n      codeB = _getBitCode(b, bounds),\n      codeOut,\n      p,\n      newCode;\n\n    // save 2nd code to avoid calculating it on the next segment\n    _lastCode = codeB;\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      }\n\n      // if a,b is outside the clip window (trivial reject)\n      if (codeA & codeB) {\n        return false;\n      }\n\n      // other cases\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n      dy = b.y - a.y,\n      min = bounds.min,\n      max = bounds.max,\n      x,\n      y;\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n    return new Point(x, y, round);\n  }\n  function _getBitCode(p, bounds) {\n    var code = 0;\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n    return code;\n  }\n\n  // square distance (to avoid unnecessary Math.sqrt calls)\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n      dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  }\n\n  // return closest point on segment or distance to that point\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n      y = p1.y,\n      dx = p2.x - x,\n      dy = p2.y - y,\n      dot = dx * dx + dy * dy,\n      t;\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  }\n\n  // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.\r\n   */\n  function polylineCenter(latlngs, crs) {\n    var i, halfDist, segDist, dist, p1, p2, ratio, center;\n    if (!latlngs || latlngs.length === 0) {\n      throw new Error('latlngs not passed');\n    }\n    if (!isFlat(latlngs)) {\n      console.warn('latlngs are not flat! Only the first ring will be used');\n      latlngs = latlngs[0];\n    }\n    var centroidLatLng = toLatLng([0, 0]);\n    var bounds = toLatLngBounds(latlngs);\n    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n    // tests showed that below 1700 rounding errors are happening\n    if (areaBounds < 1700) {\n      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n      centroidLatLng = centroid(latlngs);\n    }\n    var len = latlngs.length;\n    var points = [];\n    for (i = 0; i < len; i++) {\n      var latlng = toLatLng(latlngs[i]);\n      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\n    }\n    for (i = 0, halfDist = 0; i < len - 1; i++) {\n      halfDist += points[i].distanceTo(points[i + 1]) / 2;\n    }\n\n    // The line is so small in the current view that all points are on the same pixel.\n    if (halfDist === 0) {\n      center = points[0];\n    } else {\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          center = [p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)];\n          break;\n        }\n      }\n    }\n    var latlngCenter = crs.unproject(toPoint(center));\n    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\n  }\n  var LineUtil = {\n    __proto__: null,\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat,\n    polylineCenter: polylineCenter\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection — the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function (latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function (point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function (latlng) {\n      var d = Math.PI / 180,\n        r = this.R,\n        y = latlng.lat * d,\n        tmp = this.R_MINOR / r,\n        e = Math.sqrt(1 - tmp * tmp),\n        con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI,\n        r = this.R,\n        tmp = this.R_MINOR / r,\n        e = Math.sqrt(1 - tmp * tmp),\n        ts = Math.exp(-point.y / r),\n        phi = Math.PI / 2 - 2 * Math.atan(ts);\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n\n  /*\n   * @class Projection\n    * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n    * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n    * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n    * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n    * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n    */\n\n  var index = {\n    __proto__: null,\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  };\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function (zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function (scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function (latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n        dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \"© OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function (map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function () {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    //\n    // @alternative\n    // @method removeFrom(group: LayerGroup): this\n    // Removes the layer from the given `LayerGroup`\n    removeFrom: function (obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function (name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function (targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function (targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function () {\n      return this.options.attribution;\n    },\n    _layerAdd: function (e) {\n      var map = e.target;\n\n      // check in case layer gets added and then removed before the map is ready\n      if (!map.hasLayer(this)) {\n        return;\n      }\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n      this.onAdd(map);\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function (layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n      var id = stamp(layer);\n      if (this._layers[id]) {\n        return this;\n      }\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function (layer) {\n      var id = stamp(layer);\n      if (!this._layers[id]) {\n        return this;\n      }\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n      delete this._layers[id];\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function (layer) {\n      return stamp(layer) in this._layers;\n    },\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    _addLayers: function (layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function (layer) {\n      if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function (layer) {\n      var id = stamp(layer);\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function () {\n      var minZoom = Infinity,\n        maxZoom = -Infinity,\n        oldZoomSpan = this._getZoomSpan();\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n      // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function (layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function (layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function (layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function (layer) {\n      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);\n      return layerId in this._layers;\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function () {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, …): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function (methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        i,\n        layer;\n      for (i in this._layers) {\n        layer = this._layers[i];\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n      return this;\n    },\n    onAdd: function (map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function (map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function (id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function () {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function (zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function (layer) {\n      return stamp(layer);\n    }\n  });\n\n  // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n  var layerGroup = function (layers, options) {\n    return new LayerGroup(layers, options);\n  };\n\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function (layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer);\n\n      // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function (layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer);\n\n      // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function (style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function () {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function () {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function () {\n      var bounds = new LatLngBounds();\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n      return bounds;\n    }\n  });\n\n  // @factory L.featureGroup(layers?: Layer[], options?: Object)\n  // Create a feature group, optionally given an initial set of layers and an `options` object.\n  var featureGroup = function (layers, options) {\n    return new FeatureGroup(layers, options);\n  };\n\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0],\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function (oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function (oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function (name, oldIcon) {\n      var src = this._getIconUrl(name);\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n        return null;\n      }\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n      this._setIconStyles(img, name);\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      return img;\n    },\n    _setIconStyles: function (img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n      var size = toPoint(sizeOption),\n        anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function (src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function (name) {\n      return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  });\n\n  // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n  function icon(options) {\n    return new Icon(options);\n  }\n\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function (name) {\n      if (typeof IconDefault.imagePath !== 'string') {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      }\n\n      // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _stripUrl: function (path) {\n      // separate function to use in tests\n      var strip = function (str, re, idx) {\n        var match = re.exec(str);\n        return match && match[idx];\n      };\n      path = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n      return path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n    },\n    _detectIconPath: function () {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n      path = this._stripUrl(path);\n      if (path) {\n        return path;\n      }\n      var link = document.querySelector('link[href$=\"leaflet.css\"]');\n      if (!link) {\n        return '';\n      }\n      return link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);\n    }\n  });\n\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function (marker) {\n      this._marker = marker;\n    },\n    addHooks: function () {\n      var icon = this._marker._icon;\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function () {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function (e) {\n      var marker = this._marker,\n        map = marker._map,\n        speed = this._marker.options.autoPanSpeed,\n        padding = this._marker.options.autoPanPadding,\n        iconPos = getPosition(marker._icon),\n        bounds = map.getPixelBounds(),\n        origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n        this._draggable._newPos._add(movement);\n        this._draggable._startPos._add(movement);\n        setPosition(marker._icon, this._draggable._newPos);\n        this._onDrag(e);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function () {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n\n      this._oldLatLng = this._marker.getLatLng();\n\n      // When using ES6 imports it could not be set when `Popup` was not imported as well\n      this._marker.closePopup && this._marker.closePopup();\n      this._marker.fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function (e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function (e) {\n      var marker = this._marker,\n        shadow = marker._shadow,\n        iconPos = getPosition(marker._icon),\n        latlng = marker._map.layerPointToLatLng(iconPos);\n\n      // update shadow position\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng;\n\n      // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function (e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n\n      cancelAnimFrame(this._panRequest);\n\n      // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n      delete this._oldLatLng;\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n      title: '',\n      // @option alt: String = 'Marker'\n      // Text for the `alt` attribute of the icon image.\n      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n      alt: 'Marker',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option shadowPane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @option autoPanOnFocus: Boolean = true\n      // When `true`, the map will pan whenever the marker is focused (via\n      // e.g. pressing `tab` on the keyboard) to ensure the marker is\n      // visible within the map's bounds\n      autoPanOnFocus: true,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n      this._initIcon();\n      this.update();\n    },\n    onRemove: function (map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n      delete this.dragging;\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n      this._removeIcon();\n      this._removeShadow();\n    },\n    getEvents: function () {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update();\n\n      // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function (offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function () {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function (icon) {\n      this.options.icon = icon;\n      if (this._map) {\n        this._initIcon();\n        this.update();\n      }\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n      return this;\n    },\n    getElement: function () {\n      return this._icon;\n    },\n    update: function () {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n        this._setPos(pos);\n      }\n      return this;\n    },\n    _initIcon: function () {\n      var options = this.options,\n        classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n        addIcon = false;\n\n      // if we're not reusing the icon, remove the old one and init new one\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n        addIcon = true;\n        if (options.title) {\n          icon.title = options.title;\n        }\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n      addClass(icon, classToAdd);\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n        icon.setAttribute('role', 'button');\n      }\n      this._icon = icon;\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n      if (this.options.autoPanOnFocus) {\n        on(icon, 'focus', this._panOnFocus, this);\n      }\n      var newShadow = options.icon.createShadow(this._shadow),\n        addShadow = false;\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n        addShadow = true;\n      }\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n      this._shadow = newShadow;\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n      this._initInteraction();\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function () {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n      if (this.options.autoPanOnFocus) {\n        off(this._icon, 'focus', this._panOnFocus, this);\n      }\n      remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function () {\n      if (this._shadow) {\n        remove(this._shadow);\n      }\n      this._shadow = null;\n    },\n    _setPos: function (pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n      this._zIndex = pos.y + this.options.zIndexOffset;\n      this._resetZIndex();\n    },\n    _updateZIndex: function (offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function (opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n      this._setPos(pos);\n    },\n    _initInteraction: function () {\n      if (!this.options.interactive) {\n        return;\n      }\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n        this.dragging = new MarkerDrag(this);\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n      if (this._map) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    _updateOpacity: function () {\n      var opacity = this.options.opacity;\n      if (this._icon) {\n        setOpacity(this._icon, opacity);\n      }\n      if (this._shadow) {\n        setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function () {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function () {\n      this._updateZIndex(0);\n    },\n    _panOnFocus: function () {\n      var map = this._map;\n      if (!map) {\n        return;\n      }\n      var iconOpts = this.options.icon.options;\n      var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\n      var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\n      map.panInside(this._latlng, {\n        paddingTopLeft: anchor,\n        paddingBottomRight: size.subtract(anchor)\n      });\n    },\n    _getPopupAnchor: function () {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function () {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  });\n\n  // factory L.marker(latlng: LatLng, options? : Marker options)\n\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function (map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function () {\n      this._renderer._initPath(this);\n      this._reset();\n      this._renderer._addPath(this);\n    },\n    onRemove: function () {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function () {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function (style) {\n      setOptions(this, style);\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {\n          this._updateBounds();\n        }\n      }\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function () {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function () {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n      return this;\n    },\n    getElement: function () {\n      return this._path;\n    },\n    _reset: function () {\n      // defined in child classes\n      this._project();\n      this._update();\n    },\n    _clickTolerance: function () {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);\n    }\n  });\n\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw();\n\n      // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function (radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function () {\n      return this._radius;\n    },\n    setStyle: function (options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function () {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n      this._updateBounds();\n    },\n    _updateBounds: function () {\n      var r = this._radius,\n        r2 = this._radiusY || r,\n        w = this._clickTolerance(),\n        p = [r + w, r2 + w];\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function () {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function () {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  });\n\n  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n  var Circle = CircleMarker.extend({\n    initialize: function (latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      }\n\n      // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function (radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function () {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function () {\n      var lng = this._latlng.lng,\n        lat = this._latlng.lat,\n        map = this._map,\n        crs = map.options.crs;\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n          latR = this._mRadius / Earth.R / d,\n          top = map.project([lat + latR, lng]),\n          bottom = map.project([lat - latR, lng]),\n          p = top.add(bottom).divideBy(2),\n          lat2 = map.unproject(p).lat,\n          lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n      this._updateBounds();\n    }\n  });\n\n  // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function (latlngs, options) {\n      setOptions(this, options);\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function () {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function (latlngs) {\n      this._setLatLngs(latlngs);\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function () {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function (p) {\n      var minDistance = Infinity,\n        minPoint = null,\n        closest = _sqClosestPointOnSegment,\n        p1,\n        p2;\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n      return polylineCenter(this._defaultShape(), this._map.options.crs);\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function (latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n      this._bounds.extend(latlng);\n      return this.redraw();\n    },\n    _setLatLngs: function (latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function (latlngs) {\n      var result = [],\n        flat = isFlat(latlngs);\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n      return result;\n    },\n    _project: function () {\n      var pxBounds = new Bounds();\n      this._rings = [];\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function () {\n      var w = this._clickTolerance(),\n        p = new Point(w, w);\n      if (!this._rawPxBounds) {\n        return;\n      }\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function (latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n        len = latlngs.length,\n        i,\n        ring;\n      if (flat) {\n        ring = [];\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function () {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n      var parts = this._parts,\n        i,\n        j,\n        k,\n        len,\n        len2,\n        segment,\n        points;\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n          if (!segment) {\n            continue;\n          }\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]);\n\n          // if segment goes out of screen, or it's the last one, it's the end of the line part\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function () {\n      var parts = this._parts,\n        tolerance = this.options.smoothFactor;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n      this._clipPoints();\n      this._simplifyPoints();\n      this._updatePath();\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p, closed) {\n      var i,\n        j,\n        k,\n        len,\n        len2,\n        part,\n        w = this._clickTolerance();\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      }\n\n      // hit detection for polylines\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  });\n\n  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  }\n\n  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n  Polyline._flat = _flat;\n\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function () {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n      return polygonCenter(this._defaultShape(), this._map.options.crs);\n    },\n    _convertLatLngs: function (latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n        len = result.length;\n\n      // remove last point if it equals first one\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n      return result;\n    },\n    _setLatLngs: function (latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function () {\n      // polygons need a different clipping algorithm so we redefine that\n\n      var bounds = this._renderer._bounds,\n        w = this.options.weight,\n        p = new Point(w, w);\n\n      // increase clip padding by stroke width to avoid stroke on clip edges\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      var inside = false,\n        part,\n        p1,\n        p2,\n        i,\n        j,\n        k,\n        len,\n        len2;\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      }\n\n      // ray casting algorithm for detecting if point is in polygon\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      }\n\n      // also check if it's on polygon stroke\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  });\n\n  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n\n    initialize: function (geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function (geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n        i,\n        len,\n        feature;\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n        return this;\n      }\n      var options = this.options;\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n      var layer = geometryToLayer(geojson, options);\n      if (!layer) {\n        return this;\n      }\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function (layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      }\n      // reset any custom styles\n      layer.options = extend({}, layer.defaultOptions);\n      this._setLayerStyle(layer, this.options.style);\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function (style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function (layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n        layer.setStyle(style);\n      }\n    }\n  });\n\n  // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n      coords = geometry ? geometry.coordinates : null,\n      layers = [],\n      pointToLayer = options && options.pointToLayer,\n      _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n      latlng,\n      latlngs,\n      i,\n      len;\n    if (!coords && !geometry) {\n      return null;\n    }\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n        return new FeatureGroup(layers);\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var geoLayer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n          if (geoLayer) {\n            layers.push(geoLayer);\n          }\n        }\n        return new FeatureGroup(layers);\n      case 'FeatureCollection':\n        for (i = 0, len = geometry.features.length; i < len; i++) {\n          var featureLayer = geometryToLayer(geometry.features[i], options);\n          if (featureLayer) {\n            layers.push(featureLayer);\n          }\n        }\n        return new FeatureGroup(layers);\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  }\n\n  // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  }\n\n  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n    return latlngs;\n  }\n\n  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n  function latLngToCoords(latlng, precision) {\n    latlng = toLatLng(latlng);\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  }\n\n  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      // Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n    if (!levelsDeep && closed && coords.length > 0) {\n      coords.push(coords[0].slice());\n    }\n    return coords;\n  }\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  }\n\n  // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n  var PointToGeoJSON = {\n    toGeoJSON: function (precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  };\n\n  // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n  Marker.include(PointToGeoJSON);\n\n  // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON);\n\n  // @namespace Polyline\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n  Polyline.include({\n    toGeoJSON: function (precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  });\n\n  // @namespace Polygon\n  // @method toGeoJSON(precision?: Number|false): Object\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n  Polygon.include({\n    toGeoJSON: function (precision) {\n      var holes = !isFlat(this._latlngs),\n        multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n      if (!holes) {\n        coords = [coords];\n      }\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  });\n\n  // @namespace LayerGroup\n  LayerGroup.include({\n    toMultiPoint: function (precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function (precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n      var isGeometryCollection = type === 'GeometryCollection',\n        jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json);\n            // Squash nested feature collections\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  });\n\n  // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  }\n\n  // Backward compatibility.\n  var geoJson = geoJSON;\n\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function (url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      if (!this._image) {\n        this._initImage();\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n      this.getPane().appendChild(this._image);\n      this._reset();\n    },\n    onRemove: function () {\n      remove(this._image);\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n      if (this._image) {\n        this._updateOpacity();\n      }\n      return this;\n    },\n    setStyle: function (styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._image);\n      }\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._image);\n      }\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function (url) {\n      this._url = url;\n      if (this._image) {\n        this._image.src = url;\n      }\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function (bounds) {\n      this._bounds = toLatLngBounds(bounds);\n      if (this._map) {\n        this._reset();\n      }\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function (value) {\n      this.options.zIndex = value;\n      this._updateZIndex();\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function () {\n      return this._image;\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn;\n\n      // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function (e) {\n      var scale = this._map.getZoomScale(e.zoom),\n        offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function () {\n      var image = this._image,\n        bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n        size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function () {\n      setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function () {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function () {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    },\n    // @method getCenter(): LatLng\n    // Returns the center of the ImageOverlay.\n    getCenter: function () {\n      return this._bounds.getCenter();\n    }\n  });\n\n  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n  var imageOverlay = function (url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      // On some browsers autoplay will only work with `muted: true`\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\n      keepAspectRatio: true,\n      // @option muted: Boolean = false\n      // Whether the video starts on mute when loaded.\n      muted: false,\n      // @option playsInline: Boolean = true\n      // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\n      playsInline: true\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn;\n\n      // @event load: Event\n      // Fired when the video has finished loading the first frame\n      vid.onloadeddata = bind(this.fire, this, 'load');\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n      vid.muted = !!this.options.muted;\n      vid.playsInline = !!this.options.playsInline;\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    }\n\n    // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n  });\n\n  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function () {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    }\n\n    // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n  });\n\n  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */\n\n  // @namespace DivOverlay\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option interactive: Boolean = false\n      // If true, the popup/tooltip will listen to the mouse events.\n      interactive: false,\n      // @option offset: Point = Point(0, 0)\n      // The offset of the overlay position.\n      offset: [0, 0],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the overlay.\n      className: '',\n      // @option pane: String = undefined\n      // `Map pane` where the overlay will be added.\n      pane: undefined,\n      // @option content: String|HTMLElement|Function = ''\n      // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be\n      // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.\n      content: ''\n    },\n    initialize: function (options, source) {\n      if (options && (options instanceof LatLng || isArray(options))) {\n        this._latlng = toLatLng(options);\n        setOptions(this, source);\n      } else {\n        setOptions(this, options);\n        this._source = source;\n      }\n      if (this.options.content) {\n        this._content = this.options.content;\n      }\n    },\n    // @method openOn(map: Map): this\n    // Adds the overlay to the map.\n    // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\n    openOn: function (map) {\n      map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n      if (!map.hasLayer(this)) {\n        map.addLayer(this);\n      }\n      return this;\n    },\n    // @method close(): this\n    // Closes the overlay.\n    // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\n    // and `layer.closePopup()`/`.closeTooltip()`.\n    close: function () {\n      if (this._map) {\n        this._map.removeLayer(this);\n      }\n      return this;\n    },\n    // @method toggle(layer?: Layer): this\n    // Opens or closes the overlay bound to layer depending on its current state.\n    // Argument may be omitted only for overlay bound to layer.\n    // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\n    toggle: function (layer) {\n      if (this._map) {\n        this.close();\n      } else {\n        if (arguments.length) {\n          this._source = layer;\n        } else {\n          layer = this._source;\n        }\n        this._prepareOpen();\n\n        // open the overlay on the map\n        this.openOn(layer._map);\n      }\n      return this;\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = map._zoomAnimated;\n      if (!this._container) {\n        this._initLayout();\n      }\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n      }\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 1);\n      }\n      this.bringToFront();\n      if (this.options.interactive) {\n        addClass(this._container, 'leaflet-interactive');\n        this.addInteractiveTarget(this._container);\n      }\n    },\n    onRemove: function (map) {\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n      } else {\n        remove(this._container);\n      }\n      if (this.options.interactive) {\n        removeClass(this._container, 'leaflet-interactive');\n        this.removeInteractiveTarget(this._container);\n      }\n    },\n    // @namespace DivOverlay\n    // @method getLatLng: LatLng\n    // Returns the geographical point of the overlay.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the overlay will open.\n    setLatLng: function (latlng) {\n      this._latlng = toLatLng(latlng);\n      if (this._map) {\n        this._updatePosition();\n        this._adjustPan();\n      }\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the overlay.\n    getContent: function () {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\n    // The function should return a `String` or `HTMLElement` to be used in the overlay.\n    setContent: function (content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Returns the HTML container of the overlay.\n    getElement: function () {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\n    update: function () {\n      if (!this._map) {\n        return;\n      }\n      this._container.style.visibility = 'hidden';\n      this._updateContent();\n      this._updateLayout();\n      this._updatePosition();\n      this._container.style.visibility = '';\n      this._adjustPan();\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the overlay is visible on the map.\n    isOpen: function () {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this overlay in front of other overlays (in the same map pane).\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n      }\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this overlay to the back of other overlays (in the same map pane).\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n      }\n      return this;\n    },\n    // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\n    _prepareOpen: function (latlng) {\n      var source = this._source;\n      if (!source._map) {\n        return false;\n      }\n      if (source instanceof FeatureGroup) {\n        source = null;\n        var layers = this._source._layers;\n        for (var id in layers) {\n          if (layers[id]._map) {\n            source = layers[id];\n            break;\n          }\n        }\n        if (!source) {\n          return false;\n        } // Unable to get source layer.\n\n        // set overlay source to this layer\n        this._source = source;\n      }\n      if (!latlng) {\n        if (source.getCenter) {\n          latlng = source.getCenter();\n        } else if (source.getLatLng) {\n          latlng = source.getLatLng();\n        } else if (source.getBounds) {\n          latlng = source.getBounds().getCenter();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      }\n      this.setLatLng(latlng);\n      if (this._map) {\n        // update the overlay (content, layout, etc...)\n        this.update();\n      }\n      return true;\n    },\n    _updateContent: function () {\n      if (!this._content) {\n        return;\n      }\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n        node.appendChild(content);\n      }\n\n      // @namespace DivOverlay\n      // @section DivOverlay events\n      // @event contentupdate: Event\n      // Fired when the content of the overlay is updated\n      this.fire('contentupdate');\n    },\n    _updatePosition: function () {\n      if (!this._map) {\n        return;\n      }\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n        offset = toPoint(this.options.offset),\n        anchor = this._getAnchor();\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n      var bottom = this._containerBottom = -offset.y,\n        left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\n\n      // bottom position the overlay in case the height of the overlay changes (images loading etc)\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function () {\n      return [0, 0];\n    }\n  });\n  Map.include({\n    _initOverlay: function (OverlayClass, content, latlng, options) {\n      var overlay = content;\n      if (!(overlay instanceof OverlayClass)) {\n        overlay = new OverlayClass(options).setContent(content);\n      }\n      if (latlng) {\n        overlay.setLatLng(latlng);\n      }\n      return overlay;\n    }\n  });\n  Layer.include({\n    _initOverlay: function (OverlayClass, old, content, options) {\n      var overlay = content;\n      if (overlay instanceof OverlayClass) {\n        setOptions(overlay, options);\n        overlay._source = this;\n      } else {\n        overlay = old && !options ? old : new OverlayClass(options, this);\n        overlay.setContent(content);\n      }\n      return overlay;\n    }\n  });\n\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   *\r\n   * A popup can be also standalone:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   * or\r\n   * ```js\r\n   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n\n  // @namespace Popup\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane',\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position.\n      offset: [0, 7],\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      // The scrollable container can be styled using the\n      // `leaflet-popup-scrolled` CSS class selector.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Alternative to `map.openPopup(popup)`.\n    // Adds the popup to the map and closes the previous one.\n    openOn: function (map) {\n      map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n\n      if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\n        map.removeLayer(map._popup);\n      }\n      map._popup = this;\n      return DivOverlay.prototype.openOn.call(this, map);\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n\n      // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n      map.fire('popupopen', {\n        popup: this\n      });\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true);\n        // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map);\n\n      // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n      map.fire('popupclose', {\n        popup: this\n      });\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this.close;\n      }\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n      return events;\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-popup',\n        container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(container);\n      disableScrollPropagation(this._contentNode);\n      on(container, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399\n        closeButton.setAttribute('aria-label', 'Close popup');\n        closeButton.href = '#close';\n        closeButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\n        on(closeButton, 'click', function (ev) {\n          preventDefault(ev);\n          this.close();\n        }, this);\n      }\n    },\n    _updateLayout: function () {\n      var container = this._contentNode,\n        style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n        maxHeight = this.options.maxHeight,\n        scrolledClass = 'leaflet-popup-scrolled';\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n        anchor = this._getAnchor();\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function () {\n      if (!this.options.autoPan) {\n        return;\n      }\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      // We can endlessly recurse if keepInView is set and the view resets.\n      // Let's guard against that by exiting early if we're responding to our own autopan.\n      if (this._autopanning) {\n        this._autopanning = false;\n        return;\n      }\n      var map = this._map,\n        marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n        containerHeight = this._container.offsetHeight + marginBottom,\n        containerWidth = this._containerWidth,\n        layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n      layerPos._add(getPosition(this._container));\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n        padding = toPoint(this.options.autoPanPadding),\n        paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n        paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n        size = map.getSize(),\n        dx = 0,\n        dy = 0;\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      }\n\n      // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n      if (dx || dy) {\n        // Track that we're autopanning, as this function will be re-ran on moveend\n        if (this.options.keepInView) {\n          this._autopanning = true;\n        }\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _getAnchor: function () {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  });\n\n  // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.popup(latlng: LatLng, options?: Popup options)\n  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.\n  var popup = function (options, source) {\n    return new Popup(options, source);\n  };\n\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n  Map.mergeOptions({\n    closePopupOnClick: true\n  });\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function (popup, latlng, options) {\n      this._initOverlay(Popup, popup, latlng, options).openOn(this);\n      return this;\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function (popup) {\n      popup = arguments.length ? popup : this._popup;\n      if (popup) {\n        popup.close();\n      }\n      return this;\n    }\n  });\n\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n\n  // @section Popup methods\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function (content, options) {\n      this._popup = this._initOverlay(Popup, this._popup, content, options);\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function () {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function (latlng) {\n      if (this._popup) {\n        if (!(this instanceof FeatureGroup)) {\n          this._popup._source = this;\n        }\n        if (this._popup._prepareOpen(latlng || this._latlng)) {\n          // open the popup on the map\n          this._popup.openOn(this._map);\n        }\n      }\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function () {\n      if (this._popup) {\n        this._popup.close();\n      }\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function () {\n      if (this._popup) {\n        this._popup.toggle(this);\n      }\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function () {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function (content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function () {\n      return this._popup;\n    },\n    _openPopup: function (e) {\n      if (!this._popup || !this._map) {\n        return;\n      }\n      // prevent map click\n      stop(e);\n      var target = e.layer || e.target;\n      if (this._popup._source === target && !(target instanceof Path)) {\n        // treat it like a marker and figure out\n        // if we should toggle it open/closed\n        if (this._map.hasLayer(this._popup)) {\n          this.closePopup();\n        } else {\n          this.openPopup(e.latlng);\n        }\n        return;\n      }\n      this._popup._source = target;\n      this.openPopup(e.latlng);\n    },\n    _movePopup: function (e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function (e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   * If you want to just bind a tooltip to marker:\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Path overlays like polylines also have a `bindTooltip` method.\n   *\n   * A tooltip can be also standalone:\n   *\n   * ```js\n   * var tooltip = L.tooltip()\n   * \t.setLatLng(latlng)\n   * \t.setContent('Hello world!<br />This is a nice tooltip.')\n   * \t.addTo(map);\n   * ```\n   * or\n   * ```js\n   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})\n   * \t.addTo(map);\n   * ```\n   *\n   *\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n\n  // @namespace Tooltip\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity);\n\n      // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n      if (this._source) {\n        this.addEventParent(this._source);\n\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map);\n\n      // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n      if (this._source) {\n        this.removeEventParent(this._source);\n\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n      if (!this.options.permanent) {\n        events.preclick = this.close;\n      }\n      return events;\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-tooltip',\n        className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n      this._container.setAttribute('role', 'tooltip');\n      this._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));\n    },\n    _updateLayout: function () {},\n    _adjustPan: function () {},\n    _setPosition: function (pos) {\n      var subX,\n        subY,\n        map = this._map,\n        container = this._container,\n        centerPoint = map.latLngToContainerPoint(map.getCenter()),\n        tooltipPoint = map.layerPointToContainerPoint(pos),\n        direction = this.options.direction,\n        tooltipWidth = container.offsetWidth,\n        tooltipHeight = container.offsetHeight,\n        offset = toPoint(this.options.offset),\n        anchor = this._getAnchor();\n      if (direction === 'top') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight;\n      } else if (direction === 'bottom') {\n        subX = tooltipWidth / 2;\n        subY = 0;\n      } else if (direction === 'center') {\n        subX = tooltipWidth / 2;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'right') {\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else if (direction === 'left') {\n        subX = tooltipWidth;\n        subY = tooltipHeight / 2;\n      } else if (tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        subX = 0;\n        subY = tooltipHeight / 2;\n      } else {\n        direction = 'left';\n        subX = tooltipWidth + (offset.x + anchor.x) * 2;\n        subY = tooltipHeight / 2;\n      }\n      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function () {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n      this._setPosition(pos);\n    },\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n      if (this._container) {\n        setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n      this._setPosition(pos);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  });\n\n  // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)\n  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.\n  var tooltip = function (options, source) {\n    return new Tooltip(options, source);\n  };\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function (tooltip, latlng, options) {\n      this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);\n      return this;\n    },\n    // @method closeTooltip(tooltip: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function (tooltip) {\n      tooltip.close();\n      return this;\n    }\n  });\n\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n\n  // @section Tooltip methods\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function (content, options) {\n      if (this._tooltip && this.isTooltipOpen()) {\n        this.unbindTooltip();\n      }\n      this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n      this._initTooltipInteractions();\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function () {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n      return this;\n    },\n    _initTooltipInteractions: function (remove) {\n      if (!remove && this._tooltipHandlersAdded) {\n        return;\n      }\n      var onOff = remove ? 'off' : 'on',\n        events = {\n          remove: this.closeTooltip,\n          move: this._moveTooltip\n        };\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n        events.click = this._openTooltip;\n        if (this._map) {\n          this._addFocusListeners();\n        } else {\n          events.add = this._addFocusListeners;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n      if (this._tooltip.options.sticky) {\n        events.mousemove = this._moveTooltip;\n      }\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function (latlng) {\n      if (this._tooltip) {\n        if (!(this instanceof FeatureGroup)) {\n          this._tooltip._source = this;\n        }\n        if (this._tooltip._prepareOpen(latlng)) {\n          // open the tooltip on the map\n          this._tooltip.openOn(this._map);\n          if (this.getElement) {\n            this._setAriaDescribedByOnLayer(this);\n          } else if (this.eachLayer) {\n            this.eachLayer(this._setAriaDescribedByOnLayer, this);\n          }\n        }\n      }\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function () {\n      if (this._tooltip) {\n        return this._tooltip.close();\n      }\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function () {\n      if (this._tooltip) {\n        this._tooltip.toggle(this);\n      }\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function () {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function (content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function () {\n      return this._tooltip;\n    },\n    _addFocusListeners: function () {\n      if (this.getElement) {\n        this._addFocusListenersOnLayer(this);\n      } else if (this.eachLayer) {\n        this.eachLayer(this._addFocusListenersOnLayer, this);\n      }\n    },\n    _addFocusListenersOnLayer: function (layer) {\n      var el = typeof layer.getElement === 'function' && layer.getElement();\n      if (el) {\n        on(el, 'focus', function () {\n          this._tooltip._source = layer;\n          this.openTooltip();\n        }, this);\n        on(el, 'blur', this.closeTooltip, this);\n      }\n    },\n    _setAriaDescribedByOnLayer: function (layer) {\n      var el = typeof layer.getElement === 'function' && layer.getElement();\n      if (el) {\n        el.setAttribute('aria-describedby', this._tooltip._container.id);\n      }\n    },\n    _openTooltip: function (e) {\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      // If the map is moving, we will show the tooltip after it's done.\n      if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {\n        this._openOnceFlag = true;\n        var that = this;\n        this._map.once('moveend', function () {\n          that._openOnceFlag = false;\n          that._openTooltip(e);\n        });\n        return;\n      }\n      this._tooltip._source = e.layer || e.target;\n      this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function (e) {\n      var latlng = e.latlng,\n        containerPoint,\n        layerPoint;\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function (oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n        options = this.options;\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n      this._setIconStyles(div, 'icon');\n      return div;\n    },\n    createShadow: function () {\n      return null;\n    }\n  });\n\n  // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n  Icon.Default = IconDefault;\n\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: Browser.mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      this._initContainer();\n      this._levels = {};\n      this._tiles = {};\n      this._resetView(); // implicit _update() call\n    },\n    beforeAdd: function (map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function (map) {\n      this._removeAllTiles();\n      remove(this._container);\n      map._removeZoomLimit(this);\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n        this._setAutoZIndex(Math.max);\n      }\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n        this._setAutoZIndex(Math.min);\n      }\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n      this._updateOpacity();\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function (zIndex) {\n      this.options.zIndex = zIndex;\n      this._updateZIndex();\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function () {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function () {\n      if (this._map) {\n        this._removeAllTiles();\n        var tileZoom = this._clampZoom(this._map.getZoom());\n        if (tileZoom !== this._tileZoom) {\n          this._tileZoom = tileZoom;\n          this._updateLevels();\n        }\n        this._update();\n      }\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n        events.move = this._onMove;\n      }\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function () {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function () {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function () {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function (compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n      var layers = this.getPane().children,\n        edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function () {\n      if (!this._map) {\n        return;\n      }\n\n      // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n      if (Browser.ielt9) {\n        return;\n      }\n      setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n        nextFrame = false,\n        willPrune = false;\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        setOpacity(tile.el, fade);\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n          tile.active = true;\n        }\n      }\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function () {\n      if (this._container) {\n        return;\n      }\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n      this._updateZIndex();\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function () {\n      var zoom = this._tileZoom,\n        maxZoom = this.options.maxZoom;\n      if (zoom === undefined) {\n        return undefined;\n      }\n      for (var z in this._levels) {\n        z = Number(z);\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n          this._onUpdateLevel(z);\n        } else {\n          remove(this._levels[z].el);\n          this._removeTilesAtZoom(z);\n          this._onRemoveLevel(z);\n          delete this._levels[z];\n        }\n      }\n      var level = this._levels[zoom],\n        map = this._map;\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n        this._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n        // force the browser to consider the newly added element for transition\n        falseFn(level.el.offsetWidth);\n        this._onCreateLevel(level);\n      }\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function () {\n      if (!this._map) {\n        return;\n      }\n      var key, tile;\n      var zoom = this._map.getZoom();\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n        return;\n      }\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function (zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function () {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function () {\n      for (var z in this._levels) {\n        remove(this._levels[z].el);\n        this._onRemoveLevel(Number(z));\n        delete this._levels[z];\n      }\n      this._removeAllTiles();\n      this._tileZoom = undefined;\n    },\n    _retainParent: function (x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n        y2 = Math.floor(y / 2),\n        z2 = z - 1,\n        coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n      var key = this._tileCoordsToKey(coords2),\n        tile = this._tiles[key];\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n      return false;\n    },\n    _retainChildren: function (x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n          var key = this._tileCoordsToKey(coords),\n            tile = this._tiles[key];\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function (e) {\n      var animating = e && (e.pinch || e.flyTo);\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function (e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function (zoom) {\n      var options = this.options;\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n      return zoom;\n    },\n    _setView: function (center, zoom, noPrune, noUpdate) {\n      var tileZoom = Math.round(zoom);\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      } else {\n        tileZoom = this._clampZoom(tileZoom);\n      }\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n        this._updateLevels();\n        this._resetGrid();\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n        if (!noPrune) {\n          this._pruneTiles();\n        }\n\n        // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n        this._noPrune = !!noPrune;\n      }\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function (center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function (level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n        translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n      if (Browser.any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function () {\n      var map = this._map,\n        crs = map.options.crs,\n        tileSize = this._tileSize = this.getTileSize(),\n        tileZoom = this._tileZoom;\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function () {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n      this._update();\n    },\n    _getTiledPixelBounds: function (center) {\n      var map = this._map,\n        mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n        scale = map.getZoomScale(mapZoom, this._tileZoom),\n        pixelCenter = map.project(center, this._tileZoom).floor(),\n        halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function (center) {\n      var map = this._map;\n      if (!map) {\n        return;\n      }\n      var zoom = this._clampZoom(map.getZoom());\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n        tileRange = this._pxBoundsToTileRange(pixelBounds),\n        tileCenter = tileRange.getCenter(),\n        queue = [],\n        margin = this.options.keepBuffer,\n        noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));\n\n      // Sanity check: panic if the tile range contains Infinity somewhere.\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      }\n\n      // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n        return;\n      }\n\n      // create a queue of coordinates to load tiles from\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      }\n\n      // sort tile queue to load tiles in order of their distance to center\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true;\n          // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n          this.fire('loading');\n        }\n\n        // create DOM fragment to append tiles in one batch\n        var fragment = document.createDocumentFragment();\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function (coords) {\n      var crs = this._map.options.crs;\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n      if (!this.options.bounds) {\n        return true;\n      }\n\n      // don't load tile if it doesn't intersect the bounds in options\n      var tileBounds = this._tileCoordsToBounds(coords);\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function (key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function (coords) {\n      var map = this._map,\n        tileSize = this.getTileSize(),\n        nwPoint = coords.scaleBy(tileSize),\n        sePoint = nwPoint.add(tileSize),\n        nw = map.unproject(nwPoint, coords.z),\n        se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function (coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n        bounds = new LatLngBounds(bp[0], bp[1]);\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function (coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function (key) {\n      var k = key.split(':'),\n        coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      remove(tile.el);\n      delete this._tiles[key];\n\n      // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function (tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn;\n\n      // update opacity on tiles in IE7-8 because of filter inheritance problems\n      if (Browser.ielt9 && this.options.opacity < 1) {\n        setOpacity(tile, this.options.opacity);\n      }\n    },\n    _addTile: function (coords, container) {\n      var tilePos = this._getTilePos(coords),\n        key = this._tileCoordsToKey(coords);\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n      this._initTile(tile);\n\n      // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n      setPosition(tile, tilePos);\n\n      // save tile in cache\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile);\n      // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function (coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n      var key = this._tileCoordsToKey(coords);\n      tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      tile.loaded = +new Date();\n      if (this._map._fadeAnimated) {\n        setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n        this._pruneTiles();\n      }\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded');\n\n        // @event tileload: TileEvent\n        // Fired when a tile loads.\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n      if (this._noTilesToLoad()) {\n        this._loading = false;\n        // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n        this.fire('load');\n        if (Browser.ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function (coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function (coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function (bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function () {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n\n  // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option referrerPolicy: Boolean|String = false\n      // Whether the referrerPolicy attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\n      // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\n      // (e.g. to validate an API token).\n      // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\n      referrerPolicy: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      options = setOptions(this, options);\n\n      // detecting retina displays, adjusting tileSize and zoom levels\n      if (options.detectRetina && Browser.retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);\n        } else {\n          options.zoomOffset--;\n          options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);\n        }\n        options.minZoom = Math.max(0, options.minZoom);\n      } else if (!options.zoomReverse) {\n        // make sure maxZoom is gte minZoom\n        options.maxZoom = Math.max(options.minZoom, options.maxZoom);\n      } else {\n        // make sure minZoom is lte maxZoom\n        options.minZoom = Math.min(options.maxZoom, options.minZoom);\n      }\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      }\n      this.on('tileunload', this._onTileRemove);\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function (url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n      this._url = url;\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function (coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      // for this new option we follow the documented behavior\n      // more closely by only setting the property when string\n      if (typeof this.options.referrerPolicy === 'string') {\n        tile.referrerPolicy = this.options.referrerPolicy;\n      }\n\n      // The alt attribute is set to the empty string,\n      // allowing screen readers to ignore the decorative image tiles.\n      // https://www.w3.org/WAI/tutorials/images/decorative/\n      // https://www.w3.org/TR/html-aria/#el-img-empty-alt\n      tile.alt = '';\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function (coords) {\n      var data = {\n        r: Browser.retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n        data['-y'] = invertedY;\n      }\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function (done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (Browser.ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function (done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n      done(e, tile);\n    },\n    _onTileRemove: function (e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function () {\n      var zoom = this._tileZoom,\n        maxZoom = this.options.maxZoom,\n        zoomReverse = this.options.zoomReverse,\n        zoomOffset = this.options.zoomOffset;\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function (tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function () {\n      var i, tile;\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            var coords = this._tiles[i].coords;\n            remove(tile);\n            delete this._tiles[i];\n            // @event tileabort: TileEvent\n            // Fired when a tile was loading but is now not wanted.\n            this.fire('tileabort', {\n              tile: tile,\n              coords: coords\n            });\n          }\n        }\n      }\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n\n      // Cancels any pending http requests associated with the tile\n      tile.el.setAttribute('src', emptyImageUrl);\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function (coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  });\n\n  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data © 2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams);\n\n      // all keys that are not TileLayer options go to WMS params\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && Browser.retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function (map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function (coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n        crs = this._crs,\n        bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n        min = bounds.min,\n        max = bounds.max,\n        bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n        url = TileLayer.prototype.getTileUrl.call(this, coords);\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function (params, noRedraw) {\n      extend(this.wmsParams, params);\n      if (!noRedraw) {\n        this.redraw();\n      }\n      return this;\n    }\n  });\n\n  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function () {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n        // always keep transform-origin as 0 0\n        addClass(this._container, 'leaflet-zoom-animated');\n      }\n      this.getPane().appendChild(this._container);\n      this._update();\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function () {\n      this.off('update', this._updatePaths, this);\n      this._destroyContainer();\n    },\n    getEvents: function () {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n      return events;\n    },\n    _onAnimZoom: function (ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function () {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function (center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n        viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n        currentCenterPoint = this._map.project(this._center, zoom),\n        topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));\n      if (Browser.any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function () {\n      this._update();\n      this._updateTransform(this._center, this._zoom);\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function () {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function () {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function () {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n        size = this._map.getSize(),\n        min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    // @section\n    // @aka Canvas options\n    options: {\n      // @option tolerance: Number = 0\n      // How much to extend the click tolerance around a path/object on the map.\n      tolerance: 0\n    },\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function () {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function () {\n      Renderer.prototype.onAdd.call(this);\n\n      // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n      this._draw();\n    },\n    _initContainer: function () {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      container['_leaflet_disable_events'] = true;\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function () {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function () {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n      var layer;\n      this._redrawBounds = null;\n      for (var id in this._layers) {\n        layer = this._layers[id];\n        layer._update();\n      }\n      this._redraw();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      var b = this._bounds,\n        container = this._container,\n        size = b.getSize(),\n        m = Browser.retina ? 2 : 1;\n      setPosition(container, b.min);\n\n      // set canvas size (also clearing it); use double size on retina\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n      if (Browser.retina) {\n        this._ctx.scale(2, 2);\n      }\n\n      // translate so we use the same path coordinates after canvas element moves\n      this._ctx.translate(-b.min.x, -b.min.y);\n\n      // Tell paths to redraw themselves\n      this.fire('update');\n    },\n    _reset: function () {\n      Renderer.prototype._reset.call(this);\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n        this._updatePaths();\n      }\n    },\n    _initPath: function (layer) {\n      this._updateDashArray(layer);\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function (layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function (layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n      this._requestRedraw(layer);\n    },\n    _updatePath: function (layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n      layer._project();\n      layer._update();\n      // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function (layer) {\n      this._updateDashArray(layer);\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function (layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n          dashArray = [],\n          dashValue,\n          i;\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]);\n          // Ignore dash array containing invalid lengths\n          if (isNaN(dashValue)) {\n            return;\n          }\n          dashArray.push(dashValue);\n        }\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function (layer) {\n      if (!this._map) {\n        return;\n      }\n      this._extendRedrawBounds(layer);\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function (layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function () {\n      this._redrawRequest = null;\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n        this._redrawBounds.max._ceil();\n      }\n      this._clear(); // clear layers in redraw bounds\n      this._draw(); // draw layers\n\n      this._redrawBounds = null;\n    },\n    _clear: function () {\n      var bounds = this._redrawBounds;\n      if (bounds) {\n        var size = bounds.getSize();\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.save();\n        this._ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n        this._ctx.restore();\n      }\n    },\n    _draw: function () {\n      var layer,\n        bounds = this._redrawBounds;\n      this._ctx.save();\n      if (bounds) {\n        var size = bounds.getSize();\n        this._ctx.beginPath();\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n        this._ctx.clip();\n      }\n      this._drawing = true;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n      this._drawing = false;\n      this._ctx.restore(); // Restore state before clipping.\n    },\n    _updatePoly: function (layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n      var i,\n        j,\n        len2,\n        p,\n        parts = layer._parts,\n        len = parts.length,\n        ctx = this._ctx;\n      if (!len) {\n        return;\n      }\n      ctx.beginPath();\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n      this._fillStroke(ctx, layer);\n\n      // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n    },\n    _updateCircle: function (layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n      var p = layer._point,\n        ctx = this._ctx,\n        r = Math.max(Math.round(layer._radius), 1),\n        s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n      if (s !== 1) {\n        ctx.restore();\n      }\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function (ctx, layer) {\n      var options = layer.options;\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n    _onClick: function (e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n        layer,\n        clickedLayer;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          if (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {\n            clickedLayer = layer;\n          }\n        }\n      }\n      this._fireEvent(clickedLayer ? [clickedLayer] : false, e);\n    },\n    _onMouseMove: function (e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n      var point = this._map.mouseEventToLayerPoint(e);\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function (e) {\n      var layer = this._hoveredLayer;\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n        this._fireEvent([layer], e, 'mouseout');\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function (e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n      var layer, candidateHoveredLayer;\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n      this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);\n      this._mouseHoverThrottled = true;\n      setTimeout(bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function (layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function (layer) {\n      var order = layer._order;\n      if (!order) {\n        return;\n      }\n      var next = order.next;\n      var prev = order.prev;\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function (layer) {\n      var order = layer._order;\n      if (!order) {\n        return;\n      }\n      var next = order.next;\n      var prev = order.prev;\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n      this._requestRedraw(layer);\n    }\n  });\n\n  // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n  function canvas(options) {\n    return Browser.canvas ? new Canvas(options) : null;\n  }\n\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      // Do not return fn from catch block so `e` can be garbage collected\n      // See https://github.com/Leaflet/Leaflet/pull/7279\n    }\n    return function (name) {\n      return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n    };\n  }();\n\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n  var vmlMixin = {\n    _initContainer: function () {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function () {\n      if (this._map._animatingZoom) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      this.fire('update');\n    },\n    _initPath: function (layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n      this._updateStyle(layer);\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      var container = layer._container;\n      this._container.appendChild(container);\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function (layer) {\n      var container = layer._container;\n      remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function (layer) {\n      var stroke = layer._stroke,\n        fill = layer._fill,\n        options = layer.options,\n        container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point.round(),\n        r = Math.round(layer._radius),\n        r2 = Math.round(layer._radiusY || r);\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function (layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function (layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._container);\n    }\n  };\n  var create = Browser.vml ? vmlCreate : svgCreate;\n\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    _initContainer: function () {\n      this._container = create('svg');\n\n      // makes it possible to click through svg root; we'll reset it back in individual paths\n      this._container.setAttribute('pointer-events', 'none');\n      this._rootGroup = create('g');\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function () {\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n      Renderer.prototype._update.call(this);\n      var b = this._bounds,\n        size = b.getSize(),\n        container = this._container;\n\n      // set size of svg-container if changed\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      }\n\n      // movement: update container viewBox so that we don't have to change coordinates of individual layers\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n\n    _initPath: function (layer) {\n      var path = layer._path = create('path');\n\n      // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n      this._updateStyle(layer);\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n      this._rootGroup.appendChild(layer._path);\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function (layer) {\n      remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function (layer) {\n      layer._project();\n      layer._update();\n    },\n    _updateStyle: function (layer) {\n      var path = layer._path,\n        options = layer.options;\n      if (!path) {\n        return;\n      }\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function (layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point,\n        r = Math.max(Math.round(layer._radius), 1),\n        r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n        arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n      // drawing a circle with two half-arcs\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n      this._setPath(layer, d);\n    },\n    _setPath: function (layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function (layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._path);\n    }\n  });\n  if (Browser.vml) {\n    SVG.include(vmlMixin);\n  }\n\n  // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n  function svg(options) {\n    return Browser.svg || Browser.vml ? new SVG(options) : null;\n  }\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function (layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n      return renderer;\n    },\n    _getPaneRenderer: function (name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n      var renderer = this._paneRenderers[name];\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n      return renderer;\n    },\n    _createRenderer: function (options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas(options) || svg(options);\n    }\n  });\n\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function (latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function (latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function (latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  });\n\n  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n  SVG.create = create;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function (map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function () {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function () {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function () {\n      return this._moved;\n    },\n    _destroy: function () {\n      remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function () {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function () {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function (e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      }\n\n      // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n      this._clearDeferredResetState();\n      this._resetState();\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function (e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n        this._map.fire('boxzoomstart');\n      }\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n        size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function () {\n      if (this._moved) {\n        remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function (e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n      this._finish();\n      if (!this._moved) {\n        return;\n      }\n      // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n      this._clearDeferredResetState();\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function (e) {\n      if (e.keyCode === 27) {\n        this._finish();\n        this._clearDeferredResetState();\n        this._resetState();\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function () {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function () {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function (e) {\n      var map = this._map,\n        oldZoom = map.getZoom(),\n        delta = map.options.zoomDelta,\n        zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  });\n\n  // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map is draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default.\n    inertia: true,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second².\n    inertiaDeceleration: 3400,\n    // px/s^2\n\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function () {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n      this._draggable.enable();\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n      this._draggable.disable();\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function () {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function () {\n      var map = this._map;\n      map._stop();\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n      map.fire('movestart').fire('dragstart');\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function (e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n          pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n        this._positions.push(pos);\n        this._times.push(time);\n        this._prunePositions(time);\n      }\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function (time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function () {\n      var pxCenter = this._map.getSize().divideBy(2),\n        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function (value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function () {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n      var limit = this._offsetLimit;\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function () {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n        halfWidth = Math.round(worldWidth / 2),\n        dx = this._initialWorldOffset,\n        x = this._draggable._newPos.x,\n        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function (e) {\n      var map = this._map,\n        options = map.options,\n        noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n      map.fire('dragend', e);\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n        var direction = this._lastPos.subtract(this._positions[0]),\n          duration = (this._lastTime - this._times[0]) / 1000,\n          ease = options.easeLinearity,\n          speedVector = direction.multiplyBy(ease / duration),\n          speed = speedVector.distanceTo([0, 0]),\n          limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n          limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n          decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n          offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n  Map.addInitHook('addHandler', 'dragging', Drag);\n\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Keyboard Navigation Options\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function (map) {\n      this._map = map;\n      this._setPanDelta(map.options.keyboardPanDelta);\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function () {\n      var container = this._map._container;\n\n      // make the container focusable by tabbing\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function () {\n      this._removeHooks();\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function () {\n      if (this._focused) {\n        return;\n      }\n      var body = document.body,\n        docEl = document.documentElement,\n        top = body.scrollTop || docEl.scrollTop,\n        left = body.scrollLeft || docEl.scrollLeft;\n      this._map._container.focus();\n      window.scrollTo(left, top);\n    },\n    _onFocus: function () {\n      this._focused = true;\n      this._map.fire('focus');\n    },\n    _onBlur: function () {\n      this._focused = false;\n      this._map.fire('blur');\n    },\n    _setPanDelta: function (panDelta) {\n      var keys = this._panKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function (zoomDelta) {\n      var keys = this._zoomKeys = {},\n        codes = this.keyCodes,\n        i,\n        len;\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function () {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function () {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function (e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n      var key = e.keyCode,\n        map = this._map,\n        offset;\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n          if (map.options.maxBounds) {\n            offset = map._limitOffset(toPoint(offset), map.options.maxBounds);\n          }\n          if (map.options.worldCopyJump) {\n            var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));\n            map.panTo(newLatLng);\n          } else {\n            map.panBy(offset);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n      stop(e);\n    }\n  });\n\n  // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Mouse wheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'wheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function () {\n      off(this._map._container, 'wheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function (e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function () {\n      var map = this._map,\n        zoom = map.getZoom(),\n        snap = this._map.options.zoomSnap || 0;\n      map._stop(); // stop panning and fly animations if any\n\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n        d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n        d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n        delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n      if (!delta) {\n        return;\n      }\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n\n  /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */\n\n  var tapHoldDelay = 600;\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tapHold: Boolean\n    // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n    tapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var TapHold = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function () {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function (e) {\n      clearTimeout(this._holdTimeout);\n      if (e.touches.length !== 1) {\n        return;\n      }\n      var first = e.touches[0];\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY);\n      this._holdTimeout = setTimeout(bind(function () {\n        this._cancel();\n        if (!this._isTapValid()) {\n          return;\n        }\n\n        // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n        on(document, 'touchend', preventDefault);\n        on(document, 'touchend touchcancel', this._cancelClickPrevent);\n        this._simulateEvent('contextmenu', first);\n      }, this), tapHoldDelay);\n      on(document, 'touchend touchcancel contextmenu', this._cancel, this);\n      on(document, 'touchmove', this._onMove, this);\n    },\n    _cancelClickPrevent: function cancelClickPrevent() {\n      off(document, 'touchend', preventDefault);\n      off(document, 'touchend touchcancel', cancelClickPrevent);\n    },\n    _cancel: function () {\n      clearTimeout(this._holdTimeout);\n      off(document, 'touchend touchcancel contextmenu', this._cancel, this);\n      off(document, 'touchmove', this._onMove, this);\n    },\n    _onMove: function (e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n    },\n    _isTapValid: function () {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _simulateEvent: function (type, e) {\n      var simulatedEvent = new MouseEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        view: window,\n        // detail: 1,\n        screenX: e.screenX,\n        screenY: e.screenY,\n        clientX: e.clientX,\n        clientY: e.clientY\n        // button: 2,\n        // buttons: 2\n      });\n      simulatedEvent._simulated = true;\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  });\n\n  // @section Handlers\n  // @property tapHold: Handler\n  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n  Map.addInitHook('addHandler', 'tapHold', TapHold);\n\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers.\n    touchZoom: Browser.touch,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function () {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function (e) {\n      var map = this._map;\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n        p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n      map._stop();\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend touchcancel', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function (e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n      var map = this._map,\n        p1 = map.mouseEventToContainerPoint(e.touches[0]),\n        p2 = map.mouseEventToContainerPoint(e.touches[1]),\n        scale = p1.distanceTo(p2) / this._startDist;\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n      if (!this._moved) {\n        map._moveStart(true, false);\n        this._moved = true;\n      }\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      }, undefined);\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function () {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove, this);\n      off(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n      // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  });\n\n  // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.TapHold = TapHold;\n  Map.TouchZoom = TouchZoom;\n  exports.Bounds = Bounds;\n  exports.Browser = Browser;\n  exports.CRS = CRS;\n  exports.Canvas = Canvas;\n  exports.Circle = Circle;\n  exports.CircleMarker = CircleMarker;\n  exports.Class = Class;\n  exports.Control = Control;\n  exports.DivIcon = DivIcon;\n  exports.DivOverlay = DivOverlay;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.Draggable = Draggable;\n  exports.Evented = Evented;\n  exports.FeatureGroup = FeatureGroup;\n  exports.GeoJSON = GeoJSON;\n  exports.GridLayer = GridLayer;\n  exports.Handler = Handler;\n  exports.Icon = Icon;\n  exports.ImageOverlay = ImageOverlay;\n  exports.LatLng = LatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.LineUtil = LineUtil;\n  exports.Map = Map;\n  exports.Marker = Marker;\n  exports.Mixin = Mixin;\n  exports.Path = Path;\n  exports.Point = Point;\n  exports.PolyUtil = PolyUtil;\n  exports.Polygon = Polygon;\n  exports.Polyline = Polyline;\n  exports.Popup = Popup;\n  exports.PosAnimation = PosAnimation;\n  exports.Projection = index;\n  exports.Rectangle = Rectangle;\n  exports.Renderer = Renderer;\n  exports.SVG = SVG;\n  exports.SVGOverlay = SVGOverlay;\n  exports.TileLayer = TileLayer;\n  exports.Tooltip = Tooltip;\n  exports.Transformation = Transformation;\n  exports.Util = Util;\n  exports.VideoOverlay = VideoOverlay;\n  exports.bind = bind;\n  exports.bounds = toBounds;\n  exports.canvas = canvas;\n  exports.circle = circle;\n  exports.circleMarker = circleMarker;\n  exports.control = control;\n  exports.divIcon = divIcon;\n  exports.extend = extend;\n  exports.featureGroup = featureGroup;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.gridLayer = gridLayer;\n  exports.icon = icon;\n  exports.imageOverlay = imageOverlay;\n  exports.latLng = toLatLng;\n  exports.latLngBounds = toLatLngBounds;\n  exports.layerGroup = layerGroup;\n  exports.map = createMap;\n  exports.marker = marker;\n  exports.point = toPoint;\n  exports.polygon = polygon;\n  exports.polyline = polyline;\n  exports.popup = popup;\n  exports.rectangle = rectangle;\n  exports.setOptions = setOptions;\n  exports.stamp = stamp;\n  exports.svg = svg;\n  exports.svgOverlay = svgOverlay;\n  exports.tileLayer = tileLayer;\n  exports.tooltip = tooltip;\n  exports.transformation = toTransformation;\n  exports.version = version;\n  exports.videoOverlay = videoOverlay;\n  var oldL = window.L;\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  };\n  // Always export us to window global (see #2364)\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGVBQWU7RUFFckNwbUMsR0FBRyxDQUFDMm1DLElBQUksR0FBR0EsSUFBSTtFQUVmM21DLEdBQUcsQ0FBQ3lvQyxRQUFRLEdBQUdBLFFBQVE7RUFFdkJ6b0MsR0FBRyxDQUFDb3FDLGVBQWUsR0FBR0EsZUFBZTtFQUVyQ3BxQyxHQUFHLENBQUNpckMsT0FBTyxHQUFHQSxPQUFPO0VBRXJCanJDLEdBQUcsQ0FBQ2dzQyxTQUFTLEdBQUdBLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvcmUvVXRpbC5qcz8yZTY0Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvY29yZS9DbGFzcy5qcz8wMWFjIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvY29yZS9FdmVudHMuanM/MTM2ZiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlb21ldHJ5L1BvaW50LmpzPzE1NDAiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW9tZXRyeS9Cb3VuZHMuanM/MWM3OSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9MYXRMbmdCb3VuZHMuanM/YjU3YyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9MYXRMbmcuanM/NWI2NCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9jcnMvQ1JTLmpzP2IyY2QiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vY3JzL0NSUy5FYXJ0aC5qcz8xMDE5Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcz8xZTVlIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanM/YzI1MyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzP2YyMmUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanM/OTBjMSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvcmUvQnJvd3Nlci5qcz83ZGUzIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZG9tL0RvbUV2ZW50LlBvaW50ZXIuanM/ODY0NCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanM/ZTc2ZCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2RvbS9Eb21VdGlsLmpzPzdjOTMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9kb20vRG9tRXZlbnQuanM/MWVhYyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2RvbS9Qb3NBbmltYXRpb24uanM/YjZiMSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL21hcC9NYXAuanM/NzNlYSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5qcz81MjkxIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcz82NGQ0Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanM/MTU1MCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcz84YzY0Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzPzJjZDciLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9jb250cm9sL2luZGV4LmpzPzBjYTgiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9jb3JlL0hhbmRsZXIuanM/NGU1ZSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2NvcmUvaW5kZXguanM/ZTBlMCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2RvbS9EcmFnZ2FibGUuanM/Y2NlYyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlb21ldHJ5L1BvbHlVdGlsLmpzP2Q1N2UiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW9tZXRyeS9MaW5lVXRpbC5qcz8xODdhIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanM/OWQ4NSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanM/YjJiYyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzP2ZkYTgiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcz8wYzNiIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanM/ZDk4MyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcz85YmU4Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvZ2VvL2Nycy9pbmRleC5qcz82NmQ5Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvTGF5ZXIuanM/NjcwMyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL0xheWVyR3JvdXAuanM/N2Y2NCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcz8yNDRhIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanM/MDU4OCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanM/MjdlNyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcz8yZmI1Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcz8zZGQyIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanM/ZjY2YSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanM/MjQ4ZiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanM/OWQxYSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcz85YzM3Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanM/MjcyNyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL0dlb0pTT04uanM/YWFlYSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcz8wMTg5Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzPzAzZTgiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9TVkdPdmVybGF5LmpzPzNjZjMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9EaXZPdmVybGF5LmpzPzAwMjMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9Qb3B1cC5qcz84ZTExIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvVG9vbHRpcC5qcz8wZGIyIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanM/ZTBkZSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL21hcmtlci9pbmRleC5qcz84ZjM4Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanM/Mzg4ZSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzPzI2MjAiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanM/ZjllNiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3RpbGUvaW5kZXguanM/NDI4YyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcz8xMGVlIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcz9iOWViIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanM/YzkzNCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuanM/Zjg0YiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcz81ZmE3Iiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcz8wZDdhIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzPzFlMTMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9sYXllci9pbmRleC5qcz8xMjIyIiwid2VicGFjazovL2NsaWVudC8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkJveFpvb20uanM/ZTljYyIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanM/MDJkNSIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzP2JjZDAiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanM/M2YzYiIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanM/MWYxNCIsIndlYnBhY2s6Ly9jbGllbnQvLi4vc3JjL21hcC9oYW5kbGVyL01hcC5UYXBIb2xkLmpzP2MwYmYiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9tYXAvaGFuZGxlci9NYXAuVG91Y2hab29tLmpzP2Y2NmEiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4uL3NyYy9tYXAvaW5kZXguanM/MjA1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBAbmFtZXNwYWNlIFV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcclxuXHR2YXIgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG5cdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG5cdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG5cdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZGVzdDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShwcm90bzogT2JqZWN0LCBwcm9wZXJ0aWVzPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG5leHBvcnQgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBGKCkge31cclxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cdFx0cmV0dXJuIG5ldyBGKCk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbi8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG4vLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gYmluZChmbiwgb2JqKSB7XHJcblx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuXHRpZiAoZm4uYmluZCkge1xyXG5cdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcblx0fTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbi8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcbmV4cG9ydCB2YXIgbGFzdElkID0gMDtcclxuXHJcbi8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ25pbmcgaXQgb25lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YW1wKG9iaikge1xyXG5cdGlmICghKCdfbGVhZmxldF9pZCcgaW4gb2JqKSkge1xyXG5cdFx0b2JqWydfbGVhZmxldF9pZCddID0gKytsYXN0SWQ7XHJcblx0fVxyXG5cdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcbi8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4vLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG4vLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcbi8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuLy8gSGFzIGFuIGBMLnRocm90dGxlYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG5cdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuXHRcdGxvY2sgPSBmYWxzZTtcclxuXHRcdGlmIChhcmdzKSB7XHJcblx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0YXJncyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChsb2NrKSB7XHJcblx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG5cdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuXHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuXHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcblx0XHRcdGxvY2sgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiB3cmFwcGVyRm47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbi8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuLy8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTnVtKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcblx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG5cdCAgICBtaW4gPSByYW5nZVswXSxcclxuXHQgICAgZCA9IG1heCAtIG1pbjtcclxuXHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG5leHBvcnQgZnVuY3Rpb24gZmFsc2VGbigpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4vLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgd2l0aCBzcGVjaWZpZWQgYHByZWNpc2lvbmAuXHJcbi8vIFRoZSBkZWZhdWx0IGBwcmVjaXNpb25gIHZhbHVlIGlzIDYgZGVjaW1hbCBwbGFjZXMuXHJcbi8vIGBmYWxzZWAgY2FuIGJlIHBhc3NlZCB0byBza2lwIGFueSBwcm9jZXNzaW5nIChjYW4gYmUgdXNlZnVsIHRvIGF2b2lkIHJvdW5kLW9mZiBlcnJvcnMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgcHJlY2lzaW9uKSB7XHJcblx0aWYgKHByZWNpc2lvbiA9PT0gZmFsc2UpIHsgcmV0dXJuIG51bTsgfVxyXG5cdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2IDogcHJlY2lzaW9uKTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcblx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdvcHRpb25zJykpIHtcclxuXHRcdG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBjcmVhdGUob2JqLm9wdGlvbnMpIDoge307XHJcblx0fVxyXG5cdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuLy8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG4vLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbi8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcbi8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdHZhciBwYXJhbXMgPSBbXTtcclxuXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxufVxyXG5cclxudmFyIHRlbXBsYXRlUmUgPSAvXFx7ICooW1xcd18gLV0rKSAqXFx9L2c7XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4vLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuLy8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbi8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcblx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbmV4cG9ydCB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbi8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4vLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcbmV4cG9ydCB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG59XHJcblxyXG52YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5mdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbmV4cG9ydCB2YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG4vLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4vLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbi8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuXHRpZiAoaWQpIHtcclxuXHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMpO1xyXG5cclxuXHRcdC8vIGNhbGwgdGhlIGNvbnN0cnVjdG9yXHJcblx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcblx0dmFyIHByb3RvID0gVXRpbC5jcmVhdGUocGFyZW50UHJvdG8pO1xyXG5cdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG5cdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuXHQvLyBpbmhlcml0IHBhcmVudCdzIHN0YXRpY3NcclxuXHRmb3IgKHZhciBpIGluIHRoaXMpIHtcclxuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdFV0aWwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBpbmNsdWRlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRpZiAocHJvcHMuaW5jbHVkZXMpIHtcclxuXHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcclxuXHRcdFV0aWwuZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuXHRVdGlsLmV4dGVuZChwcm90bywgcHJvcHMpO1xyXG5cdGRlbGV0ZSBwcm90by5zdGF0aWNzO1xyXG5cdGRlbGV0ZSBwcm90by5pbmNsdWRlcztcclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm90by5vcHRpb25zKSB7XHJcblx0XHRwcm90by5vcHRpb25zID0gcGFyZW50UHJvdG8ub3B0aW9ucyA/IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvLm9wdGlvbnMpIDoge307XHJcblx0XHRVdGlsLmV4dGVuZChwcm90by5vcHRpb25zLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHR2YXIgcGFyZW50T3B0aW9ucyA9IHRoaXMucHJvdG90eXBlLm9wdGlvbnM7XHJcblx0VXRpbC5leHRlbmQodGhpcy5wcm90b3R5cGUsIHByb3BzKTtcclxuXHRpZiAocHJvcHMub3B0aW9ucykge1xyXG5cdFx0dGhpcy5wcm90b3R5cGUub3B0aW9ucyA9IHBhcmVudE9wdGlvbnM7XHJcblx0XHR0aGlzLm1lcmdlT3B0aW9ucyhwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0VXRpbC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4vLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuXHQvKiBnbG9iYWwgTDogdHJ1ZSAqL1xyXG5cdGlmICh0eXBlb2YgTCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUwgfHwgIUwuTWl4aW4pIHsgcmV0dXJuOyB9XHJcblxyXG5cdGluY2x1ZGVzID0gVXRpbC5pc0FycmF5KGluY2x1ZGVzKSA/IGluY2x1ZGVzIDogW2luY2x1ZGVzXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmNsdWRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGluY2x1ZGVzW2ldID09PSBMLk1peGluLkV2ZW50cykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgaW5jbHVkZSBvZiBMLk1peGluLkV2ZW50czogJyArXHJcblx0XHRcdFx0J3RoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgJyArXHJcblx0XHRcdFx0J3BsZWFzZSBpbmhlcml0IGZyb20gTC5FdmVudGVkIGluc3RlYWQuJywgbmV3IEVycm9yKCkuc3RhY2spO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEV2ZW50ZWRcclxuICogQGFrYSBMLkV2ZW50ZWRcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAqIH0gKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVhbHMgd2l0aCBldmVudCBsaXN0ZW5lcnMgYnkgcmVmZXJlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgYSBsaXN0ZW5lciBhbmQgdGhlbiByZW1vdmUgaXQsIGRlZmluZSBpdCBhcyBhIGZ1bmN0aW9uOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiBvbkNsaWNrKGUpIHsgLi4uIH1cclxuICpcclxuICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBtYXAub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEV2ZW50cyA9IHtcclxuXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgb2YgdGhlIG9iamVjdC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyIChvYmplY3QgdGhlIHRoaXMga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb24oZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblx0ICovXHJcblx0b246IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcblx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuIFRoaXMgaW5jbHVkZXMgaW1wbGljaXRseSBhdHRhY2hlZCBldmVudHMuXHJcblx0ICovXHJcblx0b2ZmOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdHZhciByZW1vdmVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRpZiAocmVtb3ZlQWxsKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCwgX29uY2UpIHtcclxuXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBsaXN0ZW5lciB0eXBlOiAnICsgdHlwZW9mIGZuKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcclxuXHRcdGlmICh0aGlzLl9saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0KSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9O1xyXG5cdFx0aWYgKF9vbmNlKSB7XHJcblx0XHRcdG5ld0xpc3RlbmVyLm9uY2UgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcclxuXHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKG5ld0xpc3RlbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMsXHJcblx0XHQgICAgaSxcclxuXHRcdCAgICBsZW47XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyAvLyByZW1vdmUgYWxsXHJcblx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcFxyXG5cdFx0XHRcdC8vIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdHZhciBpbmRleCA9IHRoaXMuX2xpc3RlbnModHlwZSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0aWYgKGluZGV4ICE9PSBmYWxzZSkge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaW5kZXhdO1xyXG5cdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0bGlzdGVuZXIuZm4gPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcblx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gVXRpbC5leHRlbmQoe30sIGRhdGEsIHtcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG5cdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0Ly8gb2ZmIG92ZXJ3cml0ZXMgbC5mbiwgc28gd2UgbmVlZCB0byBjb3B5IGZuIHRvIGEgdmFyXHJcblx0XHRcdFx0XHR2YXIgZm4gPSBsLmZuO1xyXG5cdFx0XHRcdFx0aWYgKGwub25jZSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLm9mZih0eXBlLCBmbiwgbC5jdHgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZywgcHJvcGFnYXRlPzogQm9vbGVhbik6IEJvb2xlYW5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcblx0Ly8gVGhlIHZlcmlmaWNhdGlvbiBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkLCBpdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgcGFyZW50cyBoYXZlIHRoZSBsaXN0ZW5lciBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ1wic3RyaW5nXCIgdHlwZSBhcmd1bWVudCBleHBlY3RlZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgaW5wdXQgYGZuYCB2YWx1ZSwgYmVjYXVzZSB3ZSBuZWVkIHRvIHVzZSBpdCBmb3IgcHJvcGFnYXRpb25cclxuXHRcdHZhciBfZm4gPSBmbjtcclxuXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0cHJvcGFnYXRlID0gISFmbjtcclxuXHRcdFx0X2ZuID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7XHJcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5zKHR5cGUsIF9mbiwgY29udGV4dCkgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50c1tpZF0ubGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyB0aGUgaW5kZXggKG51bWJlcikgb3IgZmFsc2VcclxuXHRfbGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0cmV0dXJuICEhbGlzdGVuZXJzLmxlbmd0aDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuIGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbiwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcblx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcblx0XHRcdH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbkV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG5leHBvcnQgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcclxuIiwiaW1wb3J0IHtpc0FycmF5LCBmb3JtYXROdW19IGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBQb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdC8vIEBwcm9wZXJ0eSB4OiBOdW1iZXI7IFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcblx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufVxyXG5cclxudmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xyXG5cdHJldHVybiB2ID4gMCA/IE1hdGguZmxvb3IodikgOiBNYXRoLmNlaWwodik7XHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG5cdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcblx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcblx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5zY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuXHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cclxuXHR1bnNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcblx0fSxcclxuXHJcblx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRydW5jKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cclxuXHR0cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fdHJ1bmMoKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IHRydW5jKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG5cdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcblx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcblx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuLy8gQ3JlYXRlcyBhIFBvaW50IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgeGAgYW5kIGB5YCBjb29yZGluYXRlcy4gSWYgb3B0aW9uYWwgYHJvdW5kYCBpcyBzZXQgdG8gdHJ1ZSwgcm91bmRzIHRoZSBgeGAgYW5kIGB5YCB2YWx1ZXMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbeCwgeV1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuLy8gRXhwZWN0cyBhIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge3g6IE51bWJlciwgeTogTnVtYmVyfWAgaW5zdGVhZC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHRpZiAoeCBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKGlzQXJyYXkoeCkpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoeFswXSwgeFsxXSk7XHJcblx0fVxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoeC54LCB4LnkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG4iLCJpbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBCb3VuZHNcclxuICogQGFrYSBMLkJvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IEJvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4yLCBtYXgyO1xyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgUG9pbnQgfHwgdHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgJ3gnIGluIG9iaikge1xyXG5cdFx0XHRtaW4yID0gbWF4MiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHRcdG1pbjIgPSBvYmoubWluO1xyXG5cdFx0XHRtYXgyID0gb2JqLm1heDtcclxuXHJcblx0XHRcdGlmICghbWluMiB8fCAhbWF4MikgeyByZXR1cm4gdGhpczsgfVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcblx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG5cdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gbWluMi5jbG9uZSgpO1xyXG5cdFx0XHR0aGlzLm1heCA9IG1heDIuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihtaW4yLngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgobWF4Mi54LCB0aGlzLm1heC54KTtcclxuXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKG1pbjIueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChtYXgyLnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcExlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG5cdGdldFRvcExlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21SaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5tYXhgXSgjYm91bmRzLW1heCkpLlxyXG5cdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXg7IC8vIHJpZ2h0LCBib3R0b21cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gdG9Qb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRcdG1pbiA9IG9iai5taW47XHJcblx0XHRcdG1heCA9IG9iai5tYXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG5cdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcblx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG5cdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0bWF4ID0gdGhpcy5tYXgsXHJcblx0XHRoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhtaW4ueCAtIG1heC54KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0d2lkdGhCdWZmZXIgPSBNYXRoLmFicyhtaW4ueSAtIG1heC55KSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHJcblx0XHRyZXR1cm4gdG9Cb3VuZHMoXHJcblx0XHRcdHRvUG9pbnQobWluLnggLSBoZWlnaHRCdWZmZXIsIG1pbi55IC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0XHR0b1BvaW50KG1heC54ICsgaGVpZ2h0QnVmZmVyLCBtYXgueSArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBib3VuZHMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm1pbi5lcXVhbHMoYm91bmRzLmdldFRvcExlZnQoKSkgJiZcclxuXHRcdFx0dGhpcy5tYXguZXF1YWxzKGJvdW5kcy5nZXRCb3R0b21SaWdodCgpKTtcclxuXHR9LFxyXG59O1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0d28gY29ybmVycyBjb29yZGluYXRlIHBhaXJzLlxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEJvdW5kcyhhLCBiKTtcclxufVxyXG4iLCJpbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4vTGF0TG5nJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICogQGFrYSBMLkxhdExuZ0JvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBjb3JuZXIxID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICogY29ybmVyMiA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmdCb3VuZHMgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5maXRCb3VuZHMoW1xyXG4gKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAqIF0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQ2F1dGlvbjogaWYgdGhlIGFyZWEgY3Jvc3NlcyB0aGUgYW50aW1lcmlkaWFuIChvZnRlbiBjb25mdXNlZCB3aXRoIHRoZSBJbnRlcm5hdGlvbmFsIERhdGUgTGluZSksIHlvdSBtdXN0IHNwZWNpZnkgY29ybmVycyBfb3V0c2lkZV8gdGhlIFstMTgwLCAxODBdIGRlZ3JlZXMgbG9uZ2l0dWRlIHJhbmdlLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYExhdExuZ0JvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gY29ybmVyMiA/IFtjb3JuZXIxLCBjb3JuZXIyXSA6IGNvcm5lcjE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0XHRzdzIgPSBvYmo7XHJcblx0XHRcdG5lMiA9IG9iajtcclxuXHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcblx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG5cdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG5cdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG5cdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIExhdExuZyB8fCAnbGF0JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcblx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9jcnMvQ1JTLkVhcnRoJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLyogQGNsYXNzIExhdExuZ1xyXG4gKiBAYWthIEwuTGF0TG5nXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBgXHJcbiAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuQmFzZVxyXG4gKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BhdGlhbF9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcclxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDUlMgPSB7XHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb1BvaW50KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIGdpdmVuIHpvb20uXHJcblx0bGF0TG5nVG9Qb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24uX3RyYW5zZm9ybShwcm9qZWN0ZWRQb2ludCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBsYXRMbmdUb1BvaW50YC4gUHJvamVjdHMgcGl4ZWwgY29vcmRpbmF0ZXMgb24gYSBnaXZlblxyXG5cdC8vIHpvb20gaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblx0cG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdCh1bnRyYW5zZm9ybWVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gY29vcmRpbmF0ZXMgaW4gdW5pdHMgYWNjZXB0ZWQgZm9yXHJcblx0Ly8gdGhpcyBDUlMgKGUuZy4gbWV0ZXJzIGZvciBFUFNHOjM4NTcsIGZvciBwYXNzaW5nIGl0IHRvIFdNUyBzZXJ2aWNlcykuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwcm9qZWN0ZWQgY29vcmRpbmF0ZSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIExhdExuZy5cclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlKHpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIHVzZWQgd2hlbiB0cmFuc2Zvcm1pbmcgcHJvamVjdGVkIGNvb3JkaW5hdGVzIGludG9cclxuXHQvLyBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBwYXJ0aWN1bGFyIHpvb20uIEZvciBleGFtcGxlLCBpdCByZXR1cm5zXHJcblx0Ly8gYDI1NiAqIDJeem9vbWAgZm9yIE1lcmNhdG9yLWJhc2VkIENSUy5cclxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiAyNTYgKiBNYXRoLnBvdygyLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb20oc2NhbGU6IE51bWJlcik6IE51bWJlclxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlKClgLCByZXR1cm5zIHRoZSB6b29tIGxldmVsIGNvcnJlc3BvbmRpbmcgdG8gYSBzY2FsZVxyXG5cdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xyXG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlIC8gMjU2KSAvIE1hdGguTE4yO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UHJvamVjdGVkQm91bmRzKHpvb206IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3Rpb24ncyBib3VuZHMgc2NhbGVkIGFuZCB0cmFuc2Zvcm1lZCBmb3IgdGhlIHByb3ZpZGVkIGB6b29tYC5cclxuXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRpZiAodGhpcy5pbmZpbml0ZSkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuXHRcdHZhciBiID0gdGhpcy5wcm9qZWN0aW9uLmJvdW5kcyxcclxuXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICBtaW4gPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1pbiwgcyksXHJcblx0XHQgICAgbWF4ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5tYXgsIHMpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgQm91bmRzKG1pbiwgbWF4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuXHQvLyBAcHJvcGVydHkgY29kZTogU3RyaW5nXHJcblx0Ly8gU3RhbmRhcmQgY29kZSBuYW1lIG9mIHRoZSBDUlMgcGFzc2VkIGludG8gV01TIHNlcnZpY2VzIChlLmcuIGAnRVBTRzozODU3J2ApXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExuZzogTnVtYmVyW11cclxuXHQvLyBBbiBhcnJheSBvZiB0d28gbnVtYmVycyBkZWZpbmluZyB3aGV0aGVyIHRoZSBsb25naXR1ZGUgKGhvcml6b250YWwpIGNvb3JkaW5hdGVcclxuXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG5cdC8vIGdlb2dyYXBoaWNhbCBDUlNzLiBJZiBgdW5kZWZpbmVkYCwgdGhlIGxvbmdpdHVkZSBheGlzIGRvZXMgbm90IHdyYXAgYXJvdW5kLlxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcblx0Ly8gTGlrZSBgd3JhcExuZ2AsIGJ1dCBmb3IgdGhlIGxhdGl0dWRlICh2ZXJ0aWNhbCkgYXhpcy5cclxuXHJcblx0Ly8gd3JhcExuZzogW21pbiwgbWF4XSxcclxuXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuXHQvLyBAcHJvcGVydHkgaW5maW5pdGU6IEJvb2xlYW5cclxuXHQvLyBJZiB0cnVlLCB0aGUgY29vcmRpbmF0ZSBzcGFjZSB3aWxsIGJlIHVuYm91bmRlZCAoaW5maW5pdGUgaW4gYm90aCBheGVzKVxyXG5cdGluZmluaXRlOiBmYWxzZSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGxhdCBhbmQgbG5nIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgbG5nID0gdGhpcy53cmFwTG5nID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sbmcsIHRoaXMud3JhcExuZywgdHJ1ZSkgOiBsYXRsbmcubG5nLFxyXG5cdFx0ICAgIGxhdCA9IHRoaXMud3JhcExhdCA/IFV0aWwud3JhcE51bShsYXRsbmcubGF0LCB0aGlzLndyYXBMYXQsIHRydWUpIDogbGF0bG5nLmxhdCxcclxuXHRcdCAgICBhbHQgPSBsYXRsbmcuYWx0O1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcclxuXHQvLyB0aGF0IGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdCb3VuZHNgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIgY2VudGVyID0gYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMud3JhcExhdExuZyhjZW50ZXIpLFxyXG5cdFx0ICAgIGxhdFNoaWZ0ID0gY2VudGVyLmxhdCAtIG5ld0NlbnRlci5sYXQsXHJcblx0XHQgICAgbG5nU2hpZnQgPSBjZW50ZXIubG5nIC0gbmV3Q2VudGVyLmxuZztcclxuXHJcblx0XHRpZiAobGF0U2hpZnQgPT09IDAgJiYgbG5nU2hpZnQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIGJvdW5kcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblx0XHQgICAgbmV3U3cgPSBuZXcgTGF0TG5nKHN3LmxhdCAtIGxhdFNoaWZ0LCBzdy5sbmcgLSBsbmdTaGlmdCksXHJcblx0XHQgICAgbmV3TmUgPSBuZXcgTGF0TG5nKG5lLmxhdCAtIGxhdFNoaWZ0LCBuZS5sbmcgLSBsbmdTaGlmdCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3U3csIG5ld05lKTtcclxuXHR9XHJcbn07XHJcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5FYXJ0aFxuICpcbiAqIFNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgQ1JTIHRoYXQgYXJlIGdsb2JhbCBzdWNoIHRoYXQgdGhleSBjb3ZlciB0aGUgZWFydGguXG4gKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBtZXRlcnMuXG4gKi9cblxuZXhwb3J0IHZhciBFYXJ0aCA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcblx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcblx0Ly8gc2VlIGh0dHBzOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG5cdFx0ICAgIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBzaW5ETG9uICogc2luRExvbixcblx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG52YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxuZXhwb3J0IHZhciBTcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHJcblx0UjogZWFydGhSYWRpdXMsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IGVhcnRoUmFkaXVzICogTWF0aC5QSTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG5cdH0pKClcclxufTtcclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRpZiAoVXRpbC5pc0FycmF5KGEpKSB7XHJcblx0XHQvLyB1c2UgYXJyYXkgcHJvcGVydGllc1xyXG5cdFx0dGhpcy5fYSA9IGFbMF07XHJcblx0XHR0aGlzLl9iID0gYVsxXTtcclxuXHRcdHRoaXMuX2MgPSBhWzJdO1xyXG5cdFx0dGhpcy5fZCA9IGFbM107XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59XHJcblxyXG5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG5cdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG5cclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuLy8gYFthOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXJdYC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRyZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpO1xyXG59XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHMzg1NyA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgRVBTRzkwMDkxMyA9IFV0aWwuZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcbiIsImltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5leHBvcnQgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4vLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4vLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcblx0dmFyIHN0ciA9ICcnLFxuXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdH1cblxuXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRzdHIgKz0gY2xvc2VkID8gKEJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHR9XG5cblx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3Ncblx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG59XG5cblxuXG5cbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuaW1wb3J0IHtzdmdDcmVhdGV9IGZyb20gJy4uL2xheWVyL3ZlY3Rvci9TVkcuVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICogQGFrYSBMLkJyb3dzZXJcclxuICpcclxuICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogaWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG4gKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgaWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcbnZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4vLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbnZhciBpZWx0OSA9IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyO1xyXG5cclxuLy8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcbnZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuO1xyXG4vLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbi8vICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxudmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgYnJvd3NlcnMgcnVubmluZyBvbiBBbmRyb2lkIDIgb3IgQW5kcm9pZCAzLlxyXG52YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbi8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxudmFyIHdlYmtpdFZlciA9IHBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLCAxMCk7IC8vIGFsc28gbWF0Y2hlcyBBcHBsZVdlYktpdFxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZFN0b2NrOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbnZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbnZhciBvcGVyYSA9ICEhd2luZG93Lm9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcbnZhciBjaHJvbWUgPSAhZWRnZSAmJiB1c2VyQWdlbnRDb250YWlucygnY2hyb21lJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG52YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4vLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxudmFyIHNhZmFyaSA9ICFjaHJvbWUgJiYgdXNlckFnZW50Q29udGFpbnMoJ3NhZmFyaScpO1xyXG5cclxudmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxudmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IHdpbjogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxudmFyIHdpbiA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdXaW4nKSA9PT0gMDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gc3R5bGUpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlV2Via2l0ID0gbW9iaWxlICYmIHdlYmtpdDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQzZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbnZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbnZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbnZhciBwb2ludGVyID0gISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoTmF0aXZlOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcbi8vICoqVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuKiogdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4vLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbi8vIHRvdWNoIGV2ZW50cy5cclxudmFyIHRvdWNoTmF0aXZlID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8ICEhd2luZG93LlRvdWNoRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgdG91Y2g6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBlaXRoZXIgW3RvdWNoXSgjYnJvd3Nlci10b3VjaCkgb3IgW3BvaW50ZXJdKCNicm93c2VyLXBvaW50ZXIpIGV2ZW50cy5cclxuLy8gTm90ZTogcG9pbnRlciBldmVudHMgd2lsbCBiZSBwcmVmZXJyZWQgKGlmIGF2YWlsYWJsZSksIGFuZCBwcm9jZXNzZWQgZm9yIGFsbCBgdG91Y2gqYCBsaXN0ZW5lcnMuXHJcbnZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAodG91Y2hOYXRpdmUgfHwgcG9pbnRlcik7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG52YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlR2Vja286IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuLy8gQHByb3BlcnR5IHJldGluYTogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIG9uIGEgaGlnaC1yZXNvbHV0aW9uIFwicmV0aW5hXCIgc2NyZWVuIG9yIG9uIGFueSBzY3JlZW4gd2hlbiBicm93c2VyJ3MgZGlzcGxheSB6b29tIGlzIG1vcmUgdGhhbiAxMDAlLlxyXG52YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuLy8gQHByb3BlcnR5IHBhc3NpdmVFdmVudHM6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgcGFzc2l2ZSBldmVudHMuXHJcbnZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2V0dGVyLXJldHVyblxyXG5cdFx0XHRcdHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuXHR9XHJcblx0cmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcclxufSgpKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cclxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cclxudmFyIGNhbnZhcyA9IChmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcclxufSgpKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBzdmc6IEJvb2xlYW5cclxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cclxudmFyIHN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBzdmdDcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xyXG5cclxudmFyIGlubGluZVN2ZyA9ICEhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdGRpdi5pbm5lckhUTUwgPSAnPHN2Zy8+JztcclxuXHRyZXR1cm4gKGRpdi5maXJzdENoaWxkICYmIGRpdi5maXJzdENoaWxkLm5hbWVzcGFjZVVSSSkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbn0pKCk7XHJcblxyXG4vLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxudmFyIHZtbCA9ICFzdmcgJiYgKGZ1bmN0aW9uICgpIHtcclxuXHR0cnkge1xyXG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XHJcblxyXG5cdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcblx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XHJcblxyXG5cdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XHJcblxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn0oKSk7XHJcblxyXG5cclxuLy8gQHByb3BlcnR5IG1hYzogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIE1hYyBwbGF0Zm9ybVxyXG52YXIgbWFjID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ01hYycpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IG1hYzogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIExpbnV4IHBsYXRmb3JtXHJcbnZhciBsaW51eCA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdMaW51eCcpID09PSAwO1xyXG5cclxuZnVuY3Rpb24gdXNlckFnZW50Q29udGFpbnMoc3RyKSB7XHJcblx0cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPj0gMDtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpZTogaWUsXHJcblx0aWVsdDk6IGllbHQ5LFxyXG5cdGVkZ2U6IGVkZ2UsXHJcblx0d2Via2l0OiB3ZWJraXQsXHJcblx0YW5kcm9pZDogYW5kcm9pZCxcclxuXHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuXHRhbmRyb2lkU3RvY2s6IGFuZHJvaWRTdG9jayxcclxuXHRvcGVyYTogb3BlcmEsXHJcblx0Y2hyb21lOiBjaHJvbWUsXHJcblx0Z2Vja286IGdlY2tvLFxyXG5cdHNhZmFyaTogc2FmYXJpLFxyXG5cdHBoYW50b206IHBoYW50b20sXHJcblx0b3BlcmExMjogb3BlcmExMixcclxuXHR3aW46IHdpbixcclxuXHRpZTNkOiBpZTNkLFxyXG5cdHdlYmtpdDNkOiB3ZWJraXQzZCxcclxuXHRnZWNrbzNkOiBnZWNrbzNkLFxyXG5cdGFueTNkOiBhbnkzZCxcclxuXHRtb2JpbGU6IG1vYmlsZSxcclxuXHRtb2JpbGVXZWJraXQ6IG1vYmlsZVdlYmtpdCxcclxuXHRtb2JpbGVXZWJraXQzZDogbW9iaWxlV2Via2l0M2QsXHJcblx0bXNQb2ludGVyOiBtc1BvaW50ZXIsXHJcblx0cG9pbnRlcjogcG9pbnRlcixcclxuXHR0b3VjaDogdG91Y2gsXHJcblx0dG91Y2hOYXRpdmU6IHRvdWNoTmF0aXZlLFxyXG5cdG1vYmlsZU9wZXJhOiBtb2JpbGVPcGVyYSxcclxuXHRtb2JpbGVHZWNrbzogbW9iaWxlR2Vja28sXHJcblx0cmV0aW5hOiByZXRpbmEsXHJcblx0cGFzc2l2ZUV2ZW50czogcGFzc2l2ZUV2ZW50cyxcclxuXHRjYW52YXM6IGNhbnZhcyxcclxuXHRzdmc6IHN2ZyxcclxuXHR2bWw6IHZtbCxcclxuXHRpbmxpbmVTdmc6IGlubGluZVN2ZyxcclxuXHRtYWM6IG1hYyxcclxuXHRsaW51eDogbGludXhcclxufTtcclxuIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtmYWxzZUZufSBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG52YXIgUE9JTlRFUl9ET1dOID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyAgIDogJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX01PVkUgPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnO1xudmFyIFBPSU5URVJfVVAgPSAgICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xudmFyIFBPSU5URVJfQ0FOQ0VMID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJztcbnZhciBwRXZlbnQgPSB7XG5cdHRvdWNoc3RhcnQgIDogUE9JTlRFUl9ET1dOLFxuXHR0b3VjaG1vdmUgICA6IFBPSU5URVJfTU9WRSxcblx0dG91Y2hlbmQgICAgOiBQT0lOVEVSX1VQLFxuXHR0b3VjaGNhbmNlbCA6IFBPSU5URVJfQ0FOQ0VMXG59O1xudmFyIGhhbmRsZSA9IHtcblx0dG91Y2hzdGFydCAgOiBfb25Qb2ludGVyU3RhcnQsXG5cdHRvdWNobW92ZSAgIDogX2hhbmRsZVBvaW50ZXIsXG5cdHRvdWNoZW5kICAgIDogX2hhbmRsZVBvaW50ZXIsXG5cdHRvdWNoY2FuY2VsIDogX2hhbmRsZVBvaW50ZXJcbn07XG52YXIgX3BvaW50ZXJzID0ge307XG52YXIgX3BvaW50ZXJEb2NMaXN0ZW5lciA9IGZhbHNlO1xuXG4vLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG4vLyByZWYgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpIHtcblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKTtcblx0fVxuXHRpZiAoIWhhbmRsZVt0eXBlXSkge1xuXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuXHRcdHJldHVybiBmYWxzZUZuO1xuXHR9XG5cdGhhbmRsZXIgPSBoYW5kbGVbdHlwZV0uYmluZCh0aGlzLCBoYW5kbGVyKTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG5cdHJldHVybiBoYW5kbGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuXHRpZiAoIXBFdmVudFt0eXBlXSkge1xuXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuXHRcdHJldHVybjtcblx0fVxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJEb3duKGUpIHtcblx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyTW92ZShlKSB7XG5cdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG5cdFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJVcChlKSB7XG5cdGRlbGV0ZSBfcG9pbnRlcnNbZS5wb2ludGVySWRdO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCkge1xuXHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cblx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKSB7XG5cdGlmIChlLnBvaW50ZXJUeXBlID09PSAoZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCAnbW91c2UnKSkgeyByZXR1cm47IH1cblxuXHRlLnRvdWNoZXMgPSBbXTtcblx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcblx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuXHR9XG5cdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0aGFuZGxlcihlKTtcbn1cblxuZnVuY3Rpb24gX29uUG9pbnRlclN0YXJ0KGhhbmRsZXIsIGUpIHtcblx0Ly8gSUUxMCBzcGVjaWZpYzogTXNUb3VjaCBuZWVkcyBwcmV2ZW50RGVmYXVsdC4gU2VlICMyMDAwXG5cdGlmIChlLk1TUE9JTlRFUl9UWVBFX1RPVUNIICYmIGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0gpIHtcblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fVxuXHRfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKTtcbn1cbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5cclxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKlxyXG4gKiBOb3RlOiBjdXJyZW50bHkgbW9zdCBicm93c2VycyBmaXJlIG5hdGl2ZSBkYmxjbGljaywgd2l0aCBvbmx5IGEgZmV3IGV4Y2VwdGlvbnNcclxuICogKHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy83MDEyI2lzc3VlY29tbWVudC01OTUwODczODYpXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWFrZURibGNsaWNrKGV2ZW50KSB7XHJcblx0Ly8gaW4gbW9kZXJuIGJyb3dzZXJzIGB0eXBlYCBjYW5ub3QgYmUganVzdCBvdmVycmlkZGVuOlxyXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9HZXR0ZXJfb25seVxyXG5cdHZhciBuZXdFdmVudCA9IHt9LFxyXG5cdCAgICBwcm9wLCBpO1xyXG5cdGZvciAoaSBpbiBldmVudCkge1xyXG5cdFx0cHJvcCA9IGV2ZW50W2ldO1xyXG5cdFx0bmV3RXZlbnRbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZChldmVudCkgOiBwcm9wO1xyXG5cdH1cclxuXHRldmVudCA9IG5ld0V2ZW50O1xyXG5cdG5ld0V2ZW50LnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdG5ld0V2ZW50LmRldGFpbCA9IDI7XHJcblx0bmV3RXZlbnQuaXNUcnVzdGVkID0gZmFsc2U7XHJcblx0bmV3RXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7IC8vIGZvciBkZWJ1ZyBwdXJwb3Nlc1xyXG5cdHJldHVybiBuZXdFdmVudDtcclxufVxyXG5cclxudmFyIGRlbGF5ID0gMjAwO1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKSB7XHJcblx0Ly8gTW9zdCBicm93c2VycyBoYW5kbGUgZG91YmxlIHRhcCBuYXRpdmVseVxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIpO1xyXG5cclxuXHQvLyBPbiBzb21lIHBsYXRmb3JtcyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgbmF0aXZlIGRibGNsaWNrcyBmb3IgdG91Y2ggZXZlbnRzLlxyXG5cdC8vIEl0IHNlZW1zIHRoYXQgaW4gYWxsIHN1Y2ggY2FzZXMgYGRldGFpbGAgcHJvcGVydHkgb2YgYGNsaWNrYCBldmVudCBpcyBhbHdheXMgYDFgLlxyXG5cdC8vIFNvIGhlcmUgd2UgcmVseSBvbiB0aGF0IGZhY3QgdG8gYXZvaWQgZXhjZXNzaXZlICdkYmxjbGljaycgc2ltdWxhdGlvbiB3aGVuIG5vdCBuZWVkZWQuXHJcblx0dmFyIGxhc3QgPSAwLFxyXG5cdCAgICBkZXRhaWw7XHJcblx0ZnVuY3Rpb24gc2ltRGJsY2xpY2soZSkge1xyXG5cdFx0aWYgKGUuZGV0YWlsICE9PSAxKSB7XHJcblx0XHRcdGRldGFpbCA9IGUuZGV0YWlsOyAvLyBrZWVwIGluIHN5bmMgdG8gYXZvaWQgZmFsc2UgZGJsY2xpY2sgaW4gc29tZSBjYXNlc1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHxcclxuXHRcdFx0KGUuc291cmNlQ2FwYWJpbGl0aWVzICYmICFlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSkge1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdoZW4gY2xpY2tpbmcgb24gYW4gPGlucHV0PiwgdGhlIGJyb3dzZXIgZ2VuZXJhdGVzIGEgY2xpY2sgb24gaXRzXHJcblx0XHQvLyA8bGFiZWw+IChhbmQgdmljZSB2ZXJzYSkgdHJpZ2dlcmluZyB0d28gY2xpY2tzIGluIHF1aWNrIHN1Y2Nlc3Npb24uXHJcblx0XHQvLyBUaGlzIGlnbm9yZXMgY2xpY2tzIG9uIGVsZW1lbnRzIHdoaWNoIGFyZSBhIGxhYmVsIHdpdGggYSAnZm9yJ1xyXG5cdFx0Ly8gYXR0cmlidXRlIChvciBjaGlsZHJlbiBvZiBzdWNoIGEgbGFiZWwpLCBidXQgbm90IGNoaWxkcmVuIG9mXHJcblx0XHQvLyBhIDxpbnB1dD4uXHJcblx0XHR2YXIgcGF0aCA9IERvbUV2ZW50LmdldFByb3BhZ2F0aW9uUGF0aChlKTtcclxuXHRcdGlmIChwYXRoLnNvbWUoZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRcdHJldHVybiBlbCBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQgJiYgZWwuYXR0cmlidXRlcy5mb3I7XHJcblx0XHR9KSAmJlxyXG5cdFx0XHQhcGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHxcclxuXHRcdFx0XHRcdGVsIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnRcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuXHRcdGlmIChub3cgLSBsYXN0IDw9IGRlbGF5KSB7XHJcblx0XHRcdGRldGFpbCsrO1xyXG5cdFx0XHRpZiAoZGV0YWlsID09PSAyKSB7XHJcblx0XHRcdFx0aGFuZGxlcihtYWtlRGJsY2xpY2soZSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkZXRhaWwgPSAxO1xyXG5cdFx0fVxyXG5cdFx0bGFzdCA9IG5vdztcclxuXHR9XHJcblxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNpbURibGNsaWNrKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGRibGNsaWNrOiBoYW5kbGVyLFxyXG5cdFx0c2ltRGJsY2xpY2s6IHNpbURibGNsaWNrXHJcblx0fTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcnMpIHtcclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVycy5kYmxjbGljayk7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcnMuc2ltRGJsY2xpY2spO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbmV4cG9ydCB2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcblx0Wyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4vLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OID0gdGVzdFByb3AoXHJcblx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTl9FTkQ6IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT05fRU5EID1cclxuXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldChpZCkge1xyXG5cdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHN0eWxlKSB7XHJcblx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG5cdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcblx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBDcmVhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIGB0YWdOYW1lYCwgc2V0cyBpdHMgY2xhc3MgdG8gYGNsYXNzTmFtZWAsIGFuZCBvcHRpb25hbGx5IGFwcGVuZHMgaXQgdG8gYGNvbnRhaW5lcmAgZWxlbWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuXHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQpIHtcclxuXHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGFsbCBvZiBgZWxgJ3MgY2hpbGRyZW4gZWxlbWVudHMgZnJvbSBgZWxgXHJcbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbCkge1xyXG5cdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcbi8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdH1cclxuXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIGNsYXNzZXMgPSBVdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRcdHNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c2V0Q2xhc3MoZWwsIFV0aWwudHJpbSgoJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xyXG5cdC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWR0VsZW1lbnRJbnN0YW5jZSBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nRWxlbWVudCBpbnN0ZWFkXHJcblx0Ly8gKFJlcXVpcmVkIGZvciBsaW5rZWQgU1ZHIGVsZW1lbnRzIGluIElFMTEuKVxyXG5cdGlmIChlbC5jb3JyZXNwb25kaW5nRWxlbWVudCkge1xyXG5cdFx0ZWwgPSBlbC5jb3JyZXNwb25kaW5nRWxlbWVudDtcclxuXHR9XHJcblx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbi8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4vLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG5cdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSkge1xyXG5cdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdHRyeSB7XHJcblx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdH1cclxuXHJcblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0aWYgKGZpbHRlcikge1xyXG5cdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4vLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbi8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcbi8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcclxuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG4vLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4vLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbi8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcblx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblxyXG5cdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG5cdFx0KEJyb3dzZXIuaWUzZCA/XHJcblx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcblx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG4vLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4vLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG4vLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcclxuXHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcblx0aWYgKEJyb3dzZXIuYW55M2QpIHtcclxuXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuLy8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG4vLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgdmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG5leHBvcnQgdmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbnZhciBfdXNlclNlbGVjdDtcclxuaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcbn0gZWxzZSB7XHJcblx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG5cdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdH1cclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4vLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxudmFyIF9vdXRsaW5lRWxlbWVudCwgX291dGxpbmVTdHlsZTtcclxuLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4vLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcblx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRpZiAoIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcblx0cmVzdG9yZU91dGxpbmUoKTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdF9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmVTdHlsZTtcclxuXHRlbGVtZW50LnN0eWxlLm91dGxpbmVTdHlsZSA9ICdub25lJztcclxuXHREb21FdmVudC5vbih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwucHJldmVudE91dGxpbmVgXSgpLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKSB7XHJcblx0aWYgKCFfb3V0bGluZUVsZW1lbnQpIHsgcmV0dXJuOyB9XHJcblx0X291dGxpbmVFbGVtZW50LnN0eWxlLm91dGxpbmVTdHlsZSA9IF9vdXRsaW5lU3R5bGU7XHJcblx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWw6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgd2hpY2ggc2l6ZSAod2lkdGggYW5kIGhlaWdodCkgaXMgbm90IG51bGwuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG5cdGRvIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fSB3aGlsZSAoKCFlbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFlbGVtZW50Lm9mZnNldEhlaWdodCkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSk7XHJcblx0cmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3RcclxuLy8gQ29tcHV0ZXMgdGhlIENTUyBzY2FsZSBjdXJyZW50bHkgYXBwbGllZCBvbiB0aGUgZWxlbWVudC5cclxuLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBtZW1iZXJzIGFzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjYWxlcyByZXNwZWN0aXZlbHksXHJcbi8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xyXG5cdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gUmVhZC1vbmx5IGluIG9sZCBicm93c2Vycy5cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEsXHJcblx0XHR5OiByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEsXHJcblx0XHRib3VuZGluZ0NsaWVudFJlY3Q6IHJlY3RcclxuXHR9O1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge2FkZFBvaW50ZXJMaXN0ZW5lciwgcmVtb3ZlUG9pbnRlckxpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LlBvaW50ZXInO1xyXG5pbXBvcnQge2FkZERvdWJsZVRhcExpc3RlbmVyLCByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Eb3VibGVUYXAnO1xyXG5pbXBvcnQge2dldFNjYWxlfSBmcm9tICcuL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG4vLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG4vLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG4vLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbmV4cG9ydCBmdW5jdGlvbiBvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZXMgJiYgdHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbi8vIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gb24sIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWVcclxuLy8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIG9mIGdpdmVuIHR5cGVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBmcm9tIGdpdmVuIEhUTUxFbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiBvZmYob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdGJhdGNoUmVtb3ZlKG9iaik7XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblxyXG5cdH0gZWxzZSBpZiAodHlwZXMgJiYgdHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdGJhdGNoUmVtb3ZlKG9iaiwgZnVuY3Rpb24gKHR5cGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gVXRpbC5pbmRleE9mKHR5cGVzLCB0eXBlKSAhPT0gLTE7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhdGNoUmVtb3ZlKG9iaiwgZmlsdGVyRm4pIHtcclxuXHRmb3IgKHZhciBpZCBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0dmFyIHR5cGUgPSBpZC5zcGxpdCgvXFxkLylbMF07XHJcblx0XHRpZiAoIWZpbHRlckZuIHx8IGZpbHRlckZuKHR5cGUpKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIG51bGwsIG51bGwsIGlkKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbnZhciBtb3VzZVN1YnN0ID0ge1xyXG5cdG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxyXG5cdG1vdXNlbGVhdmU6ICdtb3VzZW91dCcsXHJcblx0d2hlZWw6ICEoJ29ud2hlZWwnIGluIHdpbmRvdykgJiYgJ21vdXNld2hlZWwnXHJcbn07XHJcblxyXG5mdW5jdGlvbiBhZGRPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdH07XHJcblxyXG5cdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRpZiAoIUJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG5cdFx0aGFuZGxlciA9IGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcblx0XHRoYW5kbGVyID0gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJyB8fCB0eXBlID09PSAnd2hlZWwnIHx8ICB0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xyXG5cdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRcdFx0aWYgKGlzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG5cdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG9yaWdpbmFsSGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQsIGlkKSB7XHJcblx0aWQgPSBpZCB8fCB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblx0dmFyIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG5cdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRpZiAoIUJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykpIHtcclxuXHRcdHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuLy8gYGBganNcclxuLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4vLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuLy8gfSk7XHJcbi8vIGBgYFxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcblx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcblx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ3doZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsKSB7XHJcblx0YWRkT25lKGVsLCAnd2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RibGNsaWNrJ2AsIGAnY29udGV4dG1lbnUnYCxcclxuLy8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWwpIHtcclxuXHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrIGNvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddID0gdHJ1ZTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG4vLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcbi8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcbi8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xyXG5cdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcChlKSB7XHJcblx0cHJldmVudERlZmF1bHQoZSk7XHJcblx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UHJvcGFnYXRpb25QYXRoKGV2OiBET01FdmVudCk6IEFycmF5XHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtgRXZlbnQuY29tcG9zZWRQYXRoKClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnQvY29tcG9zZWRQYXRoKS5cclxuLy8gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBgSFRNTEVsZW1lbnRgcyB0aGF0IHRoZSBnaXZlbiBET00gZXZlbnRcclxuLy8gc2hvdWxkIHByb3BhZ2F0ZSB0byAoaWYgbm90IHN0b3BwZWQpLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGFnYXRpb25QYXRoKGV2KSB7XHJcblx0aWYgKGV2LmNvbXBvc2VkUGF0aCkge1xyXG5cdFx0cmV0dXJuIGV2LmNvbXBvc2VkUGF0aCgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHBhdGggPSBbXTtcclxuXHR2YXIgZWwgPSBldi50YXJnZXQ7XHJcblxyXG5cdHdoaWxlIChlbCkge1xyXG5cdFx0cGF0aC5wdXNoKGVsKTtcclxuXHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0cmV0dXJuIHBhdGg7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcbi8vIGBjb250YWluZXJgIChib3JkZXIgZXhjbHVkZWQpIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xyXG5cdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHR9XHJcblxyXG5cdHZhciBzY2FsZSA9IGdldFNjYWxlKGNvbnRhaW5lciksXHJcblx0ICAgIG9mZnNldCA9IHNjYWxlLmJvdW5kaW5nQ2xpZW50UmVjdDsgLy8gbGVmdCBhbmQgdG9wICB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgdGhlIGV2ZW50IGNsaWVudFgvWSlcclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdC8vIG9mZnNldC5sZWZ0L3RvcCB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgY2xpZW50WC9ZKSxcclxuXHRcdC8vIHdoZXJlYXMgY2xpZW50TGVmdC9Ub3AgKGJvcmRlciB3aWR0aCkgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgdmFsdWVzIChiZWZvcmUgQ1NTIHNjYWxlIGFwcGxpZXMpLlxyXG5cdFx0KGUuY2xpZW50WCAtIG9mZnNldC5sZWZ0KSAvIHNjYWxlLnggLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuXHRcdChlLmNsaWVudFkgLSBvZmZzZXQudG9wKSAvIHNjYWxlLnkgLSBjb250YWluZXIuY2xpZW50VG9wXHJcblx0KTtcclxufVxyXG5cclxuXHJcbi8vICBleGNlcHQgLCBTYWZhcmkgYW5kXHJcbi8vIFdlIG5lZWQgZG91YmxlIHRoZSBzY3JvbGwgcGl4ZWxzIChzZWUgIzc0MDMgYW5kICM0NTM4KSBmb3IgYWxsIEJyb3dzZXJzXHJcbi8vIGV4Y2VwdCBPU1ggKE1hYykgLT4gM3gsIENocm9tZSBydW5uaW5nIG9uIExpbnV4IDF4XHJcblxyXG52YXIgd2hlZWxQeEZhY3RvciA9XHJcblx0KEJyb3dzZXIubGludXggJiYgQnJvd3Nlci5jaHJvbWUpID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG5cdEJyb3dzZXIubWFjID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gKiAzIDpcclxuXHR3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDAgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG4vLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuLy8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSB3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbi8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4vLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4vLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0ICAgICAgIDA7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuXHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdHRyeSB7XHJcblx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub25gXSgjZG9tZXZlbnQtb24pXHJcbmV4cG9ydCB7b24gYXMgYWRkTGlzdGVuZXJ9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9mZmBdKCNkb21ldmVudC1vZmYpXHJcbmV4cG9ydCB7b2ZmIGFzIHJlbW92ZUxpc3RlbmVyfTtcclxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuXG4vKlxuICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteVBvc2l0aW9uTWFya2VyID0gTC5tYXJrZXIoWzQ4Ljg2NDcxNiwgMi4yOTQ2OTRdKS5hZGRUbyhtYXApO1xuICpcbiAqIG15UG9zaXRpb25NYXJrZXIub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAqIFx0dmFyIHBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobXlQb3NpdGlvbk1hcmtlci5nZXRMYXRMbmcoKSk7XG4gKiBcdHBvcy55IC09IDI1O1xuICogXHR2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqXG4gKiBcdGZ4Lm9uY2UoJ2VuZCcsZnVuY3Rpb24oKSB7XG4gKiBcdFx0cG9zLnkgKz0gMjU7XG4gKiBcdFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC44KTtcbiAqIFx0fSk7XG4gKlxuICogXHRmeC5ydW4obXlQb3NpdGlvbk1hcmtlci5faWNvbiwgcG9zLCAwLjMpO1xuICogfSk7XG4gKlxuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAqIENyZWF0ZXMgYSBgUG9zQW5pbWF0aW9uYCBvYmplY3QuXG4gKlxuICovXG5cbmV4cG9ydCB2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG5cdC8vIFJ1biBhbiBhbmltYXRpb24gb2YgYSBnaXZlbiBlbGVtZW50IHRvIGEgbmV3IHBvc2l0aW9uLCBvcHRpb25hbGx5IHNldHRpbmdcblx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG5cdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwczovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQge0VQU0czODU3fSBmcm9tICcuLi9nZW8vY3JzL0NSUy5FUFNHMzg1Nyc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtCb3VuZHMsIHRvQm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb3NBbmltYXRpb259IGZyb20gJy4uL2RvbS9Qb3NBbmltYXRpb24nO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcFxyXG4gKiBAYWthIEwuTWFwXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogLy8gaW5pdGlhbGl6ZSB0aGUgbWFwIG9uIHRoZSBcIm1hcFwiIGRpdiB3aXRoIGEgZ2l2ZW4gY2VudGVyIGFuZCB6b29tXHJcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gKiBcdHpvb206IDEzXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcCA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xyXG5cdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG5cdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBFUFNHMzg1NyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuXHRcdGNlbnRlcjogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcblx0XHR6b29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgaGlnaGVzdCBvZiB0aGVpciBgbWF4Wm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcblx0XHQvLyBBcnJheSBvZiBsYXllcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgaW5pdGlhbGx5XHJcblx0XHRsYXllcnM6IFtdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcblx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXHJcblx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG5cdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcblx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXHJcblx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuXHRcdC8vIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZHJhd2luZyB2ZWN0b3IgbGF5ZXJzIG9uIHRoZSBtYXAuIGBMLlNWR2BcclxuXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG5cdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcclxuXHRcdC8vIFdvbid0IGFuaW1hdGUgem9vbSBpZiB0aGUgem9vbSBkaWZmZXJlbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1hcmtlclpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG5cdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuXHRcdC8vIGVuYWJsZWQgaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuXHRcdC8vIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiBhIENTUyB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0uIFRoZSBkZWZhdWx0XHJcblx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG5cdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuXHRcdHRyYW5zZm9ybTNETGltaXQ6IDgzODg2MDgsIC8vIFByZWNpc2lvbiBsaW1pdCBvZiBhIDMyLWJpdCBmbG9hdFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuXHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcclxuXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcblx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuXHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcclxuXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0em9vbVNuYXA6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tRGVsdGE6IE51bWJlciA9IDFcclxuXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcblx0XHQvLyBvciBgLWAgb24gdGhlIGtleWJvYXJkLCBvciB1c2luZyB0aGUgW3pvb20gY29udHJvbHNdKCNjb250cm9sLXpvb20pLlxyXG5cdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG5cdFx0em9vbURlbHRhOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhY2tSZXNpemU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdG8gYXNzaWduIGludGVybmFsIGZsYWdzIGF0IHRoZSBiZWdpbm5pbmcsXHJcblx0XHQvLyB0byBhdm9pZCBpbmNvbnNpc3RlbnQgc3RhdGUgaW4gc29tZSBlZGdlIGNhc2VzLlxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBVdGlsLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBEb21VdGlsLlRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG5cdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG5cdFx0XHREb21FdmVudC5vbih0aGlzLl9wcm94eSwgRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG5cdFx0XHRcdG9wdGlvbnMucGFuID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG5cdFx0XHRpZiAobW92ZWQpIHtcclxuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSwgb3B0aW9ucy5wYW4gJiYgb3B0aW9ucy5wYW4ubm9Nb3ZlU3RhcnQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbSh6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHpvb20gb2YgdGhlIG1hcC5cclxuXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIEluY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuXHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXHJcblx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIFBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0X2dldEJvdW5kc0NlbnRlclpvb206IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcblx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuXHRcdHpvb20gPSAodHlwZW9mIG9wdGlvbnMubWF4Wm9vbSA9PT0gJ251bWJlcicpID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0aWYgKHpvb20gPT09IEluZmluaXR5KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Y2VudGVyOiBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHRcdFx0em9vbTogem9vbVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG5cdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcblx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0V29ybGQob3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG5cdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhblRvKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG5cdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCwgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xyXG5cdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcclxuXHRcdC8vIGFuZCBtYWtlcyB0aGVtIGRpc2FwcGVhciBvciBhcHBlYXIgaW4gdGhlIHdyb25nIHBsYWNlIChzbGlnaHRseSBvZmZzZXQpICMyNjAyXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IFBvc0FuaW1hdGlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XHJcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxyXG5cdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcclxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHJcblx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHBlcmZvcm1pbmcgYSBzbW9vdGhcclxuXHQvLyBwYW4tem9vbSBhbmltYXRpb24uXHJcblx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8ICFCcm93c2VyLmFueTNkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcblx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcclxuXHJcblx0XHR0YXJnZXRDZW50ZXIgPSB0b0xhdExuZyh0YXJnZXRDZW50ZXIpO1xyXG5cdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XHJcblxyXG5cdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxyXG5cdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxyXG5cdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXHJcblx0XHQgICAgcmhvID0gMS40MixcclxuXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHIoaSkge1xyXG5cdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxyXG5cdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcclxuXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcclxuXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxyXG5cdFx0XHQgICAgYiA9IHQxIC8gYjEsXHJcblx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcclxuXHJcblx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXHJcblx0XHRcdCAgICAvLyB0aHVzIHRyaWdnZXJpbmcgYW4gaW5maW5pdGUgbG9vcCBpbiBmbHlUb1xyXG5cdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbG9nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cclxuXHJcblx0XHR2YXIgcjAgPSByKDApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XHJcblx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxyXG5cclxuXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XHJcblxyXG5cdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBTID0gKHIoMSkgLSByMCkgLyByaG8sXHJcblx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcclxuXHJcblx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcclxuXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxyXG5cdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xyXG5cclxuXHRcdFx0aWYgKHQgPD0gMSkge1xyXG5cdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9tb3ZlKFxyXG5cdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcclxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcclxuXHRcdFx0XHRcdHtmbHlUbzogdHJ1ZX0pO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdFx0XHQuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKVxyXG5cdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQpO1xyXG5cclxuXHRcdGZyYW1lLmNhbGwodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uIGxpa2UgW2BmbHlUb2BdKCNtYXAtZmx5dG8pLFxyXG5cdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuXHRmbHlUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcblx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLmxpc3RlbnMoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG5cdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgdG9MYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG5cdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBwYWRkaW5nIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRoZSBtaW5pbXVtIGFtb3VudCB0byBtYWtlIHRoZSBgbGF0bG5nYCB2aXNpYmxlLiBVc2VcclxuXHQvLyBwYWRkaW5nIG9wdGlvbnMgdG8gZml0IHRoZSBkaXNwbGF5IHRvIG1vcmUgcmVzdHJpY3RlZCBib3VuZHMuXHJcblx0Ly8gSWYgYGxhdGxuZ2AgaXMgYWxyZWFkeSB3aXRoaW4gdGhlIChvcHRpb25hbGx5IHBhZGRlZCkgZGlzcGxheSBib3VuZHMsXHJcblx0Ly8gdGhlIG1hcCB3aWxsIG5vdCBiZSBwYW5uZWQuXHJcblx0cGFuSW5zaWRlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcblx0XHQgICAgcGl4ZWxQb2ludCA9IHRoaXMucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHBpeGVsQm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHBhZGRlZEJvdW5kcyA9IHRvQm91bmRzKFtwaXhlbEJvdW5kcy5taW4uYWRkKHBhZGRpbmdUTCksIHBpeGVsQm91bmRzLm1heC5zdWJ0cmFjdChwYWRkaW5nQlIpXSksXHJcblx0XHQgICAgcGFkZGVkU2l6ZSA9IHBhZGRlZEJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG5cdFx0aWYgKCFwYWRkZWRCb3VuZHMuY29udGFpbnMocGl4ZWxQb2ludCkpIHtcclxuXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdFx0dmFyIGNlbnRlck9mZnNldCA9IHBpeGVsUG9pbnQuc3VidHJhY3QocGFkZGVkQm91bmRzLmdldENlbnRlcigpKTtcclxuXHRcdFx0dmFyIG9mZnNldCA9IHBhZGRlZEJvdW5kcy5leHRlbmQocGl4ZWxQb2ludCkuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRlZFNpemUpO1xyXG5cdFx0XHRwaXhlbENlbnRlci54ICs9IGNlbnRlck9mZnNldC54IDwgMCA/IC1vZmZzZXQueCA6IG9mZnNldC54O1xyXG5cdFx0XHRwaXhlbENlbnRlci55ICs9IGNlbnRlck9mZnNldC55IDwgMCA/IC1vZmZzZXQueSA6IG9mZnNldC55O1xyXG5cdFx0XHR0aGlzLnBhblRvKHRoaXMudW5wcm9qZWN0KHBpeGVsQ2VudGVyKSwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG5cdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG5cdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcblx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG5cdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG5cdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblx0Ly8gQG1ldGhvZCBzdG9wKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG5cdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxyXG5cdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcblx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG5cdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cclxuXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcblx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0XHR3YXRjaDogZmFsc2VcclxuXHRcdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG5cdFx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcblx0XHRcdFx0Y29kZTogMCxcclxuXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25SZXNwb25zZSA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuXHRcdCAgICBvbkVycm9yID0gVXRpbC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdG9wTG9jYXRlKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB3YXRjaGluZyBsb2NhdGlvbiBwcmV2aW91c2x5IGluaXRpYXRlZCBieSBgbWFwLmxvY2F0ZSh7d2F0Y2g6IHRydWV9KWBcclxuXHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcclxuXHQvLyBge3NldFZpZXc6IHRydWV9YC5cclxuXHRzdG9wTG9jYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBjID0gZXJyb3IuY29kZSxcclxuXHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fFxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDEgPyAncGVybWlzc2lvbiBkZW5pZWQnIDpcclxuXHRcdCAgICAgICAgICAgIChjID09PSAyID8gJ3Bvc2l0aW9uIHVuYXZhaWxhYmxlJyA6ICd0aW1lb3V0JykpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgJiYgIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpdFdvcmxkKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25lcnJvcjogRXJyb3JFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZCkgZmFpbGVkLlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xyXG5cdFx0XHRjb2RlOiBjLFxyXG5cdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gZXJyb3I6ICcgKyBtZXNzYWdlICsgJy4nXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcblx0XHQgICAgbG5nID0gcG9zLmNvb3Jkcy5sb25naXR1ZGUsXHJcblx0XHQgICAgbGF0bG5nID0gbmV3IExhdExuZyhsYXQsIGxuZyksXHJcblx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG5cdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykgeyB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVySWQgIT09IHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYmVpbmcgcmV1c2VkIGJ5IGFub3RoZXIgaW5zdGFuY2UnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZDtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRpb25XYXRjaElkICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zdG9wTG9jYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fcmVzaXplUmVxdWVzdCkge1xyXG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHVubG9hZDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcblx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGk7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcclxuXHRcdH1cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9wYW5lcykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9wYW5lcyA9IFtdO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX21hcFBhbmU7XHJcblx0XHRkZWxldGUgdGhpcy5fcmVuZGVyZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDcmVhdGVzIGEgbmV3IFttYXAgcGFuZV0oI21hcC1wYW5lKSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSxcclxuXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZCBvZiBgY29udGFpbmVyYCwgb3JcclxuXHQvLyBhcyBhIGNoaWxkIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcblx0Y3JlYXRlUGFuZTogZnVuY3Rpb24gKG5hbWUsIGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcblx0XHQgICAgcGFuZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAobmFtZSkge1xyXG5cdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyLmNsb25lKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNaW5ab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcblx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1heFpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLlxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4sIHBhZGRpbmc/OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXHJcblx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG5cdFx0ICAgIHNjYWxleSA9IHNpemUueSAvIGJvdW5kc1NpemUueSxcclxuXHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcclxuXHJcblx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBQb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcblx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG5cdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcblx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcblx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcblx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG5cdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG5cdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG5cdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcblx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcblx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh0b0xhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuXHQvLyBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuXHQvLyBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyB0aGUgY2VudGVyIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXBzIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG5cdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcblx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0b0xhdExuZyhsYXRsbmcpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVySWQgPSBVdGlsLnN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgQnJvd3Nlci5hbnkzZDtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcgJiYgcG9zaXRpb24gIT09ICdzdGlja3knKSB7XHJcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuXHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcclxuXHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly9cclxuXHRcdC8vIFBhbmVzIGFyZSBET00gZWxlbWVudHMgdXNlZCB0byBjb250cm9sIHRoZSBvcmRlcmluZyBvZiBsYXllcnMgb24gdGhlIG1hcC4gWW91XHJcblx0XHQvLyBjYW4gYWNjZXNzIHBhbmVzIHdpdGggW2BtYXAuZ2V0UGFuZWBdKCNtYXAtZ2V0cGFuZSkgb3JcclxuXHRcdC8vIFtgbWFwLmdldFBhbmVzYF0oI21hcC1nZXRwYW5lcykgbWV0aG9kcy4gTmV3IHBhbmVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlXHJcblx0XHQvLyBbYG1hcC5jcmVhdGVQYW5lYF0oI21hcC1jcmVhdGVwYW5lKSBtZXRob2QuXHJcblx0XHQvL1xyXG5cdFx0Ly8gRXZlcnkgbWFwIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgcGFuZXMgdGhhdCBkaWZmZXIgb25seSBpbiB6SW5kZXguXHJcblx0XHQvL1xyXG5cdFx0Ly8gQHBhbmUgbWFwUGFuZTogSFRNTEVsZW1lbnQgPSAnYXV0bydcclxuXHRcdC8vIFBhbmUgdGhhdCBjb250YWlucyBhbGwgb3RoZXIgbWFwIHBhbmVzXHJcblxyXG5cdFx0dGhpcy5fbWFwUGFuZSA9IHRoaXMuY3JlYXRlUGFuZSgnbWFwUGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0Ly8gQHBhbmUgdGlsZVBhbmU6IEhUTUxFbGVtZW50ID0gMjAwXHJcblx0XHQvLyBQYW5lIGZvciBgR3JpZExheWVyYHMgYW5kIGBUaWxlTGF5ZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0aWxlUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgb3ZlcmxheVBhbmU6IEhUTUxFbGVtZW50ID0gNDAwXHJcblx0XHQvLyBQYW5lIGZvciB2ZWN0b3JzIChgUGF0aGBzLCBsaWtlIGBQb2x5bGluZWBzIGFuZCBgUG9seWdvbmBzKSwgYEltYWdlT3ZlcmxheWBzIGFuZCBgVmlkZW9PdmVybGF5YHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcblx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgbWFya2VyUGFuZTogSFRNTEVsZW1lbnQgPSA2MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHRvb2x0aXBQYW5lOiBIVE1MRWxlbWVudCA9IDY1MFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFRvb2x0aXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHBvcHVwUGFuZTogSFRNTEVsZW1lbnQgPSA3MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub01vdmVTdGFydCkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHRcdHRoaXNcclxuXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIW5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSwgc3VwcmVzc0V2ZW50KSB7XHJcblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHJcblx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcblx0XHR0aGlzLl9waXhlbE9yaWdpbiA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFzdXByZXNzRXZlbnQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCxcclxuXHRcdFx0Ly8gaW5jbHVkaW5nIHpvb20gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcblx0XHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCxcclxuXHRcdFx0Ly8gaW5jbHVkaW5nIHBhbiBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG5cdFx0fSBlbHNlIGlmIChkYXRhICYmIGRhdGEucGluY2gpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNlbnRlciBvZiB0aGUgbWFwIHN0b3BzIGNoYW5naW5nXHJcblx0XHQvLyAoZS5nLiB1c2VyIHN0b3BwZWQgZHJhZ2dpbmcgdGhlIG1hcCBvciBhZnRlciBub24tY2VudGVyZWQgem9vbSkuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG5cdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcblx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcblx0XHR0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IERvbUV2ZW50Lm9mZiA6IERvbUV2ZW50Lm9uO1xyXG5cclxuXHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXHJcblx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcblx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcblx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHQvLyBAZXZlbnQga2V5ZG93bjogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC4gVW5saWtlIHRoZSBga2V5cHJlc3NgIGV2ZW50LFxyXG5cdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcblx0XHQvLyB0aGF0IGRvIG5vdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXVwOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdG9uT2ZmKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG5cdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0b25PZmYod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdChyZW1vdmUgPyB0aGlzLm9mZiA6IHRoaXMub24pLmNhbGwodGhpcywgJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcblx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpbmRFdmVudFRhcmdldHM6IGZ1bmN0aW9uIChlLCB0eXBlKSB7XHJcblx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxyXG5cdFx0ICAgIHRhcmdldCxcclxuXHRcdCAgICBpc0hvdmVyID0gdHlwZSA9PT0gJ21vdXNlb3V0JyB8fCB0eXBlID09PSAnbW91c2VvdmVyJyxcclxuXHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXHJcblx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcblx0XHR3aGlsZSAoc3JjKSB7XHJcblx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcChzcmMpXTtcclxuXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcblx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcblx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiB0aGlzLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH0sXHJcblxyXG5cdF9pc0NsaWNrRGlzYWJsZWQ6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0d2hpbGUgKGVsICYmIGVsICE9PSB0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0aWYgKGVsWydfbGVhZmxldF9kaXNhYmxlX2NsaWNrJ10pIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBlbCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgZWxbJ19sZWFmbGV0X2Rpc2FibGVfZXZlbnRzJ10gfHwgZS50eXBlID09PSAnY2xpY2snICYmIHRoaXMuX2lzQ2xpY2tEaXNhYmxlZChlbCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJykge1xyXG5cdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZShlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3VzZUV2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXSxcclxuXHJcblx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIGNhbnZhc1RhcmdldHMpIHtcclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cclxuXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcblx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXHJcblx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG5cdFx0XHR2YXIgc3ludGggPSBVdGlsLmV4dGVuZCh7fSwgZSk7XHJcblx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG5cdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIGNhbnZhc1RhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuXHRcdHZhciB0YXJnZXRzID0gdGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKTtcclxuXHJcblx0XHRpZiAoY2FudmFzVGFyZ2V0cykge1xyXG5cdFx0XHR2YXIgZmlsdGVyZWQgPSBbXTsgLy8gcGljayBvbmx5IHRhcmdldHMgd2l0aCBsaXN0ZW5lcnNcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYW52YXNUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKGNhbnZhc1RhcmdldHNbaV0ubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRcdFx0ZmlsdGVyZWQucHVzaChjYW52YXNUYXJnZXRzW2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGFyZ2V0cyA9IGZpbHRlcmVkLmNvbmNhdCh0YXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnKSB7XHJcblx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGUudHlwZSAhPT0gJ2tleXByZXNzJyAmJiBlLnR5cGUgIT09ICdrZXlkb3duJyAmJiBlLnR5cGUgIT09ICdrZXl1cCcpIHtcclxuXHRcdFx0dmFyIGlzTWFya2VyID0gdGFyZ2V0LmdldExhdExuZyAmJiAoIXRhcmdldC5fcmFkaXVzIHx8IHRhcmdldC5fcmFkaXVzIDw9IDEwKTtcclxuXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuXHRcdFx0XHR0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XHJcblx0XHRcdGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XHJcblx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG5cdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgVXRpbC5pbmRleE9mKHRoaXMuX21vdXNlRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG5cdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG5cdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0b0JvdW5kcyhbXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG5cdFx0XSk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSA8PSAxICYmIE1hdGguYWJzKG9mZnNldC55KSA8PSAxKSB7XHJcblx0XHRcdHJldHVybiBjZW50ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSB0b0JvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcblx0XHQgICAgKSxcclxuXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25TdGVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcclxuXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XHJcblxyXG5cdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHR2YXIgcHJvcCA9IERvbVV0aWwuVFJBTlNGT1JNLFxyXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF07XHJcblxyXG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGUuY2VudGVyLCBlLnpvb20pLCB0aGlzLmdldFpvb21TY2FsZShlLnpvb20sIDEpKTtcclxuXHJcblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXHJcblx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2Rlc3Ryb3lBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3Byb3h5KTtcclxuXHRcdHRoaXMub2ZmKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xyXG5cdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChjLCB6KSwgdGhpcy5nZXRab29tU2NhbGUoeiwgMSkpO1xyXG5cdH0sXHJcblxyXG5cdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XHJcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxyXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuXHRcdCAgICAgICAgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQgfHwgZmFsc2UpXHJcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwUGFuZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoc3RhcnRBbmltKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE90aGVyIEV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcblx0XHQvLyBGaXJlZCBhdCBsZWFzdCBvbmNlIHBlciB6b29tIGFuaW1hdGlvbi4gRm9yIGNvbnRpbnVvdXMgem9vbSwgbGlrZSBwaW5jaCB6b29taW5nLCBmaXJlZCBvbmNlIHBlciBmcmFtZSBkdXJpbmcgem9vbS5cclxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tLFxyXG5cdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICghdGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuXHRcdFx0dGhpcy5fdGVtcEZpcmVab29tRXZlbnQgPSB0aGlzLl96b29tICE9PSB0aGlzLl9hbmltYXRlVG9ab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcclxuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xyXG5cdH0sXHJcblxyXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbScpO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50O1xyXG5cclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gdGhlIERPTSBJRCBvZiBhIGA8ZGl2PmAgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbi8vXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hcChpZCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFwKGlkLCBvcHRpb25zKTtcclxufVxyXG4iLCJcclxuaW1wb3J0IHtDbGFzc30gZnJvbSAnLi4vY29yZS9DbGFzcyc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sXHJcbiAqIEBha2EgTC5Db250cm9sXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENvbnRyb2wgPSBDbGFzcy5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sIE9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXHJcblx0XHQvLyBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgKG9uZSBvZiB0aGUgbWFwIGNvcm5lcnMpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndG9wbGVmdCdgLFxyXG5cdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRQb3NpdGlvbjogc3RyaW5nXHJcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0ICovXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2wuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcblx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcblx0XHRcdHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub2ZmKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IHZhciBjb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IENvbnRyb2wob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gKiBAdW5pbmhlcml0YWJsZVxyXG4gKlxyXG4gKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICovXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAqL1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwXHJcblx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcFxyXG5cdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcblx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcblx0XHQgICAgICAgICAgICBEb21VdGlsLmNyZWF0ZSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xyXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuXHRcdFx0Y29ybmVyc1t2U2lkZSArIGhTaWRlXSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29ybmVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycztcclxuXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xyXG5cdH1cclxufSk7XHJcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIsIHRvdWNoLCBvciBrZXlib2FyZCBhY3RpdmF0aW9uLlxyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuXHRcdGF1dG9aSW5kZXg6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG5cdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIGxheWVycy4gV2hlbiBgZmFsc2VgLCBsYXllcnMgd2lsbCBrZWVwIHRoZSBvcmRlclxyXG5cdFx0Ly8gaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHRvIHRoZSBjb250cm9sLlxyXG5cdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0RnVuY3Rpb246IEZ1bmN0aW9uID0gKlxyXG5cdFx0Ly8gQSBbY29tcGFyZSBmdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydClcclxuXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuXHRcdC8vIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBib3RoIHRoZSBgTC5MYXllcmAgaW5zdGFuY2VzIGFuZCB0aGVpciBuYW1lcywgYXMgaW5cclxuXHRcdC8vIGBzb3J0RnVuY3Rpb24obGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQilgLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcblx0XHRzb3J0RnVuY3Rpb246IGZ1bmN0aW9uIChsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKSB7XHJcblx0XHRcdHJldHVybiBuYW1lQSA8IG5hbWVCID8gLTEgOiAobmFtZUIgPCBuYW1lQSA/IDEgOiAwKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG5cdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXHJcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcclxuXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblxyXG5cdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uID0gRG9tVXRpbC5jcmVhdGUoJ3NlY3Rpb24nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAoY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHJcblx0XHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xyXG5cdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuX2V4cGFuZFNhZmVseSxcclxuXHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24obGluaywge1xyXG5cdFx0XHRrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGlmIChlLmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIENlcnRhaW4gc2NyZWVuIHJlYWRlcnMgaW50ZXJjZXB0IHRoZSBrZXkgZXZlbnQgYW5kIGluc3RlYWQgc2VuZCBhIGNsaWNrIGV2ZW50XHJcblx0XHRcdGNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0XHRcdHRoaXMuX2V4cGFuZFNhZmVseSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIHNlY3Rpb24pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgVXRpbC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoVXRpbC5iaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5cmVtb3ZlOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwNzkpXHJcblx0X2NyZWF0ZVJhZGlvRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGNoZWNrZWQpIHtcclxuXHJcblx0XHR2YXIgcmFkaW9IdG1sID0gJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIiBuYW1lPVwiJyArXHJcblx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcclxuXHJcblx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRJdGVtOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG5cdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSxcclxuXHRcdCAgICBpbnB1dDtcclxuXHJcblx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG5cdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG5cdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVyc18nICsgVXRpbC5zdGFtcCh0aGlzKSwgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IFV0aWwuc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHREb21FdmVudC5vbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG5cdFx0Ly8gSGVscHMgZnJvbSBwcmV2ZW50aW5nIGxheWVyIGNvbnRyb2wgZmxpY2tlciB3aGVuIGNoZWNrYm94ZXMgYXJlIGRpc2FibGVkXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcblx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gZXhwYW5kaW5nIHRoZSBjb250cm9sIG9uIG1vYmlsZSB3aXRoIGEgY2xpY2sgY2FuIGNhdXNlIGFkZGluZyBhIGxheWVyIC0gd2UgZG9uJ3Qgd2FudCB0aGlzXHJcblx0XHRpZiAodGhpcy5fcHJldmVudENsaWNrKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LCBsYXllcjtcclxuXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG5cdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cclxuXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIocmVtb3ZlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIoYWRkZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0Rpc2FibGVkTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGxheWVyLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRTYWZlbHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbjtcclxuXHRcdHRoaXMuX3ByZXZlbnRDbGljayA9IHRydWU7XHJcblx0XHREb21FdmVudC5vbihzZWN0aW9uLCAnY2xpY2snLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZihzZWN0aW9uLCAnY2xpY2snLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0XHRcdHRoYXQuX3ByZXZlbnRDbGljayA9IGZhbHNlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbmV4cG9ydCB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4rPC9zcGFuPidcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRleHQ6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4rPC9zcGFuPicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiN4MjIxMjs8L3NwYW4+J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiN4MjIxMjs8L3NwYW4+JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuXHRcdCAgICBjb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tT3V0VGV4dCwgb3B0aW9ucy56b29tT3V0VGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tT3V0KHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbikge1xyXG5cdFx0dmFyIGxpbmsgPSBEb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogV2lsbCBmb3JjZSBzY3JlZW4gcmVhZGVycyBsaWtlIFZvaWNlT3ZlciB0byByZWFkIHRoaXMgYXMgXCJab29tIGluIC0gYnV0dG9uXCJcclxuXHRcdCAqL1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihsaW5rKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIERvbUV2ZW50LnN0b3ApO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gbGluaztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuXHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdFx0dGhpcy5fem9vbU91dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdFx0dGhpcy5fem9vbUluQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0Ly8gQHNlY3Rpb24gQ29udHJvbHNcclxuXHRcdC8vIEBwcm9wZXJ0eSB6b29tQ29udHJvbDogQ29udHJvbC5ab29tXHJcblx0XHQvLyBUaGUgZGVmYXVsdCB6b29tIGNvbnRyb2wgKG9ubHkgYXZhaWxhYmxlIGlmIHRoZVxyXG5cdFx0Ly8gW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB3YXMgYHRydWVgIHdoZW4gY3JlYXRpbmcgdGhlIG1hcCkuXHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IFpvb20oKTtcclxuXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLlpvb21cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSB6b29tIGNvbnRyb2xcclxuZXhwb3J0IHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbn07XHJcbiIsIlxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCB2YXIgc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xufTtcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbnZhciB1a3JhaW5pYW5GbGFnID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCI4XCIgdmlld0JveD1cIjAgMCAxMiA4XCIgY2xhc3M9XCJsZWFmbGV0LWF0dHJpYnV0aW9uLWZsYWdcIj48cGF0aCBmaWxsPVwiIzRDN0JFMVwiIGQ9XCJNMCAwaDEydjRIMHpcIi8+PHBhdGggZmlsbD1cIiNGRkQ1MDBcIiBkPVwiTTAgNGgxMnYzSDB6XCIvPjxwYXRoIGZpbGw9XCIjRTBCQzAwXCIgZD1cIk0wIDdoMTJ2MUgwelwiLz48L3N2Zz4nO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmd8ZmFsc2UgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj4nICsgKEJyb3dzZXIuaW5saW5lU3ZnID8gdWtyYWluaWFuRmxhZyArICcgJyA6ICcnKSArICdMZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdG1hcC5vbignbGF5ZXJhZGQnLCB0aGlzLl9hZGRBdHRyaWJ1dGlvbiwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9hZGRBdHRyaWJ1dGlvbiwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2FkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoZXYpIHtcclxuXHRcdGlmIChldi5sYXllci5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHRldi5sYXllci5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmd8ZmFsc2UpOiB0aGlzXHJcblx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCcmY29weTsgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnMnYCkuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG5cdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcblx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnw8L3NwYW4+ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbmV4cG9ydCB2YXIgYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q29udHJvbCwgY29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCB7TGF5ZXJzLCBsYXllcnN9IGZyb20gJy4vQ29udHJvbC5MYXllcnMnO1xuaW1wb3J0IHtab29tLCB6b29tfSBmcm9tICcuL0NvbnRyb2wuWm9vbSc7XG5pbXBvcnQge1NjYWxlLCBzY2FsZX0gZnJvbSAnLi9Db250cm9sLlNjYWxlJztcbmltcG9ydCB7QXR0cmlidXRpb24sIGF0dHJpYnV0aW9ufSBmcm9tICcuL0NvbnRyb2wuQXR0cmlidXRpb24nO1xuXG5Db250cm9sLkxheWVycyA9IExheWVycztcbkNvbnRyb2wuWm9vbSA9IFpvb207XG5Db250cm9sLlNjYWxlID0gU2NhbGU7XG5Db250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbmNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuY29udHJvbC56b29tID0gem9vbTtcbmNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbmNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuZXhwb3J0IHtDb250cm9sLCBjb250cm9sfTtcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG5leHBvcnQgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG5cdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxufSk7XG5cbi8vIEBzZWN0aW9uIFRoZXJlIGlzIHN0YXRpYyBmdW5jdGlvbiB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkhhbmRsZXI6XG4vLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbi8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5IYW5kbGVyLmFkZFRvID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuIiwiaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi9Ccm93c2VyJztcbmV4cG9ydCB7QnJvd3Nlcn07XG5cbmV4cG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4vRXZlbnRzJztcbmltcG9ydCB7RXZlbnRzfSBmcm9tICcuL0V2ZW50cyc7XG5leHBvcnQge0V2ZW50ZWR9O1xuZXhwb3J0IHZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbmV4cG9ydCB7SGFuZGxlcn0gZnJvbSAnLi9IYW5kbGVyJztcblxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xuZXhwb3J0IHtVdGlsfTtcbmV4cG9ydCB7ZXh0ZW5kLCBiaW5kLCBzdGFtcCwgc2V0T3B0aW9uc30gZnJvbSAnLi9VdGlsJztcbiIsImltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQGFrYSBMLkRyYWdnYWJsZVxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBBIGNsYXNzIGZvciBtYWtpbmcgRE9NIGVsZW1lbnRzIGRyYWdnYWJsZSAoaW5jbHVkaW5nIHRvdWNoIHN1cHBvcnQpLlxyXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGVsZW1lbnRUb0RyYWcpO1xyXG4gKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBTVEFSVCA9IEJyb3dzZXIudG91Y2ggPyAndG91Y2hzdGFydCBtb3VzZWRvd24nIDogJ21vdXNlZG93bic7XHJcblxyXG5leHBvcnQgdmFyIERyYWdnYWJsZSA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vIEBha2EgRHJhZ2dhYmxlIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcblx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcblx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG5cdH0sXHJcblxyXG5cdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU/OiBCb29sZWFuLCBvcHRpb25zPzogRHJhZ2dhYmxlIG9wdGlvbnMpXHJcblx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG5cdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcblx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG5cdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZyB0aGlzIGRyYWdnYWJsZSxcclxuXHRcdC8vIGRpc2FibGluZyBpdCBjb3VudHMgYXMgZmlyc3QgZW5kaW5nIHRoZSBkcmFnLlxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuXHRcdFx0dGhpcy5maW5pc2hEcmFnKHRydWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChEb21VdGlsLmhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xyXG5cdFx0XHQvLyBGaW5pc2ggZHJhZ2dpbmcgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCB0b3VjaFpvb21cclxuXHRcdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuXHRcdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcblx0XHQgICAgc2l6ZWRQYXJlbnQgPSBEb21VdGlsLmdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuXHRcdC8vIENhY2hlIHRoZSBzY2FsZSwgc28gdGhhdCB3ZSBjYW4gY29udGludW91c2x5IGNvbXBlbnNhdGUgZm9yIGl0IGR1cmluZyBkcmFnIChfb25Nb3ZlKS5cclxuXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gRG9tVXRpbC5nZXRTY2FsZShzaXplZFBhcmVudCk7XHJcblxyXG5cdFx0dmFyIG1vdXNlZXZlbnQgPSBlLnR5cGUgPT09ICdtb3VzZWRvd24nO1xyXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIG1vdXNlZXZlbnQgPyAnbW91c2Vtb3ZlJyA6ICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIG1vdXNlZXZlbnQgPyAnbW91c2V1cCcgOiAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLl9zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgdGhlIHBhcmVudCBjb250YWluZXIncyBwb3NpdGlvbiwgYm9yZGVyIGFuZCBzY2FsZSBkbyBub3QgY2hhbmdlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRyYWcuXHJcblx0XHQvLyBUaGVyZWZvcmUgdGhlcmUgaXMgbm8gbmVlZCB0byBhY2NvdW50IGZvciB0aGUgcG9zaXRpb24gYW5kIGJvcmRlciAodGhleSBhcmUgZWxpbWluYXRlZCBieSB0aGUgc3VidHJhY3Rpb24pXHJcblx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcblx0XHRvZmZzZXQueCAvPSB0aGlzLl9wYXJlbnRTY2FsZS54O1xyXG5cdFx0b2Zmc2V0LnkgLz0gdGhpcy5fcGFyZW50U2NhbGUueTtcclxuXHJcblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcblx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHRpZiAod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSAmJiB0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkge1xyXG5cdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmlzaERyYWc6IGZ1bmN0aW9uIChub0luZXJ0aWEpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdFRhcmdldCkge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAnbW91c2V1cCB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cclxuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHR2YXIgZmlyZURyYWdlbmQgPSB0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3Zpbmc7XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKGZpcmVEcmFnZW5kKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0bm9JbmVydGlhOiBub0luZXJ0aWEsXHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG59KTtcclxuIiwiaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi9MaW5lVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuLypcclxuICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29uIGdlb21ldHJpZXMuXHJcbiAqL1xyXG5cclxuLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICogQ2xpcHMgdGhlIHBvbHlnb24gZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYHBvaW50c2AgYnkgdGhlIGdpdmVuIGJvdW5kcyAodXNpbmcgdGhlIFtTdXRoZXJsYW5kLUhvZGdtYW4gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXRoZXJsYW5kJUUyJTgwJTkzSG9kZ21hbl9hbGdvcml0aG0pKS5cclxuICogVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5Z29uIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmdcclxuICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gKiB0aGFuIHBvbHlsaW5lLCBzbyB0aGVyZSdzIGEgc2VwYXJhdGUgbWV0aG9kIGZvciBpdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcblx0ICAgIGksIGosIGssXHJcblx0ICAgIGEsIGIsXHJcblx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gTGluZVV0aWwuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKGEpO1xyXG5cclxuXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcblx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHRwID0gTGluZVV0aWwuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuLyogQGZ1bmN0aW9uIHBvbHlnb25DZW50ZXIobGF0bG5nczogTGF0TG5nW10sIGNyczogQ1JTKTogTGF0TG5nXHJcbiAqIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBhc3NlZCBMYXRMbmdzIChmaXJzdCByaW5nKSBmcm9tIGEgcG9seWdvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3MsIGNycykge1xyXG5cdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcjtcclxuXHJcblx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFMaW5lVXRpbC5pc0ZsYXQobGF0bG5ncykpIHtcclxuXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcblx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuXHR9XHJcblxyXG5cdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG5cdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRsbmdzKTtcclxuXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG5cdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuXHRpZiAoYXJlYUJvdW5kcyA8IDE3MDApIHtcclxuXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuXHR9XHJcblxyXG5cdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuXHR2YXIgcG9pbnRzID0gW107XHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcblx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcblx0fVxyXG5cclxuXHRhcmVhID0geCA9IHkgPSAwO1xyXG5cclxuXHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTtcclxuXHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0cDEgPSBwb2ludHNbaV07XHJcblx0XHRwMiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcclxuXHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XHJcblx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xyXG5cdFx0YXJlYSArPSBmICogMztcclxuXHR9XHJcblxyXG5cdGlmIChhcmVhID09PSAwKSB7XHJcblx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cclxuXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XHJcblx0fVxyXG5cclxuXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG5cdHJldHVybiB0b0xhdExuZyhbbGF0bG5nQ2VudGVyLmxhdCArIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nQ2VudGVyLmxuZyArIGNlbnRyb2lkTGF0TG5nLmxuZ10pO1xyXG59XHJcblxyXG4vKiBAZnVuY3Rpb24gY2VudHJvaWQobGF0bG5nczogTGF0TG5nW10pOiBMYXRMbmdcclxuICogUmV0dXJucyB0aGUgJ2NlbnRlciBvZiBtYXNzJyBvZiB0aGUgcGFzc2VkIExhdExuZ3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2VudHJvaWQoY29vcmRzKSB7XHJcblx0dmFyIGxhdFN1bSA9IDA7XHJcblx0dmFyIGxuZ1N1bSA9IDA7XHJcblx0dmFyIGxlbiA9IDA7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0bGF0U3VtICs9IGxhdGxuZy5sYXQ7XHJcblx0XHRsbmdTdW0gKz0gbGF0bG5nLmxuZztcclxuXHRcdGxlbisrO1xyXG5cdH1cclxuXHRyZXR1cm4gdG9MYXRMbmcoW2xhdFN1bSAvIGxlbiwgbG5nU3VtIC8gbGVuXSk7XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7Y2VudHJvaWR9IGZyb20gJy4vUG9seVV0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuXHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlsaW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG4vLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuLy8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcbi8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4vLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4vLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG4vLyBbUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbi8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuLy8gZWFjaCB6b29tIGxldmVsIGFuZCBhbHNvIHJlZHVjaW5nIHZpc3VhbCBub2lzZS4gdG9sZXJhbmNlIGFmZmVjdHMgdGhlIGFtb3VudCBvZlxyXG4vLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4vLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwczovL21vdXJuZXIuZ2l0aHViLmlvL3NpbXBsaWZ5LWpzLykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHQgICAgcG9pbnRzID0gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbn1cclxuXHJcbi8vIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0dmFyIGksXHJcblx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRwcmV2ID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbn1cclxuXHJcbnZhciBfbGFzdENvZGU7XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4vLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbi8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBTZWdtZW50KGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUsIHJvdW5kKSB7XHJcblx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyBfbGFzdENvZGUgOiBfZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG5cdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuXHQgICAgLy8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG5cdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0cmV0dXJuIFthLCBiXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0aWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcblx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRuZXdDb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcclxuXHRcdFx0YSA9IHA7XHJcblx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGIgPSBwO1xyXG5cdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0ICAgIHgsIHk7XHJcblxyXG5cdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtYXgueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtaW4ueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0eCA9IG1heC54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdHggPSBtaW4ueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcblx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdGNvZGUgfD0gMTtcclxuXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0Y29kZSB8PSAyO1xyXG5cdH1cclxuXHJcblx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdGNvZGUgfD0gNDtcclxuXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuXHRcdGNvZGUgfD0gODtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb2RlO1xyXG59XHJcblxyXG4vLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5leHBvcnQgZnVuY3Rpb24gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0dmFyIHggPSBwMS54LFxyXG5cdCAgICB5ID0gcDEueSxcclxuXHQgICAgZHggPSBwMi54IC0geCxcclxuXHQgICAgZHkgPSBwMi55IC0geSxcclxuXHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXHJcblx0ICAgIHQ7XHJcblxyXG5cdGlmIChkb3QgPiAwKSB7XHJcblx0XHR0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gZG90O1xyXG5cclxuXHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0eSA9IHAyLnk7XHJcblx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHR5ICs9IGR5ICogdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGR4ID0gcC54IC0geDtcclxuXHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxufVxyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0ZsYXQobGF0bG5nczogTGF0TG5nW10pOiBCb29sZWFuXHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xyXG5cdHJldHVybiAhVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9mbGF0KGxhdGxuZ3MpIHtcclxuXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcblx0cmV0dXJuIGlzRmxhdChsYXRsbmdzKTtcclxufVxyXG5cclxuLyogQGZ1bmN0aW9uIHBvbHlsaW5lQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gKiBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwYXNzZWQgTGF0TG5ncyAoZmlyc3QgcmluZykgZnJvbSBhIHBvbHlsaW5lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lQ2VudGVyKGxhdGxuZ3MsIGNycykge1xyXG5cdHZhciBpLCBoYWxmRGlzdCwgc2VnRGlzdCwgZGlzdCwgcDEsIHAyLCByYXRpbywgY2VudGVyO1xyXG5cclxuXHRpZiAoIWxhdGxuZ3MgfHwgbGF0bG5ncy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignbGF0bG5ncyBub3QgcGFzc2VkJyk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWlzRmxhdChsYXRsbmdzKSkge1xyXG5cdFx0Y29uc29sZS53YXJuKCdsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWQnKTtcclxuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzWzBdO1xyXG5cdH1cclxuXHJcblx0dmFyIGNlbnRyb2lkTGF0TG5nID0gdG9MYXRMbmcoWzAsIDBdKTtcclxuXHJcblx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xyXG5cdHZhciBhcmVhQm91bmRzID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldFNvdXRoV2VzdCgpKSAqIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXROb3J0aFdlc3QoKSk7XHJcblx0Ly8gdGVzdHMgc2hvd2VkIHRoYXQgYmVsb3cgMTcwMCByb3VuZGluZyBlcnJvcnMgYXJlIGhhcHBlbmluZ1xyXG5cdGlmIChhcmVhQm91bmRzIDwgMTcwMCkge1xyXG5cdFx0Ly8gZ2V0dGluZyBhIGluZXhhY3QgY2VudGVyLCB0byBtb3ZlIHRoZSBsYXRsbmdzIG5lYXIgdG8gWzAsIDBdIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzXHJcblx0XHRjZW50cm9pZExhdExuZyA9IGNlbnRyb2lkKGxhdGxuZ3MpO1xyXG5cdH1cclxuXHJcblx0dmFyIGxlbiA9IGxhdGxuZ3MubGVuZ3RoO1xyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcclxuXHRcdHBvaW50cy5wdXNoKGNycy5wcm9qZWN0KHRvTGF0TG5nKFtsYXRsbmcubGF0IC0gY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmcubG5nIC0gY2VudHJvaWRMYXRMbmcubG5nXSkpKTtcclxuXHR9XHJcblxyXG5cdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG5cdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xyXG5cdH1cclxuXHJcblx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxyXG5cdGlmIChoYWxmRGlzdCA9PT0gMCkge1xyXG5cdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcclxuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xyXG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XHJcblx0XHRcdGRpc3QgKz0gc2VnRGlzdDtcclxuXHJcblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcclxuXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcclxuXHRcdFx0XHRjZW50ZXIgPSBbXHJcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxyXG5cdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxyXG5cdFx0XHRcdF07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZhciBsYXRsbmdDZW50ZXIgPSBjcnMudW5wcm9qZWN0KHRvUG9pbnQoY2VudGVyKSk7XHJcblx0cmV0dXJuIHRvTGF0TG5nKFtsYXRsbmdDZW50ZXIubGF0ICsgY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmdDZW50ZXIubG5nICsgY2VudHJvaWRMYXRMbmcubG5nXSk7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHNlY3Rpb25cclxuICogTGVhZmxldCBjb21lcyB3aXRoIGEgc2V0IG9mIGFscmVhZHkgZGVmaW5lZCBQcm9qZWN0aW9ucyBvdXQgb2YgdGhlIGJveDpcclxuICpcclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gKlxyXG4gKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICogbGF0aXR1ZGUuIEFsc28gc3VpdGFibGUgZm9yIGZsYXQgd29ybGRzLCBlLmcuIGdhbWUgbWFwcy4gVXNlZCBieSB0aGVcclxuICogYEVQU0c6NDMyNmAgYW5kIGBTaW1wbGVgIENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIExvbkxhdCA9IHtcclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxufTtcclxuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAqXHJcbiAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuIiwiLypcbiAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAqIEBwcm9wZXJ0eSBib3VuZHM6IEJvdW5kc1xuICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAqIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGEgMkQgcG9pbnQuXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICovXG5cbmV4cG9ydCB7TG9uTGF0fSBmcm9tICcuL1Byb2plY3Rpb24uTG9uTGF0JztcbmV4cG9ydCB7TWVyY2F0b3J9IGZyb20gJy4vUHJvamVjdGlvbi5NZXJjYXRvcic7XG5leHBvcnQge1NwaGVyaWNhbE1lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3InO1xuIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge01lcmNhdG9yfSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3InO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gKlxyXG4gKiBSYXJlbHkgdXNlZCBieSBzb21lIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIFVzZXMgRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IHZhciBFUFNHMzM5NSA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjMzOTUnLFxyXG5cdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAqXHJcbiAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKlxyXG4gKiBMZWFmbGV0IDEuMC54IGNvbXBsaWVzIHdpdGggdGhlIFtUTVMgY29vcmRpbmF0ZSBzY2hlbWUgZm9yIEVQU0c6NDMyNl0oaHR0cHM6Ly93aWtpLm9zZ2VvLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2VfU3BlY2lmaWNhdGlvbiNnbG9iYWwtZ2VvZGV0aWMpLFxyXG4gKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAqIHdob2xlIGVhcnRoIGF0IHpvb20gbGV2ZWwgemVybywgYW5kIHRoYXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBvcmlnaW4gaXMgKC0xODAsKzkwKSxcclxuICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHNDMyNiA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cdHByb2plY3Rpb246IExvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcclxuIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0JztcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuU2ltcGxlXG4gKlxuICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gKiBNYXkgYmUgdXNlZCBmb3IgbWFwcyBvZiBmbGF0IHN1cmZhY2VzIChlLmcuIGdhbWUgbWFwcykuIE5vdGUgdGhhdCB0aGUgYHlgXG4gKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gKi9cblxuZXhwb3J0IHZhciBTaW1wbGUgPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHByb2plY3Rpb246IExvbkxhdCxcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcblx0fSxcblxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG5cdH0sXG5cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcblx0XHQgICAgZHkgPSBsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0O1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdH0sXG5cblx0aW5maW5pdGU6IHRydWVcbn0pO1xuIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcbmltcG9ydCB7RVBTRzMzOTV9IGZyb20gJy4vQ1JTLkVQU0czMzk1JztcbmltcG9ydCB7RVBTRzM4NTcsIEVQU0c5MDA5MTN9IGZyb20gJy4vQ1JTLkVQU0czODU3JztcbmltcG9ydCB7RVBTRzQzMjZ9IGZyb20gJy4vQ1JTLkVQU0c0MzI2JztcbmltcG9ydCB7U2ltcGxlfSBmcm9tICcuL0NSUy5TaW1wbGUnO1xuXG5DUlMuRWFydGggPSBFYXJ0aDtcbkNSUy5FUFNHMzM5NSA9IEVQU0czMzk1O1xuQ1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG5DUlMuRVBTRzkwMDkxMyA9IEVQU0c5MDA5MTM7XG5DUlMuRVBTRzQzMjYgPSBFUFNHNDMyNjtcbkNSUy5TaW1wbGUgPSBTaW1wbGU7XG5cbmV4cG9ydCB7Q1JTfTtcbiIsImltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIExheWVyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogQGFrYSBMLkxheWVyXG4gKiBAYWthIElMYXllclxuICpcbiAqIEEgc2V0IG9mIG1ldGhvZHMgZnJvbSB0aGUgTGF5ZXIgYmFzZSBjbGFzcyB0aGF0IGFsbCBMZWFmbGV0IGxheWVycyB1c2UuXG4gKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5tYXJrZXIobGF0bG5nKS5hZGRUbyhtYXApO1xuICogbGF5ZXIuYWRkVG8obWFwKTtcbiAqIGxheWVyLnJlbW92ZSgpO1xuICogYGBgXG4gKlxuICogQGV2ZW50IGFkZDogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyBhZGRlZCB0byBhIG1hcFxuICpcbiAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgbWFwXG4gKi9cblxuXG5leHBvcnQgdmFyIExheWVyID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnb3ZlcmxheVBhbmUnXG5cdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBlLmcuIFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIi4gSXQgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhIGFuZCBpcyBvZnRlbiBhIGxlZ2FsIG9ibGlnYXRpb24gdG93YXJkcyBjb3B5cmlnaHQgaG9sZGVycyBhbmQgdGlsZSBwcm92aWRlcnMuXG5cdFx0YXR0cmlidXRpb246IG51bGwsXG5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0LyogQHNlY3Rpb25cblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXB8TGF5ZXJHcm91cCk6IHRoaXNcblx0ICogQWRkcyB0aGUgbGF5ZXIgdG8gdGhlIGdpdmVuIG1hcCBvciBsYXllciBncm91cC5cblx0ICovXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBtYXBcblx0Ly9cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShncm91cDogTGF5ZXJHcm91cCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gYExheWVyR3JvdXBgXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gKiBAdW5pbmhlcml0YWJsZVxuICpcbiAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAqXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICpcbiAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICpcbiAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICpcbiAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcFxuICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gKlxuICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAqXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gKi9cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgTGF5ZXIuJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cblx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiBVdGlsLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnM7XG5cdH0sXG5cblx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHQgKiBgYGBcblx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG5cdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKFV0aWwuaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNYXhab29tICYmIHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5fbGF5ZXJzTWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNaW5ab29tICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5fbGF5ZXJzTWluWm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuXHRcdH1cblx0fVxufSk7XG4iLCJcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBsYXllcklkID0gdHlwZW9mIGxheWVyID09PSAnbnVtYmVyJyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHRcdHJldHVybiBsYXllcklkIGluIHRoaXMuX2xheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAqXHJcbiAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBGZWF0dXJlR3JvdXAgPSBMYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4vLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IHZhciBmZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi4vLi4vY29yZS9DbGFzcyc7XHJcbmltcG9ydCB7c2V0T3B0aW9uc30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG5cdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHRvb2x0aXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdCAqL1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG5cdFx0dG9vbHRpcEFuY2hvcjogWzAsIDBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpemUgPSBwb2ludChzaXplT3B0aW9uKSxcclxuXHRcdCAgICBhbmNob3IgPSBwb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIEJyb3dzZXIucmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAqIEBzZWN0aW9uXG4gKlxuICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAqIG5vIGljb24gaXMgc3BlY2lmaWVkLiBQb2ludHMgdG8gdGhlIGJsdWUgbWFya2VyIGltYWdlIGRpc3RyaWJ1dGVkIHdpdGggTGVhZmxldFxuICogcmVsZWFzZXMuXG4gKlxuICogSW4gb3JkZXIgdG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IGljb24sIGp1c3QgY2hhbmdlIHRoZSBwcm9wZXJ0aWVzIG9mIGBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUub3B0aW9uc2BcbiAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gX2NvbXBsZXRlbHlfIHJlcGxhY2UgdGhlIGRlZmF1bHQgaWNvbiwgb3ZlcnJpZGUgdGhlXG4gKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gKi9cblxuZXhwb3J0IHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvblVybDogICAgICAgJ21hcmtlci1pY29uLnBuZycsXG5cdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG5cdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcblx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcblx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKHR5cGVvZiBJY29uRGVmYXVsdC5pbWFnZVBhdGggIT09ICdzdHJpbmcnKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0fSxcblxuXHRfc3RyaXBVcmw6IGZ1bmN0aW9uIChwYXRoKSB7XHQvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byB1c2UgaW4gdGVzdHNcblx0XHR2YXIgc3RyaXAgPSBmdW5jdGlvbiAoc3RyLCByZSwgaWR4KSB7XG5cdFx0XHR2YXIgbWF0Y2ggPSByZS5leGVjKHN0cik7XG5cdFx0XHRyZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbaWR4XTtcblx0XHR9O1xuXHRcdHBhdGggPSBzdHJpcChwYXRoLCAvXnVybFxcKChbJ1wiXSk/KC4rKVxcMVxcKSQvLCAyKTtcblx0XHRyZXR1cm4gcGF0aCAmJiBzdHJpcChwYXRoLCAvXiguKiltYXJrZXItaWNvblxcLnBuZyQvLCAxKTtcblx0fSxcblxuXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG5cdFx0ICAgICAgICAgICBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXHRcdHBhdGggPSB0aGlzLl9zdHJpcFVybChwYXRoKTtcblx0XHRpZiAocGF0aCkgeyByZXR1cm4gcGF0aDsgfVxuXHRcdHZhciBsaW5rID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGlua1tocmVmJD1cImxlYWZsZXQuY3NzXCJdJyk7XG5cdFx0aWYgKCFsaW5rKSB7IHJldHVybiAnJzsgfVxuXHRcdHJldHVybiBsaW5rLmhyZWYuc3Vic3RyaW5nKDAsIGxpbmsuaHJlZi5sZW5ndGggLSAnbGVhZmxldC5jc3MnLmxlbmd0aCAtIDEpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtEcmFnZ2FibGV9IGZyb20gJy4uLy4uL2RvbS9EcmFnZ2FibGUnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtyZXF1ZXN0QW5pbUZyYW1lLCBjYW5jZWxBbmltRnJhbWV9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICovXG5cbmV4cG9ydCB2YXIgTWFya2VyRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcblx0XHQgICAgc3BlZWQgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuU3BlZWQsXG5cdFx0ICAgIHBhZGRpbmcgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuUGFkZGluZyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG5cdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG5cdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG5cdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG5cdFx0KTtcblxuXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG5cdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG5cdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKG1hcmtlci5faWNvbiwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MpO1xuXHRcdFx0dGhpcy5fb25EcmFnKGUpO1xuXG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXG5cdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXG5cdFx0Ly8gV2hlbiB1c2luZyBFUzYgaW1wb3J0cyBpdCBjb3VsZCBub3QgYmUgc2V0IHdoZW4gYFBvcHVwYCB3YXMgbm90IGltcG9ydGVkIGFzIHdlbGxcblx0XHR0aGlzLl9tYXJrZXIuY2xvc2VQb3B1cCAmJiB0aGlzLl9tYXJrZXIuY2xvc2VQb3B1cCgpO1xuXG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0XHQuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHRcdC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuKSB7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG5cdFx0fVxuXG5cdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5vbGRMYXRMbmcgPSB0aGlzLl9vbGRMYXRMbmc7XG5cblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG5cdFx0bWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQgY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0b3BzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cdFx0ZGVsZXRlIHRoaXMuX29sZExhdExuZztcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcclxuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcgYXMgbGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQge01hcmtlckRyYWd9IGZyb20gJy4vTWFya2VyLkRyYWcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcmtlclxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICogQGFrYSBMLk1hcmtlclxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcblx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcblx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG5cdFx0Ly8gW1VzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2FjY2Vzc2liaWxpdHkvI21hcmtlcnMtbXVzdC1iZS1sYWJlbGxlZCkuXHJcblx0XHR0aXRsZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICdNYXJrZXInXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlLlxyXG5cdFx0Ly8gW1VzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2FjY2Vzc2liaWxpdHkvI21hcmtlcnMtbXVzdC1iZS1sYWJlbGxlZCkuXHJcblx0XHRhbHQ6ICdNYXJrZXInLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc2hhZG93UGFuZTogU3RyaW5nID0gJ3NoYWRvd1BhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIHNoYWRvdyB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5PbkZvY3VzOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXAgd2lsbCBwYW4gd2hlbmV2ZXIgdGhlIG1hcmtlciBpcyBmb2N1c2VkICh2aWFcclxuXHRcdC8vIGUuZy4gcHJlc3NpbmcgYHRhYmAgb24gdGhlIGtleWJvYXJkKSB0byBlbnN1cmUgdGhlIG1hcmtlciBpc1xyXG5cdFx0Ly8gdmlzaWJsZSB3aXRoaW4gdGhlIG1hcCdzIGJvdW5kc1xyXG5cdFx0YXV0b1Bhbk9uRm9jdXM6IHRydWUsXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dhYmxlIG1hcmtlciBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGRyYWdnYWJsZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG5cdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBwYW4gdGhlIG1hcCB3aGVuIGRyYWdnaW5nIHRoaXMgbWFya2VyIG5lYXIgaXRzIGVkZ2Ugb3Igbm90LlxyXG5cdFx0YXV0b1BhbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1MCwgNTApXHJcblx0XHQvLyBEaXN0YW5jZSAoaW4gcGl4ZWxzIHRvIHRoZSBsZWZ0L3JpZ2h0IGFuZCB0byB0aGUgdG9wL2JvdHRvbSkgb2YgdGhlXHJcblx0XHQvLyBtYXAgZWRnZSB0byBzdGFydCBwYW5uaW5nIHRoZSBtYXAuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUwLCA1MF0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuU3BlZWQ6IE51bWJlciA9IDEwXHJcblx0XHQvLyBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBtYXAgc2hvdWxkIHBhbiBieS5cclxuXHRcdGF1dG9QYW5TcGVlZDogMTBcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqXHJcblx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5kcmFnZ2luZy5yZW1vdmVIb29rcygpO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMuZHJhZ2dpbmc7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMudXBkYXRlXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEljb246IEljb25cclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGljb24gdXNlZCBieSB0aGUgbWFya2VyXHJcblx0Z2V0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uICYmIHRoaXMuX21hcCkge1xyXG5cdFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0ICAgIGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGljb24udGFnTmFtZSA9PT0gJ0lNRycpIHtcclxuXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0IHx8ICcnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG5cdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0XHRpY29uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG5cdFx0XHREb21FdmVudC5vbihpY29uLCAnZm9jdXMnLCB0aGlzLl9wYW5PbkZvY3VzLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdFx0bmV3U2hhZG93LmFsdCA9ICcnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcblx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGlmIChhZGRJY29uKSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ljb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5faW5pdEludGVyYWN0aW9uKCk7XHJcblx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUob3B0aW9ucy5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG5cdFx0XHREb21FdmVudC5vZmYodGhpcy5faWNvbiwgJ2ZvY3VzJywgdGhpcy5fcGFuT25Gb2N1cywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faWNvbik7XHJcblx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcclxuXHJcblx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHRoaXMuX2ljb24uc3R5bGUuekluZGV4ID0gdGhpcy5fekluZGV4ICsgb2Zmc2V0O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKG9wdCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XHJcblxyXG5cdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbnRlcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHJcblx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdGlmIChNYXJrZXJEcmFnKSB7XHJcblx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG5cdFx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG5cdFx0XHRcdGRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpO1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IE1hcmtlckRyYWcodGhpcyk7XHJcblxyXG5cdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5PbkZvY3VzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGljb25PcHRzID0gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucztcclxuXHRcdHZhciBzaXplID0gaWNvbk9wdHMuaWNvblNpemUgPyBwb2ludChpY29uT3B0cy5pY29uU2l6ZSkgOiBwb2ludCgwLCAwKTtcclxuXHRcdHZhciBhbmNob3IgPSBpY29uT3B0cy5pY29uQW5jaG9yID8gcG9pbnQoaWNvbk9wdHMuaWNvbkFuY2hvcikgOiBwb2ludCgwLCAwKTtcclxuXHJcblx0XHRtYXAucGFuSW5zaWRlKHRoaXMuX2xhdGxuZywge1xyXG5cdFx0XHRwYWRkaW5nVG9wTGVmdDogYW5jaG9yLFxyXG5cdFx0XHRwYWRkaW5nQm90dG9tUmlnaHQ6IHNpemUuc3VidHJhY3QoYW5jaG9yKVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvcjtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvcjtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBQYXRoXG4gKiBAYWthIEwuUGF0aFxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAqL1xuXG5leHBvcnQgdmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCAnd2VpZ2h0JykpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgK1xuXHRcdCAgKHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlIHx8IDApO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVNYXJrZXJcbiAqIEBha2EgTC5DaXJjbGVNYXJrZXJcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjaXJjbGUgb2YgYSBmaXhlZCBzaXplIHdpdGggcmFkaXVzIHNwZWNpZmllZCBpbiBwaXhlbHMuIEV4dGVuZHMgYFBhdGhgLlxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlTWFya2VyID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcblx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuXHRcdHJhZGl1czogMTBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBjaXJjbGUgbWFya2VyIHRvIGEgbmV3IGxvY2F0aW9uLlxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjY2lyY2xlbWFya2VyLXNldGxhdGxuZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fSxcblxuXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuXHRcdFBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcblx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdH0sXG5cblx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5pbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7RWFydGh9IGZyb20gJy4uLy4uL2dlby9jcnMvQ1JTLkVhcnRoJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZVxuICogQGFrYSBMLkNpcmNsZVxuICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICpcbiAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGUgPSBDaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG5cdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcblx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SKSAvIGQsXG5cdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogcC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54O1xuXHRcdFx0dGhpcy5fcmFkaXVzWSA9IHAueSAtIHRvcC55O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4vLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlsaW5lXG4gKiBAYWthIEwuUG9seWxpbmVcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFs0NS41MSwgLTEyMi42OF0sXG4gKiBcdFszNy43NywgLTEyMi40M10sXG4gKiBcdFszNC4wNCwgLTExOC4yXVxuICogXTtcbiAqXG4gKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0W1s0NS41MSwgLTEyMi42OF0sXG4gKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICogXHQgWzM0LjA0LCAtMTE4LjJdXSxcbiAqIFx0W1s0MC43OCwgLTczLjkxXSxcbiAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAqIFx0IFszMi43NiwgLTk2LjcyXV1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuXHRcdG5vQ2xpcDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG5cdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3Nlc3RMYXllclBvaW50KHA6IFBvaW50KTogUG9pbnRcblx0Ly8gUmV0dXJucyB0aGUgcG9pbnQgY2xvc2VzdCB0byBgcGAgb24gdGhlIFBvbHlsaW5lLlxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRcdCAgICBwMSwgcDI7XG5cblx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcblx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cblx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcblx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWluUG9pbnQpIHtcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblBvaW50O1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cdFx0cmV0dXJuIExpbmVVdGlsLnBvbHlsaW5lQ2VudGVyKHRoaXMuX2RlZmF1bHRTaGFwZSgpLCB0aGlzLl9tYXAub3B0aW9ucy5jcnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz86IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IExpbmVVdGlsLmlzRmxhdChsYXRsbmdzKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzID0gcHhCb3VuZHM7XG5cdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdGlmICghdGhpcy5fcmF3UHhCb3VuZHMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHMoW1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChwKVxuXHRcdF0pO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRfcHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcykge1xuXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcblx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0ICAgIGksIHJpbmc7XG5cblx0XHRpZiAoZmxhdCkge1xuXHRcdFx0cmluZyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2Vcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG5cdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBMaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTGluZVV0aWwuc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcblx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcblx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdGlmIChMaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuXG4vLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG5Qb2x5bGluZS5fZmxhdCA9IExpbmVVdGlsLl9mbGF0O1xuIiwiaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCAqIGFzIFBvbHlVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvbHlVdGlsJztcblxuLypcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAYWthIEwuUG9seWdvblxuICogQGluaGVyaXRzIFBvbHlsaW5lXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gKlxuICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAqXG4gKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1s0MSwgLTExMS4wM10sWzQ1LCAtMTExLjA0XSxbNDUsIC0xMDQuMDVdLFs0MSwgLTEwNC4wNV1dXG4gKiAgIF1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFBvbHlnb24gPSBQb2x5bGluZS5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBQb2x5Z29uLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXHRcdHJldHVybiBQb2x5VXRpbC5wb2x5Z29uQ2VudGVyKHRoaXMuX2RlZmF1bHRTaGFwZSgpLCB0aGlzLl9tYXAub3B0aW9ucy5jcnMpO1xuXHR9LFxuXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gUG9seWxpbmUucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpLFxuXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG5cdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuXHRcdGlmIChsZW4gPj0gMiAmJiByZXN1bHRbMF0gaW5zdGFuY2VvZiBMYXRMbmcgJiYgcmVzdWx0WzBdLmVxdWFscyhyZXN1bHRbbGVuIC0gMV0pKSB7XG5cdFx0XHRyZXN1bHQucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0UG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG5cdFx0aWYgKExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcblx0XHR9XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSkgPyB0aGlzLl9sYXRsbmdzWzBdIDogdGhpcy5fbGF0bG5nc1swXVswXTtcblx0fSxcblxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcblx0XHRib3VuZHMgPSBuZXcgQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbGlwcGVkID0gUG9seVV0aWwuY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG5cdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBpbnNpZGUgPSBmYWxzZSxcblx0XHQgICAgcGFydCwgcDEsIHAyLCBpLCBqLCBrLCBsZW4sIGxlbjI7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0cDEgPSBwYXJ0W2pdO1xuXHRcdFx0XHRwMiA9IHBhcnRba107XG5cblx0XHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcblx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG5cdFx0cmV0dXJuIGluc2lkZSB8fCBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcblx0fVxuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb24obGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtNYXJrZXJ9IGZyb20gJy4vbWFya2VyL01hcmtlcic7XHJcbmltcG9ydCB7Q2lyY2xlfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGUnO1xyXG5pbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlTWFya2VyJztcclxuaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi92ZWN0b3IvUG9seWxpbmUnO1xyXG5pbXBvcnQge1BvbHlnb259IGZyb20gJy4vdmVjdG9yL1BvbHlnb24nO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuXHQgKiBXaGV0aGVyIGRlZmF1bHQgTWFya2VycyBmb3IgXCJQb2ludFwiIHR5cGUgRmVhdHVyZXMgaW5oZXJpdCBmcm9tIGdyb3VwIG9wdGlvbnMuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IFV0aWwuaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyPyApOiB0aGlzXHJcblx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG5cdC8vIElmIGBsYXllcmAgaXMgb21pdHRlZCwgdGhlIHN0eWxlIG9mIGFsbCBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBsYXllciBpcyByZXNldC5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbi8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbi8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcblx0ICAgIGxheWVycyA9IFtdLFxyXG5cdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdCAgICBfY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcsXHJcblx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRsYXllcnMucHVzaChfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnUG9seWdvbic6XHJcblx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGdlb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0aWYgKGdlb0xheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2goZ2VvTGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5mZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR2YXIgZmVhdHVyZUxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb21ldHJ5LmZlYXR1cmVzW2ldLCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChmZWF0dXJlTGF5ZXIpIHtcclxuXHRcdFx0XHRsYXllcnMucHVzaChmZWF0dXJlTGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRkZWZhdWx0OlxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXJGbiwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuXHRcdHBvaW50VG9MYXllckZuKGdlb2pzb24sIGxhdGxuZykgOlxyXG5cdFx0bmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJzSW5oZXJpdE9wdGlvbnMgJiYgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbi8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcblx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGF0bG5ncztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuXHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbiwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuXHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHQvLyBDaGVjayBmb3IgZmxhdCBhcnJheXMgcmVxdWlyZWQgdG8gZW5zdXJlIHVuYmFsYW5jZWQgYXJyYXlzIGFyZSBjb3JyZWN0bHkgY29udmVydGVkIGluIHJlY3Vyc2lvblxyXG5cdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBMaW5lVXRpbC5pc0ZsYXQobGF0bG5nc1tpXSkgPyAwIDogbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcblx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xyXG5cdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdLnNsaWNlKCkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvb3JkcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZlYXR1cmUobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG5cdFx0VXRpbC5leHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRhc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4vLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcblx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0cmV0dXJuIGdlb2pzb247XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0cHJvcGVydGllczoge30sXHJcblx0XHRnZW9tZXRyeTogZ2VvanNvblxyXG5cdH07XHJcbn1cclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ1BvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCksIHByZWNpc2lvbilcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbi8vIEBzZWN0aW9uIE90aGVyIG1ldGhvZHNcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuQ2lyY2xlLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5DaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcblBvbHlsaW5lLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIG11bHRpID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMSA6IDAsIGZhbHNlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuUG9seWdvbi5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBob2xlcyA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyksXHJcblx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRpZiAoIWhvbGVzKSB7XHJcblx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG5cdC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG5cdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgRmVhdHVyZUNvbGxlY3Rpb25gLCBgR2VvbWV0cnlDb2xsZWN0aW9uYCwgb3IgYE11bHRpUG9pbnRgKS5cclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcclxuXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdGpzb25zLnB1c2goanNvbi5nZW9tZXRyeSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG5cdFx0XHRcdFx0Ly8gU3F1YXNoIG5lc3RlZCBmZWF0dXJlIGNvbGxlY3Rpb25zXHJcblx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4vLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG5leHBvcnQgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xyXG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cHM6Ly9tYXBzLmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gKiBcdGltYWdlQm91bmRzID0gW1s0MC43MTIyMTYsIC03NC4yMjY1NV0sIFs0MC43NzM5NDEsIC03NC4xMjU0NF1dO1xyXG4gKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIEltYWdlT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGltYWdlIG92ZXJsYXkgd2lsbCBlbWl0IFttb3VzZSBldmVudHNdKCNpbnRlcmFjdGl2ZS1sYXllcikgd2hlbiBjbGlja2VkIG9yIGhvdmVyZWQuXHJcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGltYWdlLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSBvdmVybGF5IGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIG92ZXJsYXkgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yT3ZlcmxheVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuXHRcdC8vIFRoZSBleHBsaWNpdCBbekluZGV4XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleCkgb2YgdGhlIG92ZXJsYXkgbGF5ZXIuXHJcblx0XHR6SW5kZXg6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgaW1hZ2UuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG5cdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcblx0XHRcdHRoaXMuc2V0T3BhY2l0eShzdHlsZU9wdHMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gVXBkYXRlIHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgodmFsdWU6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gR2V0IHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcblx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgnaW1nJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpbWcsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoaW1nLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0aW1nLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcblx0XHRpbWcub25sb2FkID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHRcdGltZy5vbmVycm9yID0gVXRpbC5iaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56SW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBpbWcuc3JjO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9tYXAuX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHModGhpcy5fYm91bmRzLCBlLnpvb20sIGUuY2VudGVyKS5taW47XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgYm91bmRzID0gbmV3IEJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb3ZlcmxheU9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEBldmVudCBlcnJvcjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBmYWlscyB0byBsb2FkIGl0cyBpbWFnZVxyXG5cdFx0dGhpcy5maXJlKCdlcnJvcicpO1xyXG5cclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvck92ZXJsYXlVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBlcnJvclVybDtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBJbWFnZU92ZXJsYXkuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzLmdldENlbnRlcigpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbmV4cG9ydCB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0ltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFZpZGVvT3ZlcmxheVxyXG4gKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAqXHJcbiAqIEEgdmlkZW8gb3ZlcmxheSB1c2VzIHRoZSBbYDx2aWRlbz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8pXHJcbiAqIEhUTUw1IGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB2aWRlb1VybCA9ICdodHRwczovL3d3dy5tYXBib3guY29tL2JpdGVzLzAwMTg4L3BhdHJpY2lhX25hc2Eud2VibScsXHJcbiAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICogTC52aWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFZpZGVvT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkZWQuXHJcblx0XHQvLyBPbiBzb21lIGJyb3dzZXJzIGF1dG9wbGF5IHdpbGwgb25seSB3b3JrIHdpdGggYG11dGVkOiB0cnVlYFxyXG5cdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyB3aGVuIHBsYXllZC5cclxuXHRcdGxvb3A6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQXNwZWN0UmF0aW86IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIHNhdmUgYXNwZWN0IHJhdGlvIGFmdGVyIHRoZSBwcm9qZWN0aW9uLlxyXG5cdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gU2VlIFticm93c2VyIGNvbXBhdGliaWxpdHldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0KVxyXG5cdFx0a2VlcEFzcGVjdFJhdGlvOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbXV0ZWQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIG9uIG11dGUgd2hlbiBsb2FkZWQuXHJcblx0XHRtdXRlZDogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwbGF5c0lubGluZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIE1vYmlsZSBicm93c2VycyB3aWxsIHBsYXkgdGhlIHZpZGVvIHJpZ2h0IHdoZXJlIGl0IGlzIGluc3RlYWQgb2Ygb3BlbiBpdCB1cCBpbiBmdWxsc2NyZWVuIG1vZGUuXHJcblx0XHRwbGF5c0lubGluZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ1ZJREVPJztcclxuXHRcdHZhciB2aWQgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IERvbVV0aWwuY3JlYXRlKCd2aWRlbycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModmlkLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKHZpZCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHR2aWQub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdHZpZC5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZGVvIGhhcyBmaW5pc2hlZCBsb2FkaW5nIHRoZSBmaXJzdCBmcmFtZVxyXG5cdFx0dmlkLm9ubG9hZGVkZGF0YSA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblxyXG5cdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG5cdFx0XHR2YXIgc291cmNlRWxlbWVudHMgPSB2aWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xyXG5cdFx0XHR2YXIgc291cmNlcyA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHNvdXJjZUVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZUVsZW1lbnRzW2pdLnNyYyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3VybCA9IChzb3VyY2VFbGVtZW50cy5sZW5ndGggPiAwKSA/IHNvdXJjZXMgOiBbdmlkLnNyY107XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIVV0aWwuaXNBcnJheSh0aGlzLl91cmwpKSB7IHRoaXMuX3VybCA9IFt0aGlzLl91cmxdOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMua2VlcEFzcGVjdFJhdGlvICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2aWQuc3R5bGUsICdvYmplY3RGaXQnKSkge1xyXG5cdFx0XHR2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnO1xyXG5cdFx0fVxyXG5cdFx0dmlkLmF1dG9wbGF5ID0gISF0aGlzLm9wdGlvbnMuYXV0b3BsYXk7XHJcblx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XHJcblx0XHR2aWQubXV0ZWQgPSAhIXRoaXMub3B0aW9ucy5tdXRlZDtcclxuXHRcdHZpZC5wbGF5c0lubGluZSA9ICEhdGhpcy5vcHRpb25zLnBsYXlzSW5saW5lO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIHNvdXJjZSA9IERvbVV0aWwuY3JlYXRlKCdzb3VyY2UnKTtcclxuXHRcdFx0c291cmNlLnNyYyA9IHRoaXMuX3VybFtpXTtcclxuXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTFZpZGVvRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MVmlkZW9FbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnZpZGVvT3ZlcmxheSh2aWRlbzogU3RyaW5nfEFycmF5fEhUTUxWaWRlb0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogVmlkZW9PdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSB2aWRlbyAob3IgYXJyYXkgb2YgVVJMcywgb3IgZXZlbiBhIHZpZGVvIGVsZW1lbnQpIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFNWR092ZXJsYXlcbiAqIEBha2EgTC5TVkdPdmVybGF5XG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XG4gKlxuICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAqXG4gKiBBbiBTVkcgb3ZlcmxheSB1c2VzIHRoZSBbYDxzdmc+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3ZnKSBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICogc3ZnRWxlbWVudC5pbm5lckhUTUwgPSAnPHJlY3Qgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMDBcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOnJlZFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMTIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOiMwMDEzZmZcIi8+JztcbiAqIHZhciBzdmdFbGVtZW50Qm91bmRzID0gWyBbIDMyLCAtMTMwIF0sIFsgMTMsIC0xMDAgXSBdO1xuICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWR092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cblx0XHRlbC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdGVsLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXHR9XG5cblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIGFuIFNWRyBlbGVtZW50IGFuZCB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuLy8gQSB2aWV3Qm94IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvbiB0aGUgU1ZHIGVsZW1lbnQgdG8gem9vbSBpbiBhbmQgb3V0IHByb3Blcmx5LlxuXG5leHBvcnQgZnVuY3Rpb24gc3ZnT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU1ZHT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZywgTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERpdk92ZXJsYXlcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAqIEJhc2UgbW9kZWwgZm9yIEwuUG9wdXAgYW5kIEwuVG9vbHRpcC4gSW5oZXJpdCBmcm9tIGl0IGZvciBjdXN0b20gb3ZlcmxheXMgbGlrZSBwbHVnaW5zLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5leHBvcnQgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiB0cnVlLCB0aGUgcG9wdXAvdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgbW91c2UgZXZlbnRzLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXHJcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBvdmVybGF5IHBvc2l0aW9uLlxyXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIG92ZXJsYXkuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24gPSAnJ1xyXG5cdFx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBvdmVybGF5IHdoaWxlIGluaXRpYWxpemluZy4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlXHJcblx0XHQvLyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuXHRcdGNvbnRlbnQ6ICcnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0aWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMgaW5zdGFuY2VvZiBMYXRMbmcgfHwgVXRpbC5pc0FycmF5KG9wdGlvbnMpKSkge1xyXG5cdFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhvcHRpb25zKTtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIHNvdXJjZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY29udGVudCkge1xyXG5cdFx0XHR0aGlzLl9jb250ZW50ID0gdGhpcy5vcHRpb25zLmNvbnRlbnQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgb3ZlcmxheSB0byB0aGUgbWFwLlxyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAvYC5vcGVuVG9vbHRpcCh0b29sdGlwKWAuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7XHJcblx0XHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2UoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgb3ZlcmxheS5cclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLmNsb3NlUG9wdXAocG9wdXApYC9gLmNsb3NlVG9vbHRpcCh0b29sdGlwKWBcclxuXHQvLyBhbmQgYGxheWVyLmNsb3NlUG9wdXAoKWAvYC5jbG9zZVRvb2x0aXAoKWAuXHJcblx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b2dnbGUobGF5ZXI/OiBMYXllcik6IHRoaXNcclxuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIG92ZXJsYXkgYm91bmQgdG8gbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG5cdC8vIEFyZ3VtZW50IG1heSBiZSBvbWl0dGVkIG9ubHkgZm9yIG92ZXJsYXkgYm91bmQgdG8gbGF5ZXIuXHJcblx0Ly8gQWx0ZXJuYXRpdmUgdG8gYGxheWVyLnRvZ2dsZVBvcHVwKClgL2AudG9nZ2xlVG9vbHRpcCgpYC5cclxuXHR0b2dnbGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxheWVyID0gdGhpcy5fc291cmNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3ByZXBhcmVPcGVuKCk7XHJcblxyXG5cdFx0XHQvLyBvcGVuIHRoZSBvdmVybGF5IG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5vcGVuT24obGF5ZXIuX21hcCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKERvbVV0aWwucmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHRoZSBvdmVybGF5LlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIG92ZXJsYXkgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBvdmVybGF5LiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cclxuXHQvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGNvbnRhaW5lciBvZiB0aGUgb3ZlcmxheS5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXHJcblx0Ly8gVXBkYXRlcyB0aGUgb3ZlcmxheSBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBvdmVybGF5IGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBvdmVybGF5IGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IGluIGZyb250IG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gcHJlcGFyZSBib3VuZCBvdmVybGF5IHRvIG9wZW46IHVwZGF0ZSBsYXRsbmcgcG9zIC8gY29udGVudCBzb3VyY2UgKGZvciBGZWF0dXJlR3JvdXApXHJcblx0X3ByZXBhcmVPcGVuOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgc291cmNlID0gdGhpcy5fc291cmNlO1xyXG5cdFx0aWYgKCFzb3VyY2UuX21hcCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRpZiAoc291cmNlIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XHJcblx0XHRcdHNvdXJjZSA9IG51bGw7XHJcblx0XHRcdHZhciBsYXllcnMgPSB0aGlzLl9zb3VyY2UuX2xheWVycztcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gbGF5ZXJzKSB7XHJcblx0XHRcdFx0aWYgKGxheWVyc1tpZF0uX21hcCkge1xyXG5cdFx0XHRcdFx0c291cmNlID0gbGF5ZXJzW2lkXTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIXNvdXJjZSkgeyByZXR1cm4gZmFsc2U7IH0gLy8gVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIuXHJcblxyXG5cdFx0XHQvLyBzZXQgb3ZlcmxheSBzb3VyY2UgdG8gdGhpcyBsYXllclxyXG5cdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsYXRsbmcpIHtcclxuXHRcdFx0aWYgKHNvdXJjZS5nZXRDZW50ZXIpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0Q2VudGVyKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoc291cmNlLmdldExhdExuZykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRMYXRMbmcoKTtcclxuXHRcdFx0fSBlbHNlIGlmIChzb3VyY2UuZ2V0Qm91bmRzKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLicpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLnNldExhdExuZyhsYXRsbmcpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGV0Yy4uLilcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcblx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuXHRcdC8vIEBzZWN0aW9uIERpdk92ZXJsYXkgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgY29udGVudHVwZGF0ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkgaXMgdXBkYXRlZFxyXG5cdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55LFxyXG5cdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgb3ZlcmxheSBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIG92ZXJsYXkgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5NYXAuaW5jbHVkZSh7XHJcblx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBjb250ZW50LCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBvdmVybGF5ID0gY29udGVudDtcclxuXHRcdGlmICghKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpKSB7XHJcblx0XHRcdG92ZXJsYXkgPSBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMpLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRpZiAobGF0bG5nKSB7XHJcblx0XHRcdG92ZXJsYXkuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3ZlcmxheTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbkxheWVyLmluY2x1ZGUoe1xyXG5cdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgb2xkLCBjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcblx0XHRpZiAob3ZlcmxheSBpbnN0YW5jZW9mIE92ZXJsYXlDbGFzcykge1xyXG5cdFx0XHRVdGlsLnNldE9wdGlvbnMob3ZlcmxheSwgb3B0aW9ucyk7XHJcblx0XHRcdG92ZXJsYXkuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvdmVybGF5ID0gKG9sZCAmJiAhb3B0aW9ucykgPyBvbGQgOiBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMsIHRoaXMpO1xyXG5cdFx0XHRvdmVybGF5LnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3ZlcmxheTtcclxuXHR9XHJcbn0pO1xyXG4iLCJpbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi92ZWN0b3IvUGF0aCc7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9wdXBcclxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcclxuICogQGFrYSBMLlBvcHVwXHJcbiAqIFVzZWQgdG8gb3BlbiBwb3B1cHMgaW4gY2VydGFpbiBwbGFjZXMgb2YgdGhlIG1hcC4gVXNlIFtNYXAub3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgdG9cclxuICogb3BlbiBwb3B1cHMgd2hpbGUgbWFraW5nIHN1cmUgdGhhdCBvbmx5IG9uZSBwb3B1cCBpcyBvcGVuIGF0IG9uZSB0aW1lXHJcbiAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgcG9wdXAgdG8gbWFya2VyIGNsaWNrIGFuZCB0aGVuIG9wZW4gaXQsIGl0J3MgcmVhbGx5IGVhc3k6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcmtlci5iaW5kUG9wdXAocG9wdXBDb250ZW50KS5vcGVuUG9wdXAoKTtcclxuICogYGBgXHJcbiAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gKlxyXG4gKiBBIHBvcHVwIGNhbiBiZSBhbHNvIHN0YW5kYWxvbmU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb3B1cCA9IEwucG9wdXAoKVxyXG4gKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxyXG4gKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICogXHQub3Blbk9uKG1hcCk7XHJcbiAqIGBgYFxyXG4gKiBvclxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKGxhdGxuZywge2NvbnRlbnQ6ICc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICogXHQub3Blbk9uKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbmV4cG9ydCB2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBQb3B1cCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdwb3B1cFBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDcpXHJcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBwb3B1cCBwb3NpdGlvbi5cclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0Ly8gVGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGNhbiBiZSBzdHlsZWQgdXNpbmcgdGhlXHJcblx0XHQvLyBgbGVhZmxldC1wb3B1cC1zY3JvbGxlZGAgQ1NTIGNsYXNzIHNlbGVjdG9yLlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG5cdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxyXG5cdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuXHRcdC8vIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRoZSBtYXAncyBbYGNsb3NlUG9wdXBPbkNsaWNrYF0oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uLlxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcCA9IGFyZ3VtZW50cy5sZW5ndGggPyBtYXAgOiB0aGlzLl9zb3VyY2UuX21hcDsgLy8gZXhwZXJpbWVudGFsLCBub3QgdGhlIHBhcnQgb2YgcHVibGljIGFwaVxyXG5cclxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHRtYXAucmVtb3ZlTGF5ZXIobWFwLl9wb3B1cCk7XHJcblx0XHR9XHJcblx0XHRtYXAuX3BvcHVwID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gRGl2T3ZlcmxheS5wcm90b3R5cGUub3Blbk9uLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcclxuXHRcdFx0Ly8gYWdhaW4gdGhlIGxheWVyLCBzbyBwcmV2ZW50IHRoZSBtYXAgdG8gcmVvcGVuIGl0LlxyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGluIHRoZSBtYXAgaXMgY2xvc2VkXHJcblx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgIT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLmNsb3NlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLFxyXG5cdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG5cdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX3RpcCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IERvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7IC8vIG92ZXJyaWRlcyB0aGUgaW1wbGljaXQgcm9sZT1saW5rIG9mIDxhPiBlbGVtZW50cyAjNzM5OVxyXG5cdFx0XHRjbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnQ2xvc2UgcG9wdXAnKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiMyMTU7PC9zcGFuPic7XHJcblxyXG5cdFx0XHREb21FdmVudC5vbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcblx0XHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZXYpO1xyXG5cdFx0XHRcdHRoaXMuY2xvc2UoKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAodGhpcy5fbWFwLl9wYW5BbmltKSB7IHRoaXMuX21hcC5fcGFuQW5pbS5zdG9wKCk7IH1cclxuXHJcblx0XHQvLyBXZSBjYW4gZW5kbGVzc2x5IHJlY3Vyc2UgaWYga2VlcEluVmlldyBpcyBzZXQgYW5kIHRoZSB2aWV3IHJlc2V0cy5cclxuXHRcdC8vIExldCdzIGd1YXJkIGFnYWluc3QgdGhhdCBieSBleGl0aW5nIGVhcmx5IGlmIHdlJ3JlIHJlc3BvbmRpbmcgdG8gb3VyIG93biBhdXRvcGFuLlxyXG5cdFx0aWYgKHRoaXMuX2F1dG9wYW5uaW5nKSB7XHJcblx0XHRcdHRoaXMuX2F1dG9wYW5uaW5nID0gZmFsc2U7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KERvbVV0aWwuZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBQb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRsYXllclBvcy5fYWRkKERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdC8vIFRyYWNrIHRoYXQgd2UncmUgYXV0b3Bhbm5pbmcsIGFzIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZS1yYW4gb24gbW92ZWVuZFxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0XHR0aGlzLl9hdXRvcGFubmluZyA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbi8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9wdXAobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBgbGF0bG5nYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuIGFuZCBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbi5cclxuZXhwb3J0IHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5faW5pdE92ZXJsYXkoUG9wdXAsIHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpXHJcblx0XHQgIC5vcGVuT24odGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRwb3B1cCA9IGFyZ3VtZW50cy5sZW5ndGggPyBwb3B1cCA6IHRoaXMuX3BvcHVwO1xyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHBvcHVwLmNsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMYXllclxyXG4gKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICpcclxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xyXG4gKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAqL1xyXG5cclxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG5MYXllci5pbmNsdWRlKHtcclxuXHJcblx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fcG9wdXAgPSB0aGlzLl9pbml0T3ZlcmxheShQb3B1cCwgdGhpcy5fcG9wdXAsIGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bmJpbmRQb3B1cCgpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kUG9wdXBgLlxyXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBib3VuZCBwb3B1cCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkpIHtcclxuXHRcdFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX3ByZXBhcmVPcGVuKGxhdGxuZyB8fCB0aGlzLl9sYXRsbmcpKSB7XHJcblx0XHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgb24gdGhlIG1hcFxyXG5cdFx0XHRcdHRoaXMuX3BvcHVwLm9wZW5Pbih0aGlzLl9tYXApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b2dnbGVQb3B1cCgpOiB0aGlzXHJcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnRvZ2dsZSh0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8ICF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcHJldmVudCBtYXAgY2xpY2tcclxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XHJcblx0XHRpZiAodGhpcy5fcG9wdXAuX3NvdXJjZSA9PT0gdGFyZ2V0ICYmICEodGFyZ2V0IGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0Ly8gdHJlYXQgaXQgbGlrZSBhIG1hcmtlciBhbmQgZmlndXJlIG91dFxyXG5cdFx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcblx0XHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApKSB7XHJcblx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXRsbmcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSB0YXJnZXQ7XHJcblx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG4iLCJpbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcblxuLypcbiAqIEBjbGFzcyBUb29sdGlwXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICogQGFrYSBMLlRvb2x0aXBcbiAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgdG9vbHRpcCB0byBtYXJrZXI6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kVG9vbHRpcGAgbWV0aG9kLlxuICpcbiAqIEEgdG9vbHRpcCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgdG9vbHRpcCA9IEwudG9vbHRpcCgpXG4gKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxuICogXHQuc2V0Q29udGVudCgnSGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgdG9vbHRpcC4nKVxuICogXHQuYWRkVG8obWFwKTtcbiAqIGBgYFxuICogb3JcbiAqIGBgYGpzXG4gKiB2YXIgdG9vbHRpcCA9IEwudG9vbHRpcChsYXRsbmcsIHtjb250ZW50OiAnSGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgdG9vbHRpcC4nfSlcbiAqIFx0LmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKlxuICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAqL1xuXG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuZXhwb3J0IHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG5cdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuXHRcdG9mZnNldDogWzAsIDBdLFxuXG5cdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG5cdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbGx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcblx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG5cdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cblx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cblx0XHRzdGlja3k6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0dGhpcy5hZGRFdmVudFBhcmVudCh0aGlzLl9zb3VyY2UpO1xuXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcblxuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2xlYWZsZXQtdG9vbHRpcC0nICsgVXRpbC5zdGFtcCh0aGlzKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge30sXG5cblx0X3NldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG5cdFx0dmFyIHN1YlgsIHN1YlksXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG5cdFx0ICAgIHRvb2x0aXBQb2ludCA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChwb3MpLFxuXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG5cdFx0ICAgIHRvb2x0aXBIZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuXHRcdGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0O1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gMDtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG5cdFx0XHRzdWJYID0gMDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSBpZiAodG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0c3ViWCA9IDA7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0Jztcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggKyAob2Zmc2V0LnggKyBhbmNob3IueCkgKiAyO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH1cblxuXHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHN1YlgsIHN1YlksIHRydWUpKS5hZGQob2Zmc2V0KS5hZGQoYW5jaG9yKTtcblxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXRvcCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBwb3MpO1xuXHR9LFxuXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdH1cblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBgVG9vbHRpcGAgb2JqZWN0IGdpdmVuIGBsYXRsbmdgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXG5leHBvcnQgdmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKVxuXHRcdCAgLm9wZW5Pbih0aGlzKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHR0b29sdGlwLmNsb3NlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gKiBgYGBcbiAqL1xuXG4vLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5pc1Rvb2x0aXBPcGVuKCkpIHtcblx0XHRcdHRoaXMudW5iaW5kVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Rvb2x0aXAgPSB0aGlzLl9pbml0T3ZlcmxheShUb29sdGlwLCB0aGlzLl90b29sdGlwLCBjb250ZW50LCBvcHRpb25zKTtcblx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuXHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG5cdHVuYmluZFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG5cdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdGlmICghcmVtb3ZlICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcblx0XHQgICAgZXZlbnRzID0ge1xuXHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlVG9vbHRpcCxcblx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG5cdFx0ICAgIH07XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHR0aGlzLl9hZGRGb2N1c0xpc3RlbmVycygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG5cdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG5cdFx0fVxuXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG5cdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gdGhpcztcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9wcmVwYXJlT3BlbihsYXRsbmcpKSB7XG5cdFx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0XHR0aGlzLl90b29sdGlwLm9wZW5Pbih0aGlzLl9tYXApO1xuXG5cdFx0XHRcdGlmICh0aGlzLmdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHR0aGlzLl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyKHRoaXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZWFjaExheWVyKSB7XG5cdFx0XHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllciwgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuY2xvc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudG9nZ2xlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fSxcblxuXHRfYWRkRm9jdXNMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG5cdFx0XHR0aGlzLl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIodGhpcyk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuXHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGVsID0gdHlwZW9mIGxheWVyLmdldEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgbGF5ZXIuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbCkge1xuXHRcdFx0RG9tRXZlbnQub24oZWwsICdmb2N1cycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0RG9tRXZlbnQub24oZWwsICdibHVyJywgdGhpcy5jbG9zZVRvb2x0aXAsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGVsID0gdHlwZW9mIGxheWVyLmdldEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgbGF5ZXIuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLmlkKTtcblx0XHR9XG5cdH0sXG5cblxuXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbWFwIGlzIG1vdmluZywgd2Ugd2lsbCBzaG93IHRoZSB0b29sdGlwIGFmdGVyIGl0J3MgZG9uZS5cblx0XHRpZiAodGhpcy5fbWFwLmRyYWdnaW5nICYmIHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSAmJiAhdGhpcy5fb3Blbk9uY2VGbGFnKSB7XG5cdFx0XHR0aGlzLl9vcGVuT25jZUZsYWcgPSB0cnVlO1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0dGhpcy5fbWFwLm9uY2UoJ21vdmVlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoYXQuX29wZW5PbmNlRmxhZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGF0Ll9vcGVuVG9vbHRpcChlKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHR0aGlzLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdH0sXG5cblx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdH1cblx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtlbXB0eX0gZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxuZXhwb3J0IHZhciBEaXZJY29uID0gSWNvbi5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cblx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG5cdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmd8SFRNTEVsZW1lbnQgPSAnJ1xuXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuIEFsdGVybmF0aXZlbHksXG5cdFx0Ly8gYW4gaW5zdGFuY2Ugb2YgYEhUTUxFbGVtZW50YC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdFx0XHRlbXB0eShkaXYpO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKG9wdGlvbnMuaHRtbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdHZhciBiZ1BvcyA9IHBvaW50KG9wdGlvbnMuYmdQb3MpO1xuXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuXHRcdHJldHVybiBkaXY7XG5cdH0sXG5cblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5leHBvcnQge2ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XG5JY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcbmV4cG9ydCB7SWNvbn07XG5cbmV4cG9ydCB7RGl2SWNvbiwgZGl2SWNvbn0gZnJvbSAnLi9EaXZJY29uJztcbmV4cG9ydCB7TWFya2VyLCBtYXJrZXJ9IGZyb20gJy4vTWFya2VyJztcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG5cdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cblx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0dXBkYXRlV2hlbklkbGU6IEJyb3dzZXIubW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG5cdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuXHRcdHRoaXMuX3RpbGVzID0ge307XG5cblx0XHR0aGlzLl9yZXNldFZpZXcoKTsgLy8gaW1wbGljaXQgX3VwZGF0ZSgpIGNhbGxcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cblx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcblx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHR2YXIgdGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xuXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG5cdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuXHRcdFx0XHR0aGlzLl9vbk1vdmUgPSBVdGlsLnRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBgR3JpZExheWVyYC5cblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQG1ldGhvZCBnZXRUaWxlU2l6ZTogUG9pbnRcblx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG5cdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG5cdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBQb2ludCA/IHMgOiBuZXcgUG9pbnQocywgcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcblx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cblx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cblx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcblx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkgeyByZXR1cm47IH1cblxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdHZhciBub3cgPSArbmV3IERhdGUoKSxcblx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG5cdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuXHRcdFx0dmFyIGZhZGUgPSBNYXRoLm1pbigxLCAobm93IC0gdGlsZS5sb2FkZWQpIC8gMjAwKTtcblxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG5cdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR3aWxsUHJ1bmUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX29uT3BhcXVlVGlsZSh0aWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuXHRcdGlmIChuZXh0RnJhbWUpIHtcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk9wYXF1ZVRpbGU6IFV0aWwuZmFsc2VGbixcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXIgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuXHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR6ID0gTnVtYmVyKHopO1xuXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cblx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRVdGlsLmZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9vblVwZGF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uUmVtb3ZlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25DcmVhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKE51bWJlcih6KSk7XG5cdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdH1cblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcblx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcblx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcblx0XHQgICAgejIgPSB6IC0gMSxcblx0XHQgICAgY29vcmRzMiA9IG5ldyBQb2ludCgreDIsICt5Mik7XG5cdFx0Y29vcmRzMi56ID0gK3oyO1xuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcblx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHogKyAxO1xuXG5cdFx0XHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKSxcblx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6ICsgMSA8IG1heFpvb20pIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihpLCBqLCB6ICsgMSwgbWF4Wm9vbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcblx0XHR0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSwgYW5pbWF0aW5nLCBhbmltYXRpbmcpO1xuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9zZXRWaWV3KGUuY2VudGVyLCBlLnpvb20sIHRydWUsIGUubm9VcGRhdGUpO1xuXHR9LFxuXG5cdF9jbGFtcFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1pbk5hdGl2ZVpvb20gJiYgem9vbSA8IG9wdGlvbnMubWluTmF0aXZlWm9vbSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluTmF0aXZlWm9vbTtcblx0XHR9XG5cblx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1heE5hdGl2ZVpvb20gJiYgb3B0aW9ucy5tYXhOYXRpdmVab29tIDwgem9vbSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gem9vbTtcblx0fSxcblxuXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcblx0XHR2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRpbGVab29tKTtcblx0XHR9XG5cblx0XHR2YXIgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuXG5cdFx0aWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcblxuXHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblxuXHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG5cdFx0XHR0aGlzLl9yZXNldEdyaWQoKTtcblxuXHRcdFx0aWYgKHRpbGVab29tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghbm9QcnVuZSkge1xuXHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZsYWcgdG8gcHJldmVudCBfdXBkYXRlT3BhY2l0eSBmcm9tIHBydW5pbmcgdGlsZXMgZHVyaW5nXG5cdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcblx0XHRcdHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybXM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sIGNlbnRlciwgem9vbSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbiAobGV2ZWwsIGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgbGV2ZWwuem9vbSksXG5cdFx0ICAgIHRyYW5zbGF0ZSA9IGxldmVsLm9yaWdpbi5tdWx0aXBseUJ5KHNjYWxlKVxuXHRcdCAgICAgICAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24obGV2ZWwuZWwsIHRyYW5zbGF0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldEdyaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnMsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIHRpbGVab29tID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHRoaXMuX2dsb2JhbFRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoYm91bmRzKTtcblx0XHR9XG5cblx0XHR0aGlzLl93cmFwWCA9IGNycy53cmFwTG5nICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzBdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0XHR0aGlzLl93cmFwWSA9IGNycy53cmFwTGF0ICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0fSxcblxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2dldFRpbGVkUGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBtYXBab29tID0gbWFwLl9hbmltYXRpbmdab29tID8gTWF0aC5tYXgobWFwLl9hbmltYXRlVG9ab29tLCBtYXAuZ2V0Wm9vbSgpKSA6IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNjYWxlID0gbWFwLmdldFpvb21TY2FsZShtYXBab29tLCB0aGlzLl90aWxlWm9vbSksXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcblx0XHQgICAgaGFsZlNpemUgPSBtYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KHNjYWxlICogMik7XG5cblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuXHR9LFxuXG5cdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cblx0XHR2YXIgem9vbSA9IHRoaXMuX2NsYW1wWm9vbShtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cblx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cdC8vIGlmIG91dCBvZiBtaW56b29tL21heHpvb21cblxuXHRcdHZhciBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcblx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG5cdFx0ICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG5cdFx0ICAgIHF1ZXVlID0gW10sXG5cdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuXHRcdCAgICBub1BydW5lUmFuZ2UgPSBuZXcgQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG5cdFx0Ly8gU2FuaXR5IGNoZWNrOiBwYW5pYyBpZiB0aGUgdGlsZSByYW5nZSBjb250YWlucyBJbmZpbml0eSBzb21ld2hlcmUuXG5cdFx0aWYgKCEoaXNGaW5pdGUodGlsZVJhbmdlLm1pbi54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueSkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC55KSkpIHsgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXMnKTsgfVxuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKSkge1xuXHRcdFx0XHR0aGlzLl90aWxlc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBfdXBkYXRlIGp1c3QgbG9hZHMgbW9yZSB0aWxlcy4gSWYgdGhlIHRpbGUgem9vbSBsZXZlbCBkaWZmZXJzIHRvbyBtdWNoXG5cdFx0Ly8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cblx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuXHRcdC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuXHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcblx0XHRcdGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcblx0XHRcdFx0aWYgKHRpbGUpIHtcblx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG5cdFx0fSk7XG5cblx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG5cdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG5cdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcblx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG5cdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdHJldHVybiBsYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG5cdH0sXG5cblx0X2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG5cdH0sXG5cblx0X3RpbGVDb29yZHNUb053U2U6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcblx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcblx0XHQgICAgc2UgPSBtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KTtcblx0XHRyZXR1cm4gW253LCBzZV07XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBpdHMgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGJwID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxuXHRcdCAgICBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKGJwWzBdLCBicFsxXSk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKGJvdW5kcyk7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcblx0XHQgICAgY29vcmRzID0gbmV3IFBvaW50KCtrWzBdLCAra1sxXSk7XG5cdFx0Y29vcmRzLnogPSAra1syXTtcblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdERvbVV0aWwucmVtb3ZlKHRpbGUuZWwpO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcblx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXG5cdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcblx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcblx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlcnIpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKEJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyBVdGlsLndyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuXHRcdFx0dGhpcy5fd3JhcFkgPyBVdGlsLndyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBncmlkTGF5ZXIob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7R3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLnRpbGVMYXllcignaHR0cHM6Ly90aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInLCBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ30pLmFkZFRvKG1hcCk7XG4gKiBgYGBcclxuICpcclxuICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICpcclxuICogYGBgXHJcbiAqICdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZWZlcnJlclBvbGljeTogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLlxyXG5cdFx0Ly8gVGhpcyBtYXkgYmUgbmVlZGVkIGlmIHlvdXIgbWFwJ3MgcmVuZGVyaW5nIGNvbnRleHQgaGFzIGEgc3RyaWN0IGRlZmF1bHQgYnV0IHlvdXIgdGlsZSBwcm92aWRlciBleHBlY3RzIGEgdmFsaWQgcmVmZXJyZXJcclxuXHRcdC8vIChlLmcuIHRvIHZhbGlkYXRlIGFuIEFQSSB0b2tlbikuXHJcblx0XHQvLyBSZWZlciB0byBbSFRNTEltYWdlRWxlbWVudC5yZWZlcnJlclBvbGljeV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQvcmVmZXJyZXJQb2xpY3kpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0cmVmZXJyZXJQb2xpY3k6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHRcdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSAtIDEpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG5cdFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy5taW5ab29tICsgMSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9IGVsc2UgaWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdC8vIG1ha2Ugc3VyZSBtYXhab29tIGlzIGd0ZSBtaW5ab29tXHJcblx0XHRcdG9wdGlvbnMubWF4Wm9vbSA9IE1hdGgubWF4KG9wdGlvbnMubWluWm9vbSwgb3B0aW9ucy5tYXhab29tKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIG1ha2Ugc3VyZSBtaW5ab29tIGlzIGx0ZSBtYXhab29tXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy5taW5ab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuXHQvLyBJZiB0aGUgVVJMIGRvZXMgbm90IGNoYW5nZSwgdGhlIGxheWVyIHdpbGwgbm90IGJlIHJlZHJhd24gdW5sZXNzXHJcblx0Ly8gdGhlIG5vUmVkcmF3IHBhcmFtZXRlciBpcyBzZXQgdG8gZmFsc2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0aWYgKHRoaXMuX3VybCA9PT0gdXJsICYmIG5vUmVkcmF3ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0bm9SZWRyYXcgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG5cdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG5cdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcblx0XHREb21FdmVudC5vbih0aWxlLCAnbG9hZCcsIFV0aWwuYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblx0XHREb21FdmVudC5vbih0aWxlLCAnZXJyb3InLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciB0aGlzIG5ldyBvcHRpb24gd2UgZm9sbG93IHRoZSBkb2N1bWVudGVkIGJlaGF2aW9yXHJcblx0XHQvLyBtb3JlIGNsb3NlbHkgYnkgb25seSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSB3aGVuIHN0cmluZ1xyXG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3kgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHRpbGUucmVmZXJyZXJQb2xpY3kgPSB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3k7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVGhlIGFsdCBhdHRyaWJ1dGUgaXMgc2V0IHRvIHRoZSBlbXB0eSBzdHJpbmcsXHJcblx0XHQvLyBhbGxvd2luZyBzY3JlZW4gcmVhZGVycyB0byBpZ25vcmUgdGhlIGRlY29yYXRpdmUgaW1hZ2UgdGlsZXMuXHJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvV0FJL3R1dG9yaWFscy9pbWFnZXMvZGVjb3JhdGl2ZS9cclxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sLWFyaWEvI2VsLWltZy1lbXB0eS1hbHRcclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IEJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIFV0aWwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRpbGUuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0XHRkb25lKGUsIHRpbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuXHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbSxcclxuXHRcdHpvb21SZXZlcnNlID0gdGhpcy5vcHRpb25zLnpvb21SZXZlcnNlLFxyXG5cdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdGlmICh6b29tUmV2ZXJzZSkge1xyXG5cdFx0XHR6b29tID0gbWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHpvb20gKyB6b29tT2Zmc2V0O1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCB0aWxlO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0XHR0aWxlLnNyYyA9IFV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHRcdFx0XHRcdHZhciBjb29yZHMgPSB0aGlzLl90aWxlc1tpXS5jb29yZHM7XHJcblx0XHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aWxlKTtcclxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuXHRcdFx0XHRcdC8vIEBldmVudCB0aWxlYWJvcnQ6IFRpbGVFdmVudFxyXG5cdFx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgd2FzIGxvYWRpbmcgYnV0IGlzIG5vdyBub3Qgd2FudGVkLlxyXG5cdFx0XHRcdFx0dGhpcy5maXJlKCd0aWxlYWJvcnQnLCB7XHJcblx0XHRcdFx0XHRcdHRpbGU6IHRpbGUsXHJcblx0XHRcdFx0XHRcdGNvb3JkczogY29vcmRzXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xyXG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIENhbmNlbHMgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0cyBhc3NvY2lhdGVkIHdpdGggdGhlIHRpbGVcclxuXHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBVdGlsLmVtcHR5SW1hZ2VVcmwpO1xyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gVXRpbC5lbXB0eUltYWdlVXJsKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge1RpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xyXG5pbXBvcnQge2V4dGVuZCwgc2V0T3B0aW9ucywgZ2V0UGFyYW1TdHJpbmd9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7RVBTRzQzMjZ9IGZyb20gJy4uLy4uL2dlby9jcnMvQ1JTLkVQU0c0MzI2JztcclxuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllci5XTVNcclxuICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG5leHJhZCA9IEwudGlsZUxheWVyLndtcyhcImh0dHA6Ly9tZXNvbmV0LmFncm9uLmlhc3RhdGUuZWR1L2NnaS1iaW4vd21zL25leHJhZC9uMHIuY2dpXCIsIHtcclxuICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICogXHR0cmFuc3BhcmVudDogdHJ1ZSxcclxuICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVGlsZUxheWVyV01TID0gVGlsZUxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuXHQvLyBJZiBhbnkgY3VzdG9tIG9wdGlvbnMgbm90IGRvY3VtZW50ZWQgaGVyZSBhcmUgdXNlZCwgdGhleSB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcblx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cHM6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG5cdFx0bGF5ZXJzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcblx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuXHRcdHZlcnNpb246ICcxLjEuMSdcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG5cdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcblx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHR2YXIgd21zUGFyYW1zID0gZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcclxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcclxuXHRcdHdtc1BhcmFtcy53aWR0aCA9IHRpbGVTaXplLnggKiByZWFsUmV0aW5hO1xyXG5cdFx0d21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplLnkgKiByZWFsUmV0aW5hO1xyXG5cclxuXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcblx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuXHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XHJcblxyXG5cdFx0VGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxyXG5cdFx0ICAgIGNycyA9IHRoaXMuX2NycyxcclxuXHRcdCAgICBib3VuZHMgPSB0b0JvdW5kcyhjcnMucHJvamVjdCh0aWxlQm91bmRzWzBdKSwgY3JzLnByb2plY3QodGlsZUJvdW5kc1sxXSkpLFxyXG5cdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHRcdCAgICBiYm94ID0gKHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gRVBTRzQzMjYgP1xyXG5cdFx0ICAgIFttaW4ueSwgbWluLngsIG1heC55LCBtYXgueF0gOlxyXG5cdFx0ICAgIFttaW4ueCwgbWluLnksIG1heC54LCBtYXgueV0pLmpvaW4oJywnKSxcclxuXHRcdCAgICB1cmwgPSBUaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLCBjb29yZHMpO1xyXG5cdFx0cmV0dXJuIHVybCArXHJcblx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuXHRcdFx0KHRoaXMub3B0aW9ucy51cHBlcmNhc2UgPyAnJkJCT1g9JyA6ICcmYmJveD0nKSArIGJib3g7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBNZXJnZXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzIGFuZCByZS1yZXF1ZXN0cyB0aWxlcyBvbiB0aGUgY3VycmVudCBzY3JlZW4gKHVubGVzcyBgbm9SZWRyYXdgIHdhcyBzZXQgdG8gdHJ1ZSkuXHJcblx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVMYXllci53bXMoYmFzZVVybDogU3RyaW5nLCBvcHRpb25zOiBUaWxlTGF5ZXIuV01TIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpO1xyXG59XHJcbiIsImV4cG9ydCB7R3JpZExheWVyLCBncmlkTGF5ZXJ9IGZyb20gJy4vR3JpZExheWVyJztcbmltcG9ydCB7VGlsZUxheWVyLCB0aWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcbmltcG9ydCB7VGlsZUxheWVyV01TLCB0aWxlTGF5ZXJXTVN9IGZyb20gJy4vVGlsZUxheWVyLldNUyc7XG5UaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xudGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcbmV4cG9ydCB7VGlsZUxheWVyLCB0aWxlTGF5ZXJ9O1xuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5leHBvcnQgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0VXRpbC5zdGFtcCh0aGlzKTtcblx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG5cdFx0XHQvLyBhbHdheXMga2VlcCB0cmFuc2Zvcm0tb3JpZ2luIGFzIDAgMFxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcblx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChjdXJyZW50Q2VudGVyUG9pbnQpXG5cdFx0XHRcdCAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIENhbnZhc1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuQ2FudmFzXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vY2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ2FudmFzIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdG9sZXJhbmNlOiBOdW1iZXIgPSAwXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGljayB0b2xlcmFuY2UgYXJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcC5cblx0XHR0b2xlcmFuY2U6IDBcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy52aWV3cHJlcmVzZXQgPSB0aGlzLl9vblZpZXdQcmVSZXNldDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vblZpZXdQcmVSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFNldCBhIGZsYWcgc28gdGhhdCBhIHZpZXdwcmVyZXNldCttb3ZlZW5kK3ZpZXdyZXNldCBvbmx5IHVwZGF0ZXMmcmVkcmF3cyBvbmNlXG5cdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXHRcdGNvbnRhaW5lclsnX2xlYWZsZXRfZGlzYWJsZV9ldmVudHMnXSA9IHRydWU7XG5cblx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3JlZHJhd1JlcXVlc3QpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jdHg7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGxheWVyO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHRoaXMuX3JlZHJhdygpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIG0gPSBCcm93c2VyLnJldGluYSA/IDIgOiAxO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblxuXHRcdC8vIHNldCBjYW52YXMgc2l6ZSAoYWxzbyBjbGVhcmluZyBpdCk7IHVzZSBkb3VibGUgc2l6ZSBvbiByZXRpbmFcblx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuXHRcdGNvbnRhaW5lci5oZWlnaHQgPSBtICogc2l6ZS55O1xuXHRcdGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XG5cdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cblx0XHRpZiAoQnJvd3Nlci5yZXRpbmEpIHtcblx0XHRcdHRoaXMuX2N0eC5zY2FsZSgyLCAyKTtcblx0XHR9XG5cblx0XHQvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzIGVsZW1lbnQgbW92ZXNcblx0XHR0aGlzLl9jdHgudHJhbnNsYXRlKC1iLm1pbi54LCAtYi5taW4ueSk7XG5cblx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyk7XG5cblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykge1xuXHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblxuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlciA9IHtcblx0XHRcdGxheWVyOiBsYXllcixcblx0XHRcdHByZXY6IHRoaXMuX2RyYXdMYXN0LFxuXHRcdFx0bmV4dDogbnVsbFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX2RyYXdMYXN0KSB7IHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjsgfVxuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gdGhpcy5fZHJhd0ZpcnN0IHx8IHRoaXMuX2RyYXdMYXN0O1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRkZWxldGUgbGF5ZXIuX29yZGVyO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV07XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gUmVkcmF3IHRoZSB1bmlvbiBvZiB0aGUgbGF5ZXIncyBvbGQgcGl4ZWxcblx0XHQvLyBib3VuZHMgYW5kIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0Ly8gVGhlIHJlZHJhdyB3aWxsIGV4dGVuZCB0aGUgcmVkcmF3IGJvdW5kc1xuXHRcdC8vIHdpdGggdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICh0eXBlb2YgbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgvWywgXSsvKSxcblx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcblx0XHRcdCAgICBkYXNoVmFsdWUsXG5cdFx0XHQgICAgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkYXNoVmFsdWUgPSBOdW1iZXIocGFydHNbaV0pO1xuXHRcdFx0XHQvLyBJZ25vcmUgZGFzaCBhcnJheSBjb250YWluaW5nIGludmFsaWQgbGVuZ3Roc1xuXHRcdFx0XHRpZiAoaXNOYU4oZGFzaFZhbHVlKSkgeyByZXR1cm47IH1cblx0XHRcdFx0ZGFzaEFycmF5LnB1c2goZGFzaFZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGRhc2hBcnJheTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG5cdH0sXG5cblx0X2V4dGVuZFJlZHJhd0JvdW5kczogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGxheWVyLl9weEJvdW5kcykge1xuXHRcdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBCb3VuZHMoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdGlmICh0aGlzLl9yZWRyYXdCb3VuZHMpIHtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWF4Ll9jZWlsKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2xlYXIoKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcblx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF9jbGVhcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcblx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gdHJ1ZTtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKCFib3VuZHMgfHwgKGxheWVyLl9weEJvdW5kcyAmJiBsYXllci5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSkge1xuXHRcdFx0XHRsYXllci5fdXBkYXRlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcblx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG5cdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdGlmICghdGhpcy5fZHJhd2luZyB8fCBsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcyA9IChNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcikgLyByO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc2NhbGUoMSwgcyk7XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblx0fSxcblxuXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMud2VpZ2h0ICE9PSAwKSB7XG5cdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcblx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVyLCBjbGlja2VkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRpZiAoIShlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAncHJlY2xpY2snKSB8fCAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcblx0XHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9maXJlRXZlbnQoY2xpY2tlZExheWVyID8gW2NsaWNrZWRMYXllcl0gOiBmYWxzZSwgZSk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0aWYgKGxheWVyKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG5cdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZUhvdmVyZWRMYXllciA9IGxheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgIT09IHRoaXMuX2hvdmVyZWRMYXllcikge1xuXHRcdFx0dGhpcy5faGFuZGxlTW91c2VPdXQoZSk7XG5cblx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjYW5kaWRhdGVIb3ZlcmVkTGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XG5cdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maXJlRXZlbnQodGhpcy5faG92ZXJlZExheWVyID8gW3RoaXMuX2hvdmVyZWRMYXllcl0gOiBmYWxzZSwgZSk7XG5cblx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gdHJ1ZTtcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG5cdFx0fSwgdGhpcyksIDMyKTtcblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbiAobGF5ZXJzLCBlLCB0eXBlKSB7XG5cdFx0dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoZSwgdHlwZSB8fCBlLnR5cGUsIGxheWVycyk7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSBpZiAobmV4dCkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSB0aGlzLl9kcmF3TGFzdDtcblx0XHR0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7XG5cblx0XHRvcmRlci5uZXh0ID0gbnVsbDtcblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cblx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGZpcnN0XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSBpZiAocHJldikge1xuXHRcdFx0Ly8gVXBkYXRlIGxhc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gbnVsbDtcblxuXHRcdG9yZGVyLm5leHQgPSB0aGlzLl9kcmF3Rmlyc3Q7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0LnByZXYgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jYW52YXMob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gY2FudmFzKG9wdGlvbnMpIHtcblx0cmV0dXJuIEJyb3dzZXIuY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG59XG4iLCJpbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuXG4vKlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG5cbmV4cG9ydCB2YXIgdm1sQ3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gRG8gbm90IHJldHVybiBmbiBmcm9tIGNhdGNoIGJsb2NrIHNvIGBlYCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzcyNzlcblx0fVxuXHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdH07XG59KSgpO1xuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5leHBvcnQgdmFyIHZtbE1peGluID0ge1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IHZtbENyZWF0ZSgnc2hhcGUnKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0RG9tVXRpbC5yZW1vdmUoY29udGFpbmVyKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBVdGlsLmlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn07XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge3N0YW1wfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtzdmdDcmVhdGUsIHBvaW50c1RvUGF0aH0gZnJvbSAnLi9TVkcuVXRpbCc7XG5leHBvcnQge3BvaW50c1RvUGF0aH07XG5pbXBvcnQge3ZtbE1peGluLCB2bWxDcmVhdGV9IGZyb20gJy4vU1ZHLlZNTCc7XG5cbmV4cG9ydCB2YXIgY3JlYXRlID0gQnJvd3Nlci52bWwgPyB2bWxDcmVhdGUgOiBzdmdDcmVhdGU7XG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5TVkdcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cHM6Ly9jYW5pdXNlLmNvbS9zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlKCdzdmcnKTtcblxuXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdHRoaXMuX3Jvb3RHcm91cCA9IGNyZWF0ZSgnZycpO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290R3JvdXApO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHRcdGRlbGV0ZSB0aGlzLl9yb290R3JvdXA7XG5cdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IGNyZWF0ZSgncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKEJyb3dzZXIudm1sKSB7XG5cdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbn1cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLnN2ZyB8fCBCcm93c2VyLnZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uLy4uL21hcC9NYXAnO1xuaW1wb3J0IHtjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7c3ZnfSBmcm9tICcuL1NWRyc7XG5cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG5cdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG5cdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0aWYgKCFyZW5kZXJlcikge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuXHRcdFx0dGhpcy5hZGRMYXllcihyZW5kZXJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfZ2V0UGFuZVJlbmRlcmVyOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG5cdFx0aWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoe3BhbmU6IG5hbWV9KTtcblx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9jcmVhdGVSZW5kZXJlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cblx0XHQvLyBCeSBkZWZhdWx0LCBhbGwgYFBhdGhgcyBhcmUgcmVuZGVyZWQgaW4gYSBgU1ZHYCByZW5kZXJlci5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzKG9wdGlvbnMpKSB8fCBzdmcob3B0aW9ucyk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG5leHBvcnQgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbn1cbiIsImV4cG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuZXhwb3J0IHtDYW52YXMsIGNhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtTVkcsIGNyZWF0ZSwgcG9pbnRzVG9QYXRoLCBzdmd9IGZyb20gJy4vU1ZHJztcblNWRy5jcmVhdGUgPSBjcmVhdGU7XG5TVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuZXhwb3J0IHtTVkcsIHN2Z307XG5pbXBvcnQgJy4vUmVuZGVyZXIuZ2V0UmVuZGVyZXInO1x0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBuZWVkZWQgYmVjYXVzZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuZXhwb3J0IHtDaXJjbGVNYXJrZXIsIGNpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuZXhwb3J0IHtDaXJjbGUsIGNpcmNsZX0gZnJvbSAnLi9DaXJjbGUnO1xuZXhwb3J0IHtQb2x5bGluZSwgcG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuZXhwb3J0IHtQb2x5Z29uLCBwb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuZXhwb3J0IHtSZWN0YW5nbGUsIHJlY3RhbmdsZX0gZnJvbSAnLi9SZWN0YW5nbGUnO1xuIiwiZXhwb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5leHBvcnQge0xheWVyR3JvdXAsIGxheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XG5leHBvcnQge0ZlYXR1cmVHcm91cCwgZmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5pbXBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb24sIGdlb21ldHJ5VG9MYXllciwgY29vcmRzVG9MYXRMbmcsIGNvb3Jkc1RvTGF0TG5ncywgbGF0TG5nVG9Db29yZHMsIGxhdExuZ3NUb0Nvb3JkcywgZ2V0RmVhdHVyZSwgYXNGZWF0dXJlfSBmcm9tICcuL0dlb0pTT04nO1xuR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmc7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5ncyA9IGNvb3Jkc1RvTGF0TG5ncztcbkdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3Jkcztcbkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzID0gbGF0TG5nc1RvQ29vcmRzO1xuR2VvSlNPTi5nZXRGZWF0dXJlID0gZ2V0RmVhdHVyZTtcbkdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuZXhwb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29ufTtcblxuZXhwb3J0IHtJbWFnZU92ZXJsYXksIGltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xuZXhwb3J0IHtWaWRlb092ZXJsYXksIHZpZGVvT3ZlcmxheX0gZnJvbSAnLi9WaWRlb092ZXJsYXknO1xuZXhwb3J0IHtTVkdPdmVybGF5LCBzdmdPdmVybGF5fSBmcm9tICcuL1NWR092ZXJsYXknO1xuXG5leHBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5leHBvcnQge1BvcHVwLCBwb3B1cH0gZnJvbSAnLi9Qb3B1cCc7XG5leHBvcnQge1Rvb2x0aXAsIHRvb2x0aXB9IGZyb20gJy4vVG9vbHRpcCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vbWFya2VyL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdGlsZS9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3ZlY3Rvci9pbmRleCc7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG5cdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRib3hab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmUpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wYW5lO1xuXHR9LFxuXG5cdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBDbGVhciB0aGUgZGVmZXJyZWQgcmVzZXRTdGF0ZSBpZiBpdCBoYXNuJ3QgZXhlY3V0ZWQgeWV0LCBvdGhlcndpc2UgaXRcblx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cblx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuRG91YmxlQ2xpY2tab29tIGlzIHVzZWQgdG8gaGFuZGxlIGRvdWJsZS1jbGljayB6b29tIG9uIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG5cdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcblx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtEcmFnZ2FibGV9IGZyb20gJy4uLy4uL2RvbS9EcmFnZ2FibGUnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcERyYWcgaXMgdXNlZCB0byBtYWtlIHRoZSBtYXAgZHJhZ2dhYmxlICh3aXRoIHBhbm5pbmcgaW5lcnRpYSksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXG5cdGRyYWdnaW5nOiB0cnVlLFxuXG5cdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG5cdC8vIEBvcHRpb24gaW5lcnRpYTogQm9vbGVhbiA9ICpcblx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuXHQvLyB0aGUgc2FtZSBkaXJlY3Rpb24gZm9yIHNvbWUgdGltZS4gRmVlbHMgZXNwZWNpYWxseSBuaWNlIG9uIHRvdWNoXG5cdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdC5cblx0aW5lcnRpYTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbmV4cG9ydCB2YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdMaW1pdCwgdGhpcyk7XG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcblx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblxuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmluZztcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcblx0XHRcdHZhciBib3VuZHMgPSBsYXRMbmdCb3VuZHModGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSB0b0JvdW5kcyhcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldE5vcnRoV2VzdCgpKS5tdWx0aXBseUJ5KC0xKSxcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldFNvdXRoRWFzdCgpKS5tdWx0aXBseUJ5KC0xKVxuXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG5cdFx0XHR0aGlzLl92aXNjb3NpdHkgPSBNYXRoLm1pbigxLjAsIE1hdGgubWF4KDAuMCwgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRtYXBcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHRcdHRoaXMuX3RpbWVzID0gW107XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcblx0XHRcdCAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgfHwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XG5cblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG5cdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG5cdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucyh0aW1lKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9wcnVuZVBvc2l0aW9uczogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR3aGlsZSAodGhpcy5fcG9zaXRpb25zLmxlbmd0aCA+IDEgJiYgdGltZSAtIHRoaXMuX3RpbWVzWzBdID4gNTApIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHR9XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcblx0fSxcblxuXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cblx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcblx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG5cdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IGUubm9JbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG5cdFx0aWYgKG5vSW5lcnRpYSkge1xuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUoKSk7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG5cdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbi8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBEcmFnKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtvbiwgb2ZmLCBzdG9wfSBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cblxuLypcbiAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5leHBvcnQgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRvbihjb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vZmYoe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcblx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG5cdH0sXG5cblx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuXHR9LFxuXG5cdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2Zmc2V0O1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG5cdFx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcblx0XHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KHRvUG9pbnQob2Zmc2V0KSwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdFx0dmFyIG5ld0xhdExuZyA9IG1hcC53cmFwTGF0TG5nKG1hcC51bnByb2plY3QobWFwLnByb2plY3QobWFwLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSkpO1xuXHRcdFx0XHRcdG1hcC5wYW5UbyhuZXdMYXRMbmcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcblx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3ICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpIHtcblx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN0b3AoZSk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgS2V5Ym9hcmQpO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gTW91c2Ugd2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxuZXhwb3J0IHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblx0fSxcblxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZGVsdGEgPSBEb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHREb21FdmVudC5zdG9wKGUpO1xuXHR9LFxuXG5cdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG5cdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG5cdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG5cdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4vLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogTC5NYXAuVGFwSG9sZCBpcyB1c2VkIHRvIHNpbXVsYXRlIGBjb250ZXh0bWVudWAgZXZlbnQgb24gbG9uZyBob2xkLFxuICogd2hpY2ggb3RoZXJ3aXNlIGlzIG5vdCBmaXJlZCBieSBtb2JpbGUgU2FmYXJpLlxuICovXG5cbnZhciB0YXBIb2xkRGVsYXkgPSA2MDA7XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRhcEhvbGQ6IEJvb2xlYW5cblx0Ly8gRW5hYmxlcyBzaW11bGF0aW9uIG9mIGBjb250ZXh0bWVudWAgZXZlbnQsIGRlZmF1bHQgaXMgYHRydWVgIGZvciBtb2JpbGUgU2FmYXJpLlxuXHR0YXBIb2xkOiBCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIuc2FmYXJpICYmIEJyb3dzZXIubW9iaWxlLFxuXG5cdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbmV4cG9ydCB2YXIgVGFwSG9sZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9jYW5jZWwoKTtcblx0XHRcdGlmICghdGhpcy5faXNUYXBWYWxpZCgpKSB7IHJldHVybjsgfVxuXG5cdFx0XHQvLyBwcmV2ZW50IHNpbXVsYXRlZCBtb3VzZSBldmVudHMgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3RvdWNoLWV2ZW50cy8jbW91c2UtZXZlbnRzXG5cdFx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXHRcdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX2NhbmNlbENsaWNrUHJldmVudCk7XG5cdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjb250ZXh0bWVudScsIGZpcnN0KTtcblx0XHR9LCB0aGlzKSwgdGFwSG9sZERlbGF5KTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgY29udGV4dG1lbnUnLCB0aGlzLl9jYW5jZWwsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcblx0fSxcblxuXHRfY2FuY2VsQ2xpY2tQcmV2ZW50OiBmdW5jdGlvbiBjYW5jZWxDbGlja1ByZXZlbnQoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBjYW5jZWxDbGlja1ByZXZlbnQpO1xuXHR9LFxuXG5cdF9jYW5jZWw6IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIHtcblx0XHRcdGJ1YmJsZXM6IHRydWUsXG5cdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRcdFx0dmlldzogd2luZG93LFxuXHRcdFx0Ly8gZGV0YWlsOiAxLFxuXHRcdFx0c2NyZWVuWDogZS5zY3JlZW5YLFxuXHRcdFx0c2NyZWVuWTogZS5zY3JlZW5ZLFxuXHRcdFx0Y2xpZW50WDogZS5jbGllbnRYLFxuXHRcdFx0Y2xpZW50WTogZS5jbGllbnRZLFxuXHRcdFx0Ly8gYnV0dG9uOiAyLFxuXHRcdFx0Ly8gYnV0dG9uczogMlxuXHRcdH0pO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdGFwSG9sZDogSGFuZGxlclxuLy8gTG9uZyB0YXAgaGFuZGxlciB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50ICh1c2VmdWwgaW4gbW9iaWxlIFNhZmFyaSkuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwSG9sZCcsIFRhcEhvbGQpO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMuXG5cdHRvdWNoWm9vbTogQnJvd3Nlci50b3VjaCxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcblx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdHZhciBtb3ZlRm4gPSBVdGlsLmJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9LCB1bmRlZmluZWQpO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKG1vdmVGbiwgdGhpcywgdHJ1ZSk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHR0aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSksIHRydWUsIHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbi8vIFRvdWNoIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBUb3VjaFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4vTWFwJztcbmltcG9ydCB7Qm94Wm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Cb3hab29tJztcbk1hcC5Cb3hab29tID0gQm94Wm9vbTtcbmltcG9ydCB7RG91YmxlQ2xpY2tab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbSc7XG5NYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuaW1wb3J0IHtEcmFnfSBmcm9tICcuL2hhbmRsZXIvTWFwLkRyYWcnO1xuTWFwLkRyYWcgPSBEcmFnO1xuaW1wb3J0IHtLZXlib2FyZH0gZnJvbSAnLi9oYW5kbGVyL01hcC5LZXlib2FyZCc7XG5NYXAuS2V5Ym9hcmQgPSBLZXlib2FyZDtcbmltcG9ydCB7U2Nyb2xsV2hlZWxab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbSc7XG5NYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuaW1wb3J0IHtUYXBIb2xkfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRhcEhvbGQnO1xuTWFwLlRhcEhvbGQgPSBUYXBIb2xkO1xuaW1wb3J0IHtUb3VjaFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuVG91Y2hab29tJztcbk1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbmV4cG9ydCB7TWFwLCBjcmVhdGVNYXAgYXMgbWFwfSBmcm9tICcuL01hcCc7XG4iXSwibmFtZXMiOlsiZXh0ZW5kIiwiZGVzdCIsImkiLCJqIiwibGVuIiwic3JjIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY3JlYXRlJDIiLCJPYmplY3QiLCJjcmVhdGUiLCJGIiwicHJvdG8iLCJwcm90b3R5cGUiLCJiaW5kIiwiZm4iLCJvYmoiLCJzbGljZSIsIkFycmF5IiwiYXBwbHkiLCJjYWxsIiwiYXJncyIsImNvbmNhdCIsImxhc3RJZCIsInN0YW1wIiwiX2xlYWZsZXRfaWQiLCJ0aHJvdHRsZSIsInRpbWUiLCJjb250ZXh0IiwibG9jayIsIndyYXBwZXJGbiIsImxhdGVyIiwic2V0VGltZW91dCIsIndyYXBOdW0iLCJ4IiwicmFuZ2UiLCJpbmNsdWRlTWF4IiwibWF4IiwibWluIiwiZCIsImZhbHNlRm4iLCJmb3JtYXROdW0iLCJudW0iLCJwcmVjaXNpb24iLCJwb3ciLCJNYXRoIiwidW5kZWZpbmVkIiwicm91bmQiLCJ0cmltIiwic3RyIiwicmVwbGFjZSIsInNwbGl0V29yZHMiLCJzcGxpdCIsInNldE9wdGlvbnMiLCJvcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJnZXRQYXJhbVN0cmluZyIsImV4aXN0aW5nVXJsIiwidXBwZXJjYXNlIiwicGFyYW1zIiwicHVzaCIsImVuY29kZVVSSUNvbXBvbmVudCIsInRvVXBwZXJDYXNlIiwiaW5kZXhPZiIsImpvaW4iLCJ0ZW1wbGF0ZVJlIiwidGVtcGxhdGUiLCJkYXRhIiwia2V5IiwidmFsdWUiLCJFcnJvciIsImlzQXJyYXkiLCJ0b1N0cmluZyIsImFycmF5IiwiZWwiLCJlbXB0eUltYWdlVXJsIiwiZ2V0UHJlZml4ZWQiLCJuYW1lIiwid2luZG93IiwibGFzdFRpbWUiLCJ0aW1lb3V0RGVmZXIiLCJEYXRlIiwidGltZVRvQ2FsbCIsInJlcXVlc3RGbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEZuIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpZCIsImNsZWFyVGltZW91dCIsInJlcXVlc3RBbmltRnJhbWUiLCJpbW1lZGlhdGUiLCJjYW5jZWxBbmltRnJhbWUiLCJDbGFzcyIsInByb3BzIiwiTmV3Q2xhc3MiLCJpbml0aWFsaXplIiwiY2FsbEluaXRIb29rcyIsInBhcmVudFByb3RvIiwiX19zdXBlcl9fIiwiY29uc3RydWN0b3IiLCJzdGF0aWNzIiwiaW5jbHVkZXMiLCJjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyIsIl9pbml0SG9va3MiLCJfaW5pdEhvb2tzQ2FsbGVkIiwiaW5jbHVkZSIsInBhcmVudE9wdGlvbnMiLCJtZXJnZU9wdGlvbnMiLCJhZGRJbml0SG9vayIsImluaXQiLCJMIiwiTWl4aW4iLCJFdmVudHMiLCJjb25zb2xlIiwid2FybiIsInN0YWNrIiwib24iLCJ0eXBlcyIsInR5cGUiLCJfb24iLCJvZmYiLCJfZXZlbnRzIiwiX29mZiIsInJlbW92ZUFsbCIsIl9vbmNlIiwiX2xpc3RlbnMiLCJuZXdMaXN0ZW5lciIsImN0eCIsIm9uY2UiLCJsaXN0ZW5lcnMiLCJfZmlyaW5nQ291bnQiLCJpbmRleCIsImxpc3RlbmVyIiwic3BsaWNlIiwiZmlyZSIsInByb3BhZ2F0ZSIsImxpc3RlbnMiLCJldmVudCIsInRhcmdldCIsInNvdXJjZVRhcmdldCIsImwiLCJfcHJvcGFnYXRlRXZlbnQiLCJfZm4iLCJfZXZlbnRQYXJlbnRzIiwiYWRkRXZlbnRQYXJlbnQiLCJyZW1vdmVFdmVudFBhcmVudCIsImUiLCJsYXllciIsInByb3BhZ2F0ZWRGcm9tIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGVhckFsbEV2ZW50TGlzdGVuZXJzIiwiYWRkT25lVGltZUV2ZW50TGlzdGVuZXIiLCJmaXJlRXZlbnQiLCJoYXNFdmVudExpc3RlbmVycyIsIkV2ZW50ZWQiLCJQb2ludCIsInkiLCJ0cnVuYyIsInYiLCJmbG9vciIsImNlaWwiLCJjbG9uZSIsImFkZCIsInBvaW50IiwiX2FkZCIsInRvUG9pbnQiLCJzdWJ0cmFjdCIsIl9zdWJ0cmFjdCIsImRpdmlkZUJ5IiwiX2RpdmlkZUJ5IiwibXVsdGlwbHlCeSIsIl9tdWx0aXBseUJ5Iiwic2NhbGVCeSIsInVuc2NhbGVCeSIsIl9yb3VuZCIsIl9mbG9vciIsIl9jZWlsIiwiX3RydW5jIiwiZGlzdGFuY2VUbyIsInNxcnQiLCJlcXVhbHMiLCJjb250YWlucyIsImFicyIsIkJvdW5kcyIsImEiLCJiIiwicG9pbnRzIiwibWluMiIsIm1heDIiLCJ0b0JvdW5kcyIsImdldENlbnRlciIsImdldEJvdHRvbUxlZnQiLCJnZXRUb3BSaWdodCIsImdldFRvcExlZnQiLCJnZXRCb3R0b21SaWdodCIsImdldFNpemUiLCJpbnRlcnNlY3RzIiwiYm91bmRzIiwieEludGVyc2VjdHMiLCJ5SW50ZXJzZWN0cyIsIm92ZXJsYXBzIiwieE92ZXJsYXBzIiwieU92ZXJsYXBzIiwiaXNWYWxpZCIsInBhZCIsImJ1ZmZlclJhdGlvIiwiaGVpZ2h0QnVmZmVyIiwid2lkdGhCdWZmZXIiLCJMYXRMbmdCb3VuZHMiLCJjb3JuZXIxIiwiY29ybmVyMiIsImxhdGxuZ3MiLCJzdyIsIl9zb3V0aFdlc3QiLCJuZSIsIl9ub3J0aEVhc3QiLCJzdzIiLCJuZTIiLCJMYXRMbmciLCJ0b0xhdExuZyIsInRvTGF0TG5nQm91bmRzIiwibGF0IiwibG5nIiwiZ2V0U291dGhXZXN0IiwiZ2V0Tm9ydGhFYXN0IiwiZ2V0Tm9ydGhXZXN0IiwiZ2V0Tm9ydGgiLCJnZXRXZXN0IiwiZ2V0U291dGhFYXN0IiwiZ2V0U291dGgiLCJnZXRFYXN0IiwibGF0SW50ZXJzZWN0cyIsImxuZ0ludGVyc2VjdHMiLCJsYXRPdmVybGFwcyIsImxuZ092ZXJsYXBzIiwidG9CQm94U3RyaW5nIiwibWF4TWFyZ2luIiwiYWx0IiwiaXNOYU4iLCJtYXJnaW4iLCJvdGhlciIsIkVhcnRoIiwiZGlzdGFuY2UiLCJ3cmFwIiwid3JhcExhdExuZyIsInNpemVJbk1ldGVycyIsImxhdEFjY3VyYWN5IiwibG5nQWNjdXJhY3kiLCJjb3MiLCJQSSIsImMiLCJsb24iLCJDUlMiLCJsYXRMbmdUb1BvaW50IiwibGF0bG5nIiwiem9vbSIsInByb2plY3RlZFBvaW50IiwicHJvamVjdGlvbiIsInByb2plY3QiLCJzY2FsZSIsInRyYW5zZm9ybWF0aW9uIiwiX3RyYW5zZm9ybSIsInBvaW50VG9MYXRMbmciLCJ1bnRyYW5zZm9ybWVkUG9pbnQiLCJ1bnRyYW5zZm9ybSIsInVucHJvamVjdCIsImxvZyIsIkxOMiIsImdldFByb2plY3RlZEJvdW5kcyIsImluZmluaXRlIiwicyIsInRyYW5zZm9ybSIsIndyYXBMbmciLCJ3cmFwTGF0Iiwid3JhcExhdExuZ0JvdW5kcyIsImNlbnRlciIsIm5ld0NlbnRlciIsImxhdFNoaWZ0IiwibG5nU2hpZnQiLCJuZXdTdyIsIm5ld05lIiwiUiIsImxhdGxuZzEiLCJsYXRsbmcyIiwicmFkIiwibGF0MSIsImxhdDIiLCJzaW5ETGF0Iiwic2luIiwic2luRExvbiIsImF0YW4yIiwiZWFydGhSYWRpdXMiLCJTcGhlcmljYWxNZXJjYXRvciIsIk1BWF9MQVRJVFVERSIsImF0YW4iLCJleHAiLCJUcmFuc2Zvcm1hdGlvbiIsIl9hIiwiX2IiLCJfYyIsIl9kIiwidG9UcmFuc2Zvcm1hdGlvbiIsIkVQU0czODU3IiwiY29kZSIsIkVQU0c5MDA5MTMiLCJzdmdDcmVhdGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInBvaW50c1RvUGF0aCIsInJpbmdzIiwiY2xvc2VkIiwibGVuMiIsInAiLCJCcm93c2VyIiwic3ZnIiwic3R5bGUiLCJkb2N1bWVudEVsZW1lbnQiLCJpZSIsImllbHQ5IiwiZWRnZSIsIm5hdmlnYXRvciIsIndlYmtpdCIsInVzZXJBZ2VudENvbnRhaW5zIiwiYW5kcm9pZCIsImFuZHJvaWQyMyIsIndlYmtpdFZlciIsInBhcnNlSW50IiwiZXhlYyIsInVzZXJBZ2VudCIsImFuZHJvaWRTdG9jayIsIm9wZXJhIiwiY2hyb21lIiwiZ2Vja28iLCJzYWZhcmkiLCJwaGFudG9tIiwib3BlcmExMiIsIndpbiIsInBsYXRmb3JtIiwiaWUzZCIsIndlYmtpdDNkIiwiV2ViS2l0Q1NTTWF0cml4IiwiZ2Vja28zZCIsImFueTNkIiwiTF9ESVNBQkxFXzNEIiwibW9iaWxlIiwib3JpZW50YXRpb24iLCJtb2JpbGVXZWJraXQiLCJtb2JpbGVXZWJraXQzZCIsIm1zUG9pbnRlciIsIlBvaW50ZXJFdmVudCIsIk1TUG9pbnRlckV2ZW50IiwicG9pbnRlciIsInRvdWNoTmF0aXZlIiwiVG91Y2hFdmVudCIsInRvdWNoIiwiTF9OT19UT1VDSCIsIm1vYmlsZU9wZXJhIiwibW9iaWxlR2Vja28iLCJyZXRpbmEiLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NyZWVuIiwiZGV2aWNlWERQSSIsImxvZ2ljYWxYRFBJIiwicGFzc2l2ZUV2ZW50cyIsInN1cHBvcnRzUGFzc2l2ZU9wdGlvbiIsIm9wdHMiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImNhbnZhcyQxIiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJzdmckMSIsImNyZWF0ZVNWR1JlY3QiLCJpbmxpbmVTdmciLCJkaXYiLCJpbm5lckhUTUwiLCJmaXJzdENoaWxkIiwibmFtZXNwYWNlVVJJIiwidm1sIiwic2hhcGUiLCJiZWhhdmlvciIsImFkaiIsIm1hYyIsImxpbnV4IiwidG9Mb3dlckNhc2UiLCJjYW52YXMiLCJQT0lOVEVSX0RPV04iLCJQT0lOVEVSX01PVkUiLCJQT0lOVEVSX1VQIiwiUE9JTlRFUl9DQU5DRUwiLCJwRXZlbnQiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJ0b3VjaGNhbmNlbCIsImhhbmRsZSIsIl9vblBvaW50ZXJTdGFydCIsIl9oYW5kbGVQb2ludGVyIiwiX3BvaW50ZXJzIiwiX3BvaW50ZXJEb2NMaXN0ZW5lciIsImFkZFBvaW50ZXJMaXN0ZW5lciIsImhhbmRsZXIiLCJfYWRkUG9pbnRlckRvY0xpc3RlbmVyIiwicmVtb3ZlUG9pbnRlckxpc3RlbmVyIiwiX2dsb2JhbFBvaW50ZXJEb3duIiwicG9pbnRlcklkIiwiX2dsb2JhbFBvaW50ZXJNb3ZlIiwiX2dsb2JhbFBvaW50ZXJVcCIsInBvaW50ZXJUeXBlIiwiTVNQT0lOVEVSX1RZUEVfTU9VU0UiLCJ0b3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJNU1BPSU5URVJfVFlQRV9UT1VDSCIsInByZXZlbnREZWZhdWx0IiwibWFrZURibGNsaWNrIiwibmV3RXZlbnQiLCJwcm9wIiwiZGV0YWlsIiwiaXNUcnVzdGVkIiwiX3NpbXVsYXRlZCIsImRlbGF5IiwiYWRkRG91YmxlVGFwTGlzdGVuZXIiLCJsYXN0Iiwic2ltRGJsY2xpY2siLCJzb3VyY2VDYXBhYmlsaXRpZXMiLCJmaXJlc1RvdWNoRXZlbnRzIiwicGF0aCIsImdldFByb3BhZ2F0aW9uUGF0aCIsInNvbWUiLCJIVE1MTGFiZWxFbGVtZW50IiwiYXR0cmlidXRlcyIsImZvciIsIkhUTUxJbnB1dEVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIm5vdyIsImRibGNsaWNrIiwicmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIiLCJoYW5kbGVycyIsIlRSQU5TRk9STSIsInRlc3RQcm9wIiwiVFJBTlNJVElPTiIsIlRSQU5TSVRJT05fRU5EIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRTdHlsZSIsImN1cnJlbnRTdHlsZSIsImRlZmF1bHRWaWV3IiwiY3NzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImNyZWF0ZSQxIiwidGFnTmFtZSIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsImFwcGVuZENoaWxkIiwicmVtb3ZlIiwicGFyZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZW1wdHkiLCJ0b0Zyb250IiwibGFzdENoaWxkIiwidG9CYWNrIiwiaW5zZXJ0QmVmb3JlIiwiaGFzQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRDbGFzcyIsIlJlZ0V4cCIsInRlc3QiLCJhZGRDbGFzcyIsImNsYXNzZXMiLCJzZXRDbGFzcyIsInJlbW92ZUNsYXNzIiwiYmFzZVZhbCIsImNvcnJlc3BvbmRpbmdFbGVtZW50Iiwic2V0T3BhY2l0eSIsIm9wYWNpdHkiLCJfc2V0T3BhY2l0eUlFIiwiZmlsdGVyIiwiZmlsdGVyTmFtZSIsImZpbHRlcnMiLCJpdGVtIiwiRW5hYmxlZCIsIk9wYWNpdHkiLCJzZXRUcmFuc2Zvcm0iLCJvZmZzZXQiLCJwb3MiLCJzZXRQb3NpdGlvbiIsIl9sZWFmbGV0X3BvcyIsImxlZnQiLCJ0b3AiLCJnZXRQb3NpdGlvbiIsImRpc2FibGVUZXh0U2VsZWN0aW9uIiwiZW5hYmxlVGV4dFNlbGVjdGlvbiIsIl91c2VyU2VsZWN0IiwidXNlclNlbGVjdFByb3BlcnR5IiwiZGlzYWJsZUltYWdlRHJhZyIsImVuYWJsZUltYWdlRHJhZyIsIl9vdXRsaW5lRWxlbWVudCIsIl9vdXRsaW5lU3R5bGUiLCJwcmV2ZW50T3V0bGluZSIsImVsZW1lbnQiLCJ0YWJJbmRleCIsInJlc3RvcmVPdXRsaW5lIiwib3V0bGluZVN0eWxlIiwiZ2V0U2l6ZWRQYXJlbnROb2RlIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJib2R5IiwiZ2V0U2NhbGUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJib3VuZGluZ0NsaWVudFJlY3QiLCJhZGRPbmUiLCJldmVudHNLZXkiLCJiYXRjaFJlbW92ZSIsInJlbW92ZU9uZSIsImZpbHRlckZuIiwibW91c2VTdWJzdCIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwid2hlZWwiLCJvcmlnaW5hbEhhbmRsZXIiLCJwYXNzaXZlIiwiaXNFeHRlcm5hbFRhcmdldCIsImF0dGFjaEV2ZW50IiwiZGV0YWNoRXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJvcmlnaW5hbEV2ZW50IiwiX3N0b3BwZWQiLCJjYW5jZWxCdWJibGUiLCJkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24iLCJkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbiIsInJldHVyblZhbHVlIiwic3RvcCIsImV2IiwiY29tcG9zZWRQYXRoIiwiZ2V0TW91c2VQb3NpdGlvbiIsImNsaWVudFgiLCJjbGllbnRZIiwiY2xpZW50TGVmdCIsImNsaWVudFRvcCIsIndoZWVsUHhGYWN0b3IiLCJnZXRXaGVlbERlbHRhIiwid2hlZWxEZWx0YVkiLCJkZWx0YVkiLCJkZWx0YU1vZGUiLCJkZWx0YVgiLCJkZWx0YVoiLCJ3aGVlbERlbHRhIiwicmVsYXRlZCIsInJlbGF0ZWRUYXJnZXQiLCJlcnIiLCJQb3NBbmltYXRpb24iLCJydW4iLCJuZXdQb3MiLCJkdXJhdGlvbiIsImVhc2VMaW5lYXJpdHkiLCJfZWwiLCJfaW5Qcm9ncmVzcyIsIl9kdXJhdGlvbiIsIl9lYXNlT3V0UG93ZXIiLCJfc3RhcnRQb3MiLCJfb2Zmc2V0IiwiX3N0YXJ0VGltZSIsIl9hbmltYXRlIiwiX3N0ZXAiLCJfY29tcGxldGUiLCJfYW5pbUlkIiwiZWxhcHNlZCIsIl9ydW5GcmFtZSIsIl9lYXNlT3V0IiwicHJvZ3Jlc3MiLCJ0IiwiTWFwIiwiY3JzIiwibWluWm9vbSIsIm1heFpvb20iLCJsYXllcnMiLCJtYXhCb3VuZHMiLCJyZW5kZXJlciIsInpvb21BbmltYXRpb24iLCJ6b29tQW5pbWF0aW9uVGhyZXNob2xkIiwiZmFkZUFuaW1hdGlvbiIsIm1hcmtlclpvb21BbmltYXRpb24iLCJ0cmFuc2Zvcm0zRExpbWl0Iiwiem9vbVNuYXAiLCJ6b29tRGVsdGEiLCJ0cmFja1Jlc2l6ZSIsIl9oYW5kbGVycyIsIl9sYXllcnMiLCJfem9vbUJvdW5kTGF5ZXJzIiwiX3NpemVDaGFuZ2VkIiwiX2luaXRDb250YWluZXIiLCJfaW5pdExheW91dCIsIl9vblJlc2l6ZSIsIl9pbml0RXZlbnRzIiwic2V0TWF4Qm91bmRzIiwiX3pvb20iLCJfbGltaXRab29tIiwic2V0VmlldyIsInJlc2V0IiwiX3pvb21BbmltYXRlZCIsIl9jcmVhdGVBbmltUHJveHkiLCJfcHJveHkiLCJfY2F0Y2hUcmFuc2l0aW9uRW5kIiwiX2FkZExheWVycyIsIl9saW1pdENlbnRlciIsIl9zdG9wIiwiX2xvYWRlZCIsImFuaW1hdGUiLCJwYW4iLCJtb3ZlZCIsIl90cnlBbmltYXRlZFpvb20iLCJfdHJ5QW5pbWF0ZWRQYW4iLCJfc2l6ZVRpbWVyIiwiX3Jlc2V0VmlldyIsIm5vTW92ZVN0YXJ0Iiwic2V0Wm9vbSIsInpvb21JbiIsImRlbHRhIiwiem9vbU91dCIsInNldFpvb21Bcm91bmQiLCJnZXRab29tU2NhbGUiLCJ2aWV3SGFsZiIsImNvbnRhaW5lclBvaW50IiwibGF0TG5nVG9Db250YWluZXJQb2ludCIsImNlbnRlck9mZnNldCIsImNvbnRhaW5lclBvaW50VG9MYXRMbmciLCJfZ2V0Qm91bmRzQ2VudGVyWm9vbSIsImdldEJvdW5kcyIsInBhZGRpbmdUTCIsInBhZGRpbmdUb3BMZWZ0IiwicGFkZGluZyIsInBhZGRpbmdCUiIsInBhZGRpbmdCb3R0b21SaWdodCIsImdldEJvdW5kc1pvb20iLCJJbmZpbml0eSIsInBhZGRpbmdPZmZzZXQiLCJzd1BvaW50IiwibmVQb2ludCIsImZpdEJvdW5kcyIsImZpdFdvcmxkIiwicGFuVG8iLCJwYW5CeSIsImdldFpvb20iLCJfcGFuQW5pbSIsIl9vblBhblRyYW5zaXRpb25TdGVwIiwiX29uUGFuVHJhbnNpdGlvbkVuZCIsIl9tYXBQYW5lIiwiX2dldE1hcFBhbmVQb3MiLCJfcmF3UGFuQnkiLCJmbHlUbyIsInRhcmdldENlbnRlciIsInRhcmdldFpvb20iLCJmcm9tIiwidG8iLCJzaXplIiwic3RhcnRab29tIiwidzAiLCJ3MSIsInUxIiwicmhvIiwicmhvMiIsInIiLCJzMSIsInMyIiwidDEiLCJiMSIsInNxIiwic2luaCIsIm4iLCJjb3NoIiwidGFuaCIsInIwIiwidyIsInUiLCJlYXNlT3V0Iiwic3RhcnQiLCJTIiwiZnJhbWUiLCJfZmx5VG9GcmFtZSIsIl9tb3ZlIiwiZ2V0U2NhbGVab29tIiwiX21vdmVFbmQiLCJfbW92ZVN0YXJ0IiwiZmx5VG9Cb3VuZHMiLCJfcGFuSW5zaWRlTWF4Qm91bmRzIiwic2V0TWluWm9vbSIsIm9sZFpvb20iLCJzZXRNYXhab29tIiwicGFuSW5zaWRlQm91bmRzIiwiX2VuZm9yY2luZ0JvdW5kcyIsInBhbkluc2lkZSIsInBpeGVsQ2VudGVyIiwicGl4ZWxQb2ludCIsInBpeGVsQm91bmRzIiwiZ2V0UGl4ZWxCb3VuZHMiLCJwYWRkZWRCb3VuZHMiLCJwYWRkZWRTaXplIiwiaW52YWxpZGF0ZVNpemUiLCJvbGRTaXplIiwiX2xhc3RDZW50ZXIiLCJuZXdTaXplIiwib2xkQ2VudGVyIiwiZGVib3VuY2VNb3ZlZW5kIiwibG9jYXRlIiwiX2xvY2F0ZU9wdGlvbnMiLCJ0aW1lb3V0Iiwid2F0Y2giLCJfaGFuZGxlR2VvbG9jYXRpb25FcnJvciIsIm1lc3NhZ2UiLCJvblJlc3BvbnNlIiwiX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UiLCJvbkVycm9yIiwiX2xvY2F0aW9uV2F0Y2hJZCIsImdlb2xvY2F0aW9uIiwid2F0Y2hQb3NpdGlvbiIsImdldEN1cnJlbnRQb3NpdGlvbiIsInN0b3BMb2NhdGUiLCJjbGVhcldhdGNoIiwiZXJyb3IiLCJfY29udGFpbmVyIiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJhY2N1cmFjeSIsInRpbWVzdGFtcCIsImFkZEhhbmRsZXIiLCJIYW5kbGVyQ2xhc3MiLCJlbmFibGUiLCJfY29udGFpbmVySWQiLCJfY2xlYXJDb250cm9sUG9zIiwiX3Jlc2l6ZVJlcXVlc3QiLCJfY2xlYXJIYW5kbGVycyIsIl9wYW5lcyIsIl9yZW5kZXJlciIsImNyZWF0ZVBhbmUiLCJwYW5lIiwiX2NoZWNrSWZMb2FkZWQiLCJfbW92ZWQiLCJsYXllclBvaW50VG9MYXRMbmciLCJfZ2V0Q2VudGVyTGF5ZXJQb2ludCIsImdldE1pblpvb20iLCJfbGF5ZXJzTWluWm9vbSIsImdldE1heFpvb20iLCJfbGF5ZXJzTWF4Wm9vbSIsImluc2lkZSIsIm53Iiwic2UiLCJib3VuZHNTaXplIiwic25hcCIsInNjYWxleCIsInNjYWxleSIsIl9zaXplIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJ0b3BMZWZ0UG9pbnQiLCJfZ2V0VG9wTGVmdFBvaW50IiwiZ2V0UGl4ZWxPcmlnaW4iLCJfcGl4ZWxPcmlnaW4iLCJnZXRQaXhlbFdvcmxkQm91bmRzIiwiZ2V0UGFuZSIsImdldFBhbmVzIiwiZ2V0Q29udGFpbmVyIiwidG9ab29tIiwiZnJvbVpvb20iLCJsYXRMbmdUb0xheWVyUG9pbnQiLCJjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCIsImxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50IiwibGF5ZXJQb2ludCIsIm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50IiwibW91c2VFdmVudFRvTGF5ZXJQb2ludCIsIm1vdXNlRXZlbnRUb0xhdExuZyIsIl9vblNjcm9sbCIsIl9mYWRlQW5pbWF0ZWQiLCJwb3NpdGlvbiIsIl9pbml0UGFuZXMiLCJfaW5pdENvbnRyb2xQb3MiLCJwYW5lcyIsIl9wYW5lUmVuZGVyZXJzIiwibWFya2VyUGFuZSIsInNoYWRvd1BhbmUiLCJsb2FkaW5nIiwiem9vbUNoYW5nZWQiLCJzdXByZXNzRXZlbnQiLCJfZ2V0TmV3UGl4ZWxPcmlnaW4iLCJwaW5jaCIsIl9nZXRab29tU3BhbiIsIl90YXJnZXRzIiwib25PZmYiLCJfaGFuZGxlRE9NRXZlbnQiLCJfb25Nb3ZlRW5kIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIl9maW5kRXZlbnRUYXJnZXRzIiwidGFyZ2V0cyIsImlzSG92ZXIiLCJzcmNFbGVtZW50IiwiZHJhZ2dpbmciLCJfZHJhZ2dhYmxlTW92ZWQiLCJfaXNDbGlja0Rpc2FibGVkIiwiX2ZpcmVET01FdmVudCIsIl9tb3VzZUV2ZW50cyIsImNhbnZhc1RhcmdldHMiLCJzeW50aCIsImZpbHRlcmVkIiwiaXNNYXJrZXIiLCJnZXRMYXRMbmciLCJfcmFkaXVzIiwiYnViYmxpbmdNb3VzZUV2ZW50cyIsImVuYWJsZWQiLCJib3hab29tIiwiZGlzYWJsZSIsIndoZW5SZWFkeSIsImNhbGxiYWNrIiwicGl4ZWxPcmlnaW4iLCJfbGF0TG5nVG9OZXdMYXllclBvaW50IiwidG9wTGVmdCIsIl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzIiwibGF0TG5nQm91bmRzIiwiX2dldENlbnRlck9mZnNldCIsImNlbnRlclBvaW50Iiwidmlld0JvdW5kcyIsIl9nZXRCb3VuZHNPZmZzZXQiLCJfbGltaXRPZmZzZXQiLCJuZXdCb3VuZHMiLCJweEJvdW5kcyIsInByb2plY3RlZE1heEJvdW5kcyIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImR4IiwiX3JlYm91bmQiLCJkeSIsInJpZ2h0IiwicHJveHkiLCJtYXBQYW5lIiwiX2FuaW1hdGluZ1pvb20iLCJfb25ab29tVHJhbnNpdGlvbkVuZCIsIl9hbmltTW92ZUVuZCIsIl9kZXN0cm95QW5pbVByb3h5IiwieiIsInByb3BlcnR5TmFtZSIsIl9ub3RoaW5nVG9BbmltYXRlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIl9hbmltYXRlWm9vbSIsInN0YXJ0QW5pbSIsIm5vVXBkYXRlIiwiX2FuaW1hdGVUb0NlbnRlciIsIl9hbmltYXRlVG9ab29tIiwiX3RlbXBGaXJlWm9vbUV2ZW50IiwiY3JlYXRlTWFwIiwiQ29udHJvbCIsIm1hcCIsIl9tYXAiLCJyZW1vdmVDb250cm9sIiwiYWRkQ29udHJvbCIsImFkZFRvIiwib25BZGQiLCJjb3JuZXIiLCJfY29udHJvbENvcm5lcnMiLCJvblJlbW92ZSIsIl9yZWZvY3VzT25NYXAiLCJzY3JlZW5YIiwic2NyZWVuWSIsImZvY3VzIiwiY29udHJvbCIsImNvcm5lcnMiLCJfY29udHJvbENvbnRhaW5lciIsImNyZWF0ZUNvcm5lciIsInZTaWRlIiwiaFNpZGUiLCJMYXllcnMiLCJjb2xsYXBzZWQiLCJhdXRvWkluZGV4IiwiaGlkZVNpbmdsZUJhc2UiLCJzb3J0TGF5ZXJzIiwic29ydEZ1bmN0aW9uIiwibGF5ZXJBIiwibGF5ZXJCIiwibmFtZUEiLCJuYW1lQiIsImJhc2VMYXllcnMiLCJvdmVybGF5cyIsIl9sYXllckNvbnRyb2xJbnB1dHMiLCJfbGFzdFpJbmRleCIsIl9oYW5kbGluZ0NsaWNrIiwiX3ByZXZlbnRDbGljayIsIl9hZGRMYXllciIsIl91cGRhdGUiLCJfY2hlY2tEaXNhYmxlZExheWVycyIsIl9vbkxheWVyQ2hhbmdlIiwiX2V4cGFuZElmTm90Q29sbGFwc2VkIiwiYWRkQmFzZUxheWVyIiwiYWRkT3ZlcmxheSIsInJlbW92ZUxheWVyIiwiX2dldExheWVyIiwiZXhwYW5kIiwiX3NlY3Rpb24iLCJhY2NlcHRhYmxlSGVpZ2h0Iiwib2Zmc2V0VG9wIiwiY29sbGFwc2UiLCJzZXRBdHRyaWJ1dGUiLCJzZWN0aW9uIiwiX2V4cGFuZFNhZmVseSIsImxpbmsiLCJfbGF5ZXJzTGluayIsImhyZWYiLCJ0aXRsZSIsImtleWRvd24iLCJrZXlDb2RlIiwiY2xpY2siLCJfYmFzZUxheWVyc0xpc3QiLCJfc2VwYXJhdG9yIiwiX292ZXJsYXlzTGlzdCIsIm92ZXJsYXkiLCJzb3J0Iiwic2V0WkluZGV4IiwiYmFzZUxheWVyc1ByZXNlbnQiLCJvdmVybGF5c1ByZXNlbnQiLCJiYXNlTGF5ZXJzQ291bnQiLCJfYWRkSXRlbSIsImRpc3BsYXkiLCJfY3JlYXRlUmFkaW9FbGVtZW50IiwiY2hlY2tlZCIsInJhZGlvSHRtbCIsInJhZGlvRnJhZ21lbnQiLCJsYWJlbCIsImhhc0xheWVyIiwiaW5wdXQiLCJkZWZhdWx0Q2hlY2tlZCIsImxheWVySWQiLCJfb25JbnB1dENsaWNrIiwiaG9sZGVyIiwiaW5wdXRzIiwiYWRkZWRMYXllcnMiLCJyZW1vdmVkTGF5ZXJzIiwiYWRkTGF5ZXIiLCJkaXNhYmxlZCIsInRoYXQiLCJab29tIiwiem9vbUluVGV4dCIsInpvb21JblRpdGxlIiwiem9vbU91dFRleHQiLCJ6b29tT3V0VGl0bGUiLCJ6b29tTmFtZSIsIl96b29tSW5CdXR0b24iLCJfY3JlYXRlQnV0dG9uIiwiX3pvb21JbiIsIl96b29tT3V0QnV0dG9uIiwiX3pvb21PdXQiLCJfdXBkYXRlRGlzYWJsZWQiLCJfZGlzYWJsZWQiLCJzaGlmdEtleSIsImh0bWwiLCJ6b29tQ29udHJvbCIsIlNjYWxlIiwibWF4V2lkdGgiLCJtZXRyaWMiLCJpbXBlcmlhbCIsIl9hZGRTY2FsZXMiLCJ1cGRhdGVXaGVuSWRsZSIsIl9tU2NhbGUiLCJfaVNjYWxlIiwibWF4TWV0ZXJzIiwiX3VwZGF0ZVNjYWxlcyIsIl91cGRhdGVNZXRyaWMiLCJfdXBkYXRlSW1wZXJpYWwiLCJtZXRlcnMiLCJfZ2V0Um91bmROdW0iLCJfdXBkYXRlU2NhbGUiLCJtYXhGZWV0IiwibWF4TWlsZXMiLCJtaWxlcyIsImZlZXQiLCJ0ZXh0IiwicmF0aW8iLCJwb3cxMCIsInVrcmFpbmlhbkZsYWciLCJBdHRyaWJ1dGlvbiIsInByZWZpeCIsIl9hdHRyaWJ1dGlvbnMiLCJhdHRyaWJ1dGlvbkNvbnRyb2wiLCJnZXRBdHRyaWJ1dGlvbiIsImFkZEF0dHJpYnV0aW9uIiwiX2FkZEF0dHJpYnV0aW9uIiwicmVtb3ZlQXR0cmlidXRpb24iLCJzZXRQcmVmaXgiLCJhdHRyaWJzIiwicHJlZml4QW5kQXR0cmlicyIsImF0dHJpYnV0aW9uIiwiSGFuZGxlciIsIl9lbmFibGVkIiwiYWRkSG9va3MiLCJyZW1vdmVIb29rcyIsIlNUQVJUIiwiRHJhZ2dhYmxlIiwiY2xpY2tUb2xlcmFuY2UiLCJkcmFnU3RhcnRUYXJnZXQiLCJfZWxlbWVudCIsIl9kcmFnU3RhcnRUYXJnZXQiLCJfcHJldmVudE91dGxpbmUiLCJfb25Eb3duIiwiX2RyYWdnaW5nIiwiZmluaXNoRHJhZyIsIndoaWNoIiwiYnV0dG9uIiwiX21vdmluZyIsImZpcnN0Iiwic2l6ZWRQYXJlbnQiLCJfc3RhcnRQb2ludCIsIl9wYXJlbnRTY2FsZSIsIm1vdXNlZXZlbnQiLCJfb25Nb3ZlIiwiX29uVXAiLCJfbGFzdFRhcmdldCIsIlNWR0VsZW1lbnRJbnN0YW5jZSIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IiwiX25ld1BvcyIsIl9sYXN0RXZlbnQiLCJfdXBkYXRlUG9zaXRpb24iLCJub0luZXJ0aWEiLCJmaXJlRHJhZ2VuZCIsImNsaXBQb2x5Z29uIiwiY2xpcHBlZFBvaW50cyIsImVkZ2VzIiwiayIsIl9jb2RlIiwiX2dldEJpdENvZGUiLCJfZ2V0RWRnZUludGVyc2VjdGlvbiIsInBvbHlnb25DZW50ZXIiLCJwMSIsInAyIiwiZiIsImFyZWEiLCJpc0ZsYXQiLCJjZW50cm9pZExhdExuZyIsImFyZWFCb3VuZHMiLCJjZW50cm9pZCIsImxhdGxuZ0NlbnRlciIsImxhdFN1bSIsImxuZ1N1bSIsInNpbXBsaWZ5IiwidG9sZXJhbmNlIiwic3FUb2xlcmFuY2UiLCJfcmVkdWNlUG9pbnRzIiwiX3NpbXBsaWZ5RFAiLCJwb2ludFRvU2VnbWVudERpc3RhbmNlIiwiX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50IiwiY2xvc2VzdFBvaW50T25TZWdtZW50IiwiQXJyYXlDb25zdHJ1Y3RvciIsIlVpbnQ4QXJyYXkiLCJtYXJrZXJzIiwiX3NpbXBsaWZ5RFBTdGVwIiwibmV3UG9pbnRzIiwibWF4U3FEaXN0Iiwic3FEaXN0IiwicmVkdWNlZFBvaW50cyIsInByZXYiLCJfc3FEaXN0IiwiX2xhc3RDb2RlIiwiY2xpcFNlZ21lbnQiLCJ1c2VMYXN0Q29kZSIsImNvZGVBIiwiY29kZUIiLCJjb2RlT3V0IiwibmV3Q29kZSIsImRvdCIsIl9mbGF0IiwicG9seWxpbmVDZW50ZXIiLCJoYWxmRGlzdCIsInNlZ0Rpc3QiLCJkaXN0IiwiTG9uTGF0IiwiTWVyY2F0b3IiLCJSX01JTk9SIiwidG1wIiwiY29uIiwidHMiLCJ0YW4iLCJwaGkiLCJkcGhpIiwiRVBTRzMzOTUiLCJFUFNHNDMyNiIsIlNpbXBsZSIsIkxheWVyIiwicmVtb3ZlRnJvbSIsIl9tYXBUb0FkZCIsImFkZEludGVyYWN0aXZlVGFyZ2V0IiwidGFyZ2V0RWwiLCJyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCIsIl9sYXllckFkZCIsImdldEV2ZW50cyIsImV2ZW50cyIsImJlZm9yZUFkZCIsImVhY2hMYXllciIsIm1ldGhvZCIsIl9hZGRab29tTGltaXQiLCJfdXBkYXRlWm9vbUxldmVscyIsIl9yZW1vdmVab29tTGltaXQiLCJvbGRab29tU3BhbiIsIkxheWVyR3JvdXAiLCJnZXRMYXllcklkIiwiY2xlYXJMYXllcnMiLCJpbnZva2UiLCJtZXRob2ROYW1lIiwiZ2V0TGF5ZXIiLCJnZXRMYXllcnMiLCJ6SW5kZXgiLCJsYXllckdyb3VwIiwiRmVhdHVyZUdyb3VwIiwic2V0U3R5bGUiLCJicmluZ1RvRnJvbnQiLCJicmluZ1RvQmFjayIsImZlYXR1cmVHcm91cCIsIkljb24iLCJwb3B1cEFuY2hvciIsInRvb2x0aXBBbmNob3IiLCJjcm9zc09yaWdpbiIsImNyZWF0ZUljb24iLCJvbGRJY29uIiwiX2NyZWF0ZUljb24iLCJjcmVhdGVTaGFkb3ciLCJfZ2V0SWNvblVybCIsImltZyIsIl9jcmVhdGVJbWciLCJfc2V0SWNvblN0eWxlcyIsInNpemVPcHRpb24iLCJhbmNob3IiLCJzaGFkb3dBbmNob3IiLCJpY29uQW5jaG9yIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsImljb24iLCJJY29uRGVmYXVsdCIsImljb25VcmwiLCJpY29uUmV0aW5hVXJsIiwic2hhZG93VXJsIiwiaWNvblNpemUiLCJzaGFkb3dTaXplIiwiaW1hZ2VQYXRoIiwiX2RldGVjdEljb25QYXRoIiwiX3N0cmlwVXJsIiwic3RyaXAiLCJyZSIsImlkeCIsIm1hdGNoIiwicXVlcnlTZWxlY3RvciIsInN1YnN0cmluZyIsIk1hcmtlckRyYWciLCJtYXJrZXIiLCJfbWFya2VyIiwiX2ljb24iLCJfZHJhZ2dhYmxlIiwiZHJhZ3N0YXJ0IiwiX29uRHJhZ1N0YXJ0IiwicHJlZHJhZyIsIl9vblByZURyYWciLCJkcmFnIiwiX29uRHJhZyIsImRyYWdlbmQiLCJfb25EcmFnRW5kIiwiX2FkanVzdFBhbiIsInNwZWVkIiwiYXV0b1BhblNwZWVkIiwiYXV0b1BhblBhZGRpbmciLCJpY29uUG9zIiwib3JpZ2luIiwicGFuQm91bmRzIiwibW92ZW1lbnQiLCJfcGFuUmVxdWVzdCIsIl9vbGRMYXRMbmciLCJjbG9zZVBvcHVwIiwiYXV0b1BhbiIsInNoYWRvdyIsIl9zaGFkb3ciLCJfbGF0bG5nIiwib2xkTGF0TG5nIiwiTWFya2VyIiwiaW50ZXJhY3RpdmUiLCJrZXlib2FyZCIsInpJbmRleE9mZnNldCIsInJpc2VPbkhvdmVyIiwicmlzZU9mZnNldCIsImF1dG9QYW5PbkZvY3VzIiwiZHJhZ2dhYmxlIiwiX2luaXRJY29uIiwidXBkYXRlIiwiX3JlbW92ZUljb24iLCJfcmVtb3ZlU2hhZG93Iiwidmlld3Jlc2V0Iiwic2V0TGF0TG5nIiwic2V0WkluZGV4T2Zmc2V0IiwiZ2V0SWNvbiIsInNldEljb24iLCJfcG9wdXAiLCJiaW5kUG9wdXAiLCJnZXRFbGVtZW50IiwiX3NldFBvcyIsImNsYXNzVG9BZGQiLCJhZGRJY29uIiwibW91c2VvdmVyIiwiX2JyaW5nVG9Gcm9udCIsIm1vdXNlb3V0IiwiX3Jlc2V0WkluZGV4IiwiX3Bhbk9uRm9jdXMiLCJuZXdTaGFkb3ciLCJhZGRTaGFkb3ciLCJfdXBkYXRlT3BhY2l0eSIsIl9pbml0SW50ZXJhY3Rpb24iLCJfekluZGV4IiwiX3VwZGF0ZVpJbmRleCIsIm9wdCIsImljb25PcHRzIiwiX2dldFBvcHVwQW5jaG9yIiwiX2dldFRvb2x0aXBBbmNob3IiLCJQYXRoIiwic3Ryb2tlIiwiY29sb3IiLCJ3ZWlnaHQiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJkYXNoQXJyYXkiLCJkYXNoT2Zmc2V0IiwiZmlsbCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiZmlsbFJ1bGUiLCJnZXRSZW5kZXJlciIsIl9pbml0UGF0aCIsIl9yZXNldCIsIl9hZGRQYXRoIiwiX3JlbW92ZVBhdGgiLCJyZWRyYXciLCJfdXBkYXRlUGF0aCIsIl91cGRhdGVTdHlsZSIsIl91cGRhdGVCb3VuZHMiLCJfYnJpbmdUb0JhY2siLCJfcGF0aCIsIl9wcm9qZWN0IiwiX2NsaWNrVG9sZXJhbmNlIiwiQ2lyY2xlTWFya2VyIiwicmFkaXVzIiwic2V0UmFkaXVzIiwiZ2V0UmFkaXVzIiwiX3BvaW50IiwicjIiLCJfcmFkaXVzWSIsIl9weEJvdW5kcyIsIl91cGRhdGVDaXJjbGUiLCJfZW1wdHkiLCJfYm91bmRzIiwiX2NvbnRhaW5zUG9pbnQiLCJjaXJjbGVNYXJrZXIiLCJDaXJjbGUiLCJsZWdhY3lPcHRpb25zIiwiX21SYWRpdXMiLCJoYWxmIiwibGF0UiIsImJvdHRvbSIsImxuZ1IiLCJhY29zIiwiY2lyY2xlIiwiUG9seWxpbmUiLCJzbW9vdGhGYWN0b3IiLCJub0NsaXAiLCJfc2V0TGF0TG5ncyIsImdldExhdExuZ3MiLCJfbGF0bG5ncyIsInNldExhdExuZ3MiLCJpc0VtcHR5IiwiY2xvc2VzdExheWVyUG9pbnQiLCJtaW5EaXN0YW5jZSIsIm1pblBvaW50IiwiY2xvc2VzdCIsImpMZW4iLCJfcGFydHMiLCJfZGVmYXVsdFNoYXBlIiwiYWRkTGF0TG5nIiwiX2NvbnZlcnRMYXRMbmdzIiwicmVzdWx0IiwiZmxhdCIsIl9yaW5ncyIsIl9wcm9qZWN0TGF0bG5ncyIsIl9yYXdQeEJvdW5kcyIsInByb2plY3RlZEJvdW5kcyIsInJpbmciLCJfY2xpcFBvaW50cyIsInBhcnRzIiwic2VnbWVudCIsIl9zaW1wbGlmeVBvaW50cyIsIl91cGRhdGVQb2x5IiwicGFydCIsInBvbHlsaW5lIiwiUG9seWdvbiIsInBvcCIsImNsaXBwZWQiLCJwb2x5Z29uIiwiR2VvSlNPTiIsImdlb2pzb24iLCJhZGREYXRhIiwiZmVhdHVyZXMiLCJmZWF0dXJlIiwiZ2VvbWV0cmllcyIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJnZW9tZXRyeVRvTGF5ZXIiLCJhc0ZlYXR1cmUiLCJkZWZhdWx0T3B0aW9ucyIsInJlc2V0U3R5bGUiLCJvbkVhY2hGZWF0dXJlIiwiX3NldExheWVyU3R5bGUiLCJwb2ludFRvTGF5ZXIiLCJfY29vcmRzVG9MYXRMbmciLCJjb29yZHNUb0xhdExuZyIsIl9wb2ludFRvTGF5ZXIiLCJjb29yZHNUb0xhdExuZ3MiLCJnZW9MYXllciIsInByb3BlcnRpZXMiLCJmZWF0dXJlTGF5ZXIiLCJwb2ludFRvTGF5ZXJGbiIsIm1hcmtlcnNJbmhlcml0T3B0aW9ucyIsImxldmVsc0RlZXAiLCJsYXRMbmdUb0Nvb3JkcyIsImxhdExuZ3NUb0Nvb3JkcyIsImdldEZlYXR1cmUiLCJuZXdHZW9tZXRyeSIsIlBvaW50VG9HZW9KU09OIiwidG9HZW9KU09OIiwibXVsdGkiLCJob2xlcyIsInRvTXVsdGlQb2ludCIsImlzR2VvbWV0cnlDb2xsZWN0aW9uIiwianNvbnMiLCJqc29uIiwiZ2VvSlNPTiIsImdlb0pzb24iLCJJbWFnZU92ZXJsYXkiLCJlcnJvck92ZXJsYXlVcmwiLCJ1cmwiLCJfdXJsIiwiX2ltYWdlIiwiX2luaXRJbWFnZSIsInN0eWxlT3B0cyIsInNldFVybCIsInNldEJvdW5kcyIsInpvb21hbmltIiwid2FzRWxlbWVudFN1cHBsaWVkIiwib25zZWxlY3RzdGFydCIsIm9ubW91c2Vtb3ZlIiwib25sb2FkIiwib25lcnJvciIsIl9vdmVybGF5T25FcnJvciIsImltYWdlIiwiZXJyb3JVcmwiLCJpbWFnZU92ZXJsYXkiLCJWaWRlb092ZXJsYXkiLCJhdXRvcGxheSIsImxvb3AiLCJrZWVwQXNwZWN0UmF0aW8iLCJtdXRlZCIsInBsYXlzSW5saW5lIiwidmlkIiwib25sb2FkZWRkYXRhIiwic291cmNlRWxlbWVudHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInNvdXJjZXMiLCJzb3VyY2UiLCJ2aWRlb092ZXJsYXkiLCJ2aWRlbyIsIlNWR092ZXJsYXkiLCJzdmdPdmVybGF5IiwiRGl2T3ZlcmxheSIsImNvbnRlbnQiLCJfc291cmNlIiwiX2NvbnRlbnQiLCJvcGVuT24iLCJjbG9zZSIsInRvZ2dsZSIsIl9wcmVwYXJlT3BlbiIsIl9yZW1vdmVUaW1lb3V0IiwiZ2V0Q29udGVudCIsInNldENvbnRlbnQiLCJ2aXNpYmlsaXR5IiwiX3VwZGF0ZUNvbnRlbnQiLCJfdXBkYXRlTGF5b3V0IiwiaXNPcGVuIiwibm9kZSIsIl9jb250ZW50Tm9kZSIsImhhc0NoaWxkTm9kZXMiLCJfZ2V0QW5jaG9yIiwiX2NvbnRhaW5lckJvdHRvbSIsIl9jb250YWluZXJMZWZ0IiwiX2NvbnRhaW5lcldpZHRoIiwiX2luaXRPdmVybGF5IiwiT3ZlcmxheUNsYXNzIiwib2xkIiwiUG9wdXAiLCJtaW5XaWR0aCIsIm1heEhlaWdodCIsImF1dG9QYW5QYWRkaW5nVG9wTGVmdCIsImF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQiLCJrZWVwSW5WaWV3IiwiY2xvc2VCdXR0b24iLCJhdXRvQ2xvc2UiLCJjbG9zZU9uRXNjYXBlS2V5IiwicG9wdXAiLCJjbG9zZU9uQ2xpY2siLCJjbG9zZVBvcHVwT25DbGljayIsInByZWNsaWNrIiwibW92ZWVuZCIsIndyYXBwZXIiLCJfd3JhcHBlciIsIl90aXBDb250YWluZXIiLCJfdGlwIiwiX2Nsb3NlQnV0dG9uIiwid2hpdGVTcGFjZSIsInNjcm9sbGVkQ2xhc3MiLCJfYXV0b3Bhbm5pbmciLCJtYXJnaW5Cb3R0b20iLCJjb250YWluZXJIZWlnaHQiLCJjb250YWluZXJXaWR0aCIsImxheWVyUG9zIiwiY29udGFpbmVyUG9zIiwib3BlblBvcHVwIiwiX3BvcHVwSGFuZGxlcnNBZGRlZCIsIl9vcGVuUG9wdXAiLCJrZXlwcmVzcyIsIl9vbktleVByZXNzIiwibW92ZSIsIl9tb3ZlUG9wdXAiLCJ1bmJpbmRQb3B1cCIsInRvZ2dsZVBvcHVwIiwiaXNQb3B1cE9wZW4iLCJzZXRQb3B1cENvbnRlbnQiLCJnZXRQb3B1cCIsIlRvb2x0aXAiLCJkaXJlY3Rpb24iLCJwZXJtYW5lbnQiLCJzdGlja3kiLCJ0b29sdGlwIiwiX3NldFBvc2l0aW9uIiwic3ViWCIsInN1YlkiLCJ0b29sdGlwUG9pbnQiLCJ0b29sdGlwV2lkdGgiLCJ0b29sdGlwSGVpZ2h0Iiwib3BlblRvb2x0aXAiLCJjbG9zZVRvb2x0aXAiLCJiaW5kVG9vbHRpcCIsIl90b29sdGlwIiwiaXNUb29sdGlwT3BlbiIsInVuYmluZFRvb2x0aXAiLCJfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMiLCJfdG9vbHRpcEhhbmRsZXJzQWRkZWQiLCJfbW92ZVRvb2x0aXAiLCJfb3BlblRvb2x0aXAiLCJfYWRkRm9jdXNMaXN0ZW5lcnMiLCJtb3VzZW1vdmUiLCJfc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllciIsInRvZ2dsZVRvb2x0aXAiLCJzZXRUb29sdGlwQ29udGVudCIsImdldFRvb2x0aXAiLCJfYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyIiwibW92aW5nIiwiX29wZW5PbmNlRmxhZyIsIkRpdkljb24iLCJiZ1BvcyIsIkVsZW1lbnQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJkaXZJY29uIiwiRGVmYXVsdCIsIkdyaWRMYXllciIsInRpbGVTaXplIiwidXBkYXRlV2hlblpvb21pbmciLCJ1cGRhdGVJbnRlcnZhbCIsIm1heE5hdGl2ZVpvb20iLCJtaW5OYXRpdmVab29tIiwibm9XcmFwIiwia2VlcEJ1ZmZlciIsIl9sZXZlbHMiLCJfdGlsZXMiLCJfcmVtb3ZlQWxsVGlsZXMiLCJfdGlsZVpvb20iLCJfc2V0QXV0b1pJbmRleCIsImlzTG9hZGluZyIsIl9sb2FkaW5nIiwidGlsZVpvb20iLCJfY2xhbXBab29tIiwiX3VwZGF0ZUxldmVscyIsInZpZXdwcmVyZXNldCIsIl9pbnZhbGlkYXRlQWxsIiwiY3JlYXRlVGlsZSIsImdldFRpbGVTaXplIiwiY29tcGFyZSIsImNoaWxkcmVuIiwiZWRnZVpJbmRleCIsImlzRmluaXRlIiwibmV4dEZyYW1lIiwid2lsbFBydW5lIiwidGlsZSIsImN1cnJlbnQiLCJsb2FkZWQiLCJmYWRlIiwiYWN0aXZlIiwiX29uT3BhcXVlVGlsZSIsIl9ub1BydW5lIiwiX3BydW5lVGlsZXMiLCJfZmFkZUZyYW1lIiwiTnVtYmVyIiwiX29uVXBkYXRlTGV2ZWwiLCJfcmVtb3ZlVGlsZXNBdFpvb20iLCJfb25SZW1vdmVMZXZlbCIsImxldmVsIiwiX3NldFpvb21UcmFuc2Zvcm0iLCJfb25DcmVhdGVMZXZlbCIsIl9sZXZlbCIsInJldGFpbiIsIl9yZXRhaW5QYXJlbnQiLCJfcmV0YWluQ2hpbGRyZW4iLCJfcmVtb3ZlVGlsZSIsIngyIiwieTIiLCJ6MiIsImNvb3JkczIiLCJfdGlsZUNvb3Jkc1RvS2V5IiwiYW5pbWF0aW5nIiwiX3NldFZpZXciLCJub1BydW5lIiwidGlsZVpvb21DaGFuZ2VkIiwiX2Fib3J0TG9hZGluZyIsIl9yZXNldEdyaWQiLCJfc2V0Wm9vbVRyYW5zZm9ybXMiLCJ0cmFuc2xhdGUiLCJfdGlsZVNpemUiLCJfZ2xvYmFsVGlsZVJhbmdlIiwiX3B4Qm91bmRzVG9UaWxlUmFuZ2UiLCJfd3JhcFgiLCJfd3JhcFkiLCJfZ2V0VGlsZWRQaXhlbEJvdW5kcyIsIm1hcFpvb20iLCJoYWxmU2l6ZSIsInRpbGVSYW5nZSIsInRpbGVDZW50ZXIiLCJxdWV1ZSIsIm5vUHJ1bmVSYW5nZSIsIl9pc1ZhbGlkVGlsZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIl9hZGRUaWxlIiwidGlsZUJvdW5kcyIsIl90aWxlQ29vcmRzVG9Cb3VuZHMiLCJfa2V5VG9Cb3VuZHMiLCJfa2V5VG9UaWxlQ29vcmRzIiwiX3RpbGVDb29yZHNUb053U2UiLCJud1BvaW50Iiwic2VQb2ludCIsImJwIiwiX2luaXRUaWxlIiwidGlsZVBvcyIsIl9nZXRUaWxlUG9zIiwiX3dyYXBDb29yZHMiLCJfdGlsZVJlYWR5IiwiX25vVGlsZXNUb0xvYWQiLCJuZXdDb29yZHMiLCJncmlkTGF5ZXIiLCJUaWxlTGF5ZXIiLCJzdWJkb21haW5zIiwiZXJyb3JUaWxlVXJsIiwiem9vbU9mZnNldCIsInRtcyIsInpvb21SZXZlcnNlIiwiZGV0ZWN0UmV0aW5hIiwicmVmZXJyZXJQb2xpY3kiLCJfb25UaWxlUmVtb3ZlIiwibm9SZWRyYXciLCJkb25lIiwiX3RpbGVPbkxvYWQiLCJfdGlsZU9uRXJyb3IiLCJnZXRUaWxlVXJsIiwiX2dldFN1YmRvbWFpbiIsIl9nZXRab29tRm9yVXJsIiwiaW52ZXJ0ZWRZIiwiZ2V0QXR0cmlidXRlIiwidGlsZVBvaW50IiwiY29tcGxldGUiLCJ0aWxlTGF5ZXIiLCJUaWxlTGF5ZXJXTVMiLCJkZWZhdWx0V21zUGFyYW1zIiwic2VydmljZSIsInJlcXVlc3QiLCJzdHlsZXMiLCJmb3JtYXQiLCJ0cmFuc3BhcmVudCIsInZlcnNpb24iLCJ3bXNQYXJhbXMiLCJyZWFsUmV0aW5hIiwiX2NycyIsIl93bXNWZXJzaW9uIiwicGFyc2VGbG9hdCIsInByb2plY3Rpb25LZXkiLCJiYm94Iiwic2V0UGFyYW1zIiwidGlsZUxheWVyV01TIiwiV01TIiwid21zIiwiUmVuZGVyZXIiLCJfdXBkYXRlUGF0aHMiLCJfZGVzdHJveUNvbnRhaW5lciIsIl9vblpvb20iLCJ6b29tZW5kIiwiX29uWm9vbUVuZCIsIl9vbkFuaW1ab29tIiwiX3VwZGF0ZVRyYW5zZm9ybSIsImN1cnJlbnRDZW50ZXJQb2ludCIsIl9jZW50ZXIiLCJ0b3BMZWZ0T2Zmc2V0IiwiQ2FudmFzIiwiX29uVmlld1ByZVJlc2V0IiwiX3Bvc3Rwb25lVXBkYXRlUGF0aHMiLCJfZHJhdyIsIl9vbk1vdXNlTW92ZSIsIl9vbkNsaWNrIiwiX2hhbmRsZU1vdXNlT3V0IiwiX2N0eCIsIl9yZWRyYXdSZXF1ZXN0IiwiX3JlZHJhd0JvdW5kcyIsIl9yZWRyYXciLCJtIiwiX3VwZGF0ZURhc2hBcnJheSIsIm9yZGVyIiwiX29yZGVyIiwiX2RyYXdMYXN0IiwibmV4dCIsIl9kcmF3Rmlyc3QiLCJfcmVxdWVzdFJlZHJhdyIsIl9leHRlbmRSZWRyYXdCb3VuZHMiLCJkYXNoVmFsdWUiLCJfZGFzaEFycmF5IiwiX2NsZWFyIiwiY2xlYXJSZWN0Iiwic2F2ZSIsInJlc3RvcmUiLCJiZWdpblBhdGgiLCJjbGlwIiwiX2RyYXdpbmciLCJjbG9zZVBhdGgiLCJfZmlsbFN0cm9rZSIsImFyYyIsImdsb2JhbEFscGhhIiwiZmlsbFN0eWxlIiwic2V0TGluZURhc2giLCJsaW5lV2lkdGgiLCJzdHJva2VTdHlsZSIsImNsaWNrZWRMYXllciIsIl9maXJlRXZlbnQiLCJfaGFuZGxlTW91c2VIb3ZlciIsIl9ob3ZlcmVkTGF5ZXIiLCJfbW91c2VIb3ZlclRocm90dGxlZCIsImNhbmRpZGF0ZUhvdmVyZWRMYXllciIsInZtbENyZWF0ZSIsIm5hbWVzcGFjZXMiLCJ2bWxNaXhpbiIsImNvb3Jkc2l6ZSIsIl9zdHJva2UiLCJfZmlsbCIsInN0cm9rZWQiLCJmaWxsZWQiLCJkYXNoU3R5bGUiLCJlbmRjYXAiLCJqb2luc3R5bGUiLCJfc2V0UGF0aCIsIlNWRyIsIl9yb290R3JvdXAiLCJfc3ZnU2l6ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIl9nZXRQYW5lUmVuZGVyZXIiLCJfY3JlYXRlUmVuZGVyZXIiLCJwcmVmZXJDYW52YXMiLCJSZWN0YW5nbGUiLCJfYm91bmRzVG9MYXRMbmdzIiwicmVjdGFuZ2xlIiwiQm94Wm9vbSIsIl9wYW5lIiwib3ZlcmxheVBhbmUiLCJfcmVzZXRTdGF0ZVRpbWVvdXQiLCJfZGVzdHJveSIsIl9vbk1vdXNlRG93biIsIl9yZXNldFN0YXRlIiwiX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlIiwiY29udGV4dG1lbnUiLCJtb3VzZXVwIiwiX29uTW91c2VVcCIsIl9vbktleURvd24iLCJfYm94IiwiX2ZpbmlzaCIsImJveFpvb21Cb3VuZHMiLCJkb3VibGVDbGlja1pvb20iLCJEb3VibGVDbGlja1pvb20iLCJfb25Eb3VibGVDbGljayIsImluZXJ0aWEiLCJpbmVydGlhRGVjZWxlcmF0aW9uIiwiaW5lcnRpYU1heFNwZWVkIiwid29ybGRDb3B5SnVtcCIsIm1heEJvdW5kc1Zpc2Nvc2l0eSIsIkRyYWciLCJfb25QcmVEcmFnTGltaXQiLCJfb25QcmVEcmFnV3JhcCIsIl9wb3NpdGlvbnMiLCJfdGltZXMiLCJfb2Zmc2V0TGltaXQiLCJfdmlzY29zaXR5IiwiX2xhc3RUaW1lIiwiX2xhc3RQb3MiLCJfYWJzUG9zIiwiX3BydW5lUG9zaXRpb25zIiwic2hpZnQiLCJweENlbnRlciIsInB4V29ybGRDZW50ZXIiLCJfaW5pdGlhbFdvcmxkT2Zmc2V0IiwiX3dvcmxkV2lkdGgiLCJfdmlzY291c0xpbWl0IiwidGhyZXNob2xkIiwibGltaXQiLCJ3b3JsZFdpZHRoIiwiaGFsZldpZHRoIiwibmV3WDEiLCJuZXdYMiIsIm5ld1giLCJlYXNlIiwic3BlZWRWZWN0b3IiLCJsaW1pdGVkU3BlZWQiLCJsaW1pdGVkU3BlZWRWZWN0b3IiLCJkZWNlbGVyYXRpb25EdXJhdGlvbiIsImtleWJvYXJkUGFuRGVsdGEiLCJLZXlib2FyZCIsImtleUNvZGVzIiwiZG93biIsInVwIiwiX3NldFBhbkRlbHRhIiwiX3NldFpvb21EZWx0YSIsIl9vbkZvY3VzIiwiYmx1ciIsIl9vbkJsdXIiLCJtb3VzZWRvd24iLCJfYWRkSG9va3MiLCJfcmVtb3ZlSG9va3MiLCJfZm9jdXNlZCIsImRvY0VsIiwic2Nyb2xsVG8iLCJwYW5EZWx0YSIsImtleXMiLCJfcGFuS2V5cyIsImNvZGVzIiwiX3pvb21LZXlzIiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJuZXdMYXRMbmciLCJzY3JvbGxXaGVlbFpvb20iLCJ3aGVlbERlYm91bmNlVGltZSIsIndoZWVsUHhQZXJab29tTGV2ZWwiLCJTY3JvbGxXaGVlbFpvb20iLCJfb25XaGVlbFNjcm9sbCIsIl9kZWx0YSIsImRlYm91bmNlIiwiX2xhc3RNb3VzZVBvcyIsIl90aW1lciIsIl9wZXJmb3JtWm9vbSIsImQyIiwiZDMiLCJkNCIsInRhcEhvbGREZWxheSIsInRhcEhvbGQiLCJ0YXBUb2xlcmFuY2UiLCJUYXBIb2xkIiwiX2hvbGRUaW1lb3V0IiwiX2NhbmNlbCIsIl9pc1RhcFZhbGlkIiwiX2NhbmNlbENsaWNrUHJldmVudCIsIl9zaW11bGF0ZUV2ZW50IiwiY2FuY2VsQ2xpY2tQcmV2ZW50Iiwic2ltdWxhdGVkRXZlbnQiLCJNb3VzZUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ2aWV3IiwiZGlzcGF0Y2hFdmVudCIsInRvdWNoWm9vbSIsImJvdW5jZUF0Wm9vbUxpbWl0cyIsIlRvdWNoWm9vbSIsIl9vblRvdWNoU3RhcnQiLCJfem9vbWluZyIsIl9jZW50ZXJQb2ludCIsIl9zdGFydExhdExuZyIsIl9waW5jaFN0YXJ0TGF0TG5nIiwiX3N0YXJ0RGlzdCIsIl9zdGFydFpvb20iLCJfb25Ub3VjaE1vdmUiLCJfb25Ub3VjaEVuZCIsIl9hbmltUmVxdWVzdCIsIm1vdmVGbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///459\n")},450:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Jx: () => (/* binding */ cubicOut),\n/* harmony export */   sn: () => (/* reexport safe */ _internal_index_js__WEBPACK_IMPORTED_MODULE_0__.D_O)\n/* harmony export */ });\n/* unused harmony exports backInOut, backIn, backOut, bounceOut, bounceInOut, bounceIn, circInOut, circIn, circOut, cubicInOut, cubicIn, elasticInOut, elasticIn, elasticOut, expoInOut, expoIn, expoOut, quadInOut, quadIn, quadOut, quartInOut, quartIn, quartOut, quintInOut, quintIn, quintOut, sineInOut, sineIn, sineOut */\n/* harmony import */ var _internal_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(267);\n/*\nAdapted from https://github.com/mattdesl\nDistributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md\n*/\n\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction backInOut(t) {\n  const s = 1.70158 * 1.525;\n  if ((t *= 2) < 1) return 0.5 * (t * t * ((s + 1) * t - s));\n  return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction backIn(t) {\n  const s = 1.70158;\n  return t * t * ((s + 1) * t - s);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction backOut(t) {\n  const s = 1.70158;\n  return --t * t * ((s + 1) * t + s) + 1;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction bounceOut(t) {\n  const a = 4.0 / 11.0;\n  const b = 8.0 / 11.0;\n  const c = 9.0 / 10.0;\n  const ca = 4356.0 / 361.0;\n  const cb = 35442.0 / 1805.0;\n  const cc = 16061.0 / 1805.0;\n  const t2 = t * t;\n  return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction bounceInOut(t) {\n  return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction bounceIn(t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction circInOut(t) {\n  if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1);\n  return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction circIn(t) {\n  return 1.0 - Math.sqrt(1.0 - t * t);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction circOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction cubicInOut(t) {\n  return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction cubicIn(t) {\n  return t * t * t;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction cubicOut(t) {\n  const f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction elasticInOut(t) {\n  return t < 0.5 ? 0.5 * Math.sin(+13.0 * Math.PI / 2 * 2.0 * t) * Math.pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * Math.sin(-13.0 * Math.PI / 2 * (2.0 * t - 1.0 + 1.0)) * Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction elasticIn(t) {\n  return Math.sin(13.0 * t * Math.PI / 2) * Math.pow(2.0, 10.0 * (t - 1.0));\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction elasticOut(t) {\n  return Math.sin(-13.0 * (t + 1.0) * Math.PI / 2) * Math.pow(2.0, -10.0 * t) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction expoInOut(t) {\n  return t === 0.0 || t === 1.0 ? t : t < 0.5 ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0) : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction expoIn(t) {\n  return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction expoOut(t) {\n  return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quadInOut(t) {\n  t /= 0.5;\n  if (t < 1) return 0.5 * t * t;\n  t--;\n  return -0.5 * (t * (t - 2) - 1);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quadIn(t) {\n  return t * t;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quadOut(t) {\n  return -t * (t - 2.0);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quartInOut(t) {\n  return t < 0.5 ? +8.0 * Math.pow(t, 4.0) : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quartIn(t) {\n  return Math.pow(t, 4.0);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quartOut(t) {\n  return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quintInOut(t) {\n  if ((t *= 2) < 1) return 0.5 * t * t * t * t * t;\n  return 0.5 * ((t -= 2) * t * t * t * t + 2);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quintIn(t) {\n  return t * t * t * t * t;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction quintOut(t) {\n  return --t * t * t * t * t + 1;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction sineInOut(t) {\n  return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction sineIn(t) {\n  const v = Math.cos(t * Math.PI * 0.5);\n  if (Math.abs(v) < 1e-14) return 1;else return 1 - v;\n}\n\n/**\n * https://svelte.dev/docs/svelte-easing\n * @param {number} t\n * @returns {number}\n */\nfunction sineOut(t) {\n  return Math.sin(t * Math.PI / 2);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsR0FBR2UsSUFBSSxDQUFDVyxFQUFFLEdBQUcsR0FBRyxDQUFDO0VBQ3JDLElBQUlYLElBQUksQ0FBQzhCLEdBQUcsQ0FBQ0QsQ0FBQyxDQUFDLEdBQUcsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEtBQzdCLE9BQU8sQ0FBQyxHQUFHQSxDQUFDO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTRSxPQUFPQSxDQUFDOUMsQ0FBQyxFQUFFO0VBQzFCLE9BQU9lLElBQUksQ0FBQ1UsR0FBRyxDQUFFekIsQ0FBQyxHQUFHZSxJQUFJLENBQUNXLEVBQUUsR0FBSSxDQUFDLENBQUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2Vhc2luZy9pbmRleC5qcz8zYzBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5BZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsXG5EaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZWFzZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuKi9cbmV4cG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4LmpzJztcblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSk7XG5cdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbih0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRyZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuXHRjb25zdCBzID0gMS43MDE1ODtcblx0cmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VPdXQodCkge1xuXHRjb25zdCBhID0gNC4wIC8gMTEuMDtcblx0Y29uc3QgYiA9IDguMCAvIDExLjA7XG5cdGNvbnN0IGMgPSA5LjAgLyAxMC4wO1xuXHRjb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuXHRjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG5cdGNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcblx0Y29uc3QgdDIgPSB0ICogdDtcblx0cmV0dXJuIHQgPCBhXG5cdFx0PyA3LjU2MjUgKiB0MlxuXHRcdDogdCA8IGJcblx0XHQ/IDkuMDc1ICogdDIgLSA5LjkgKiB0ICsgMy40XG5cdFx0OiB0IDwgY1xuXHRcdD8gY2EgKiB0MiAtIGNiICogdCArIGNjXG5cdFx0OiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQgKiAyLjApKSA6IDAuNSAqIGJvdW5jZU91dCh0ICogMi4wIC0gMS4wKSArIDAuNTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcblx0cmV0dXJuIDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0KTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNJbk91dCh0KSB7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG5cdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjSW4odCkge1xuXHRyZXR1cm4gMS4wIC0gTWF0aC5zcXJ0KDEuMCAtIHQgKiB0KTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcblx0cmV0dXJuIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcblx0Y29uc3QgZiA9IHQgLSAxLjA7XG5cdHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNVxuXHRcdD8gMC41ICogTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqIE1hdGgucG93KDIuMCwgMTAuMCAqICgyLjAgKiB0IC0gMS4wKSlcblx0XHQ6IDAuNSAqXG5cdFx0XHRcdE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG5cdFx0XHRcdE1hdGgucG93KDIuMCwgLTEwLjAgKiAoMi4wICogdCAtIDEuMCkpICtcblx0XHRcdFx0MS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcblx0cmV0dXJuIE1hdGguc2luKCgxMy4wICogdCAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigoLTEzLjAgKiAodCArIDEuMCkgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpICsgMS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCB8fCB0ID09PSAxLjBcblx0XHQ/IHRcblx0XHQ6IHQgPCAwLjVcblx0XHQ/ICswLjUgKiBNYXRoLnBvdygyLjAsIDIwLjAgKiB0IC0gMTAuMClcblx0XHQ6IC0wLjUgKiBNYXRoLnBvdygyLjAsIDEwLjAgLSB0ICogMjAuMCkgKyAxLjA7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvSW4odCkge1xuXHRyZXR1cm4gdCA9PT0gMC4wID8gdCA6IE1hdGgucG93KDIuMCwgMTAuMCAqICh0IC0gMS4wKSk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvT3V0KHQpIHtcblx0cmV0dXJuIHQgPT09IDEuMCA/IHQgOiAxLjAgLSBNYXRoLnBvdygyLjAsIC0xMC4wICogdCk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW5PdXQodCkge1xuXHR0IC89IDAuNTtcblx0aWYgKHQgPCAxKSByZXR1cm4gMC41ICogdCAqIHQ7XG5cdHQtLTtcblx0cmV0dXJuIC0wLjUgKiAodCAqICh0IC0gMikgLSAxKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRJbih0KSB7XG5cdHJldHVybiB0ICogdDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRPdXQodCkge1xuXHRyZXR1cm4gLXQgKiAodCAtIDIuMCk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFydEluT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyArOC4wICogTWF0aC5wb3codCwgNC4wKSA6IC04LjAgKiBNYXRoLnBvdyh0IC0gMS4wLCA0LjApICsgMS4wO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhcnRJbih0KSB7XG5cdHJldHVybiBNYXRoLnBvdyh0LCA0LjApO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhcnRPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5wb3codCAtIDEuMCwgMy4wKSAqICgxLjAgLSB0KSArIDEuMDtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1aW50SW5PdXQodCkge1xuXHRpZiAoKHQgKj0gMikgPCAxKSByZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG5cdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWludEluKHQpIHtcblx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1lYXNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpbnRPdXQodCkge1xuXHRyZXR1cm4gLS10ICogdCAqIHQgKiB0ICogdCArIDE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5lSW5PdXQodCkge1xuXHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcbn1cblxuLyoqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbmVJbih0KSB7XG5cdGNvbnN0IHYgPSBNYXRoLmNvcyh0ICogTWF0aC5QSSAqIDAuNSk7XG5cdGlmIChNYXRoLmFicyh2KSA8IDFlLTE0KSByZXR1cm4gMTtcblx0ZWxzZSByZXR1cm4gMSAtIHY7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5lT3V0KHQpIHtcblx0cmV0dXJuIE1hdGguc2luKCh0ICogTWF0aC5QSSkgLyAyKTtcbn1cbiJdLCJuYW1lcyI6WyJpZGVudGl0eSIsImxpbmVhciIsImJhY2tJbk91dCIsInQiLCJzIiwiYmFja0luIiwiYmFja091dCIsImJvdW5jZU91dCIsImEiLCJiIiwiYyIsImNhIiwiY2IiLCJjYyIsInQyIiwiYm91bmNlSW5PdXQiLCJib3VuY2VJbiIsImNpcmNJbk91dCIsIk1hdGgiLCJzcXJ0IiwiY2lyY0luIiwiY2lyY091dCIsImN1YmljSW5PdXQiLCJwb3ciLCJjdWJpY0luIiwiY3ViaWNPdXQiLCJmIiwiZWxhc3RpY0luT3V0Iiwic2luIiwiUEkiLCJlbGFzdGljSW4iLCJlbGFzdGljT3V0IiwiZXhwb0luT3V0IiwiZXhwb0luIiwiZXhwb091dCIsInF1YWRJbk91dCIsInF1YWRJbiIsInF1YWRPdXQiLCJxdWFydEluT3V0IiwicXVhcnRJbiIsInF1YXJ0T3V0IiwicXVpbnRJbk91dCIsInF1aW50SW4iLCJxdWludE91dCIsInNpbmVJbk91dCIsImNvcyIsInNpbmVJbiIsInYiLCJhYnMiLCJzaW5lT3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///450\n")},419:()=>{"use strict";eval("\n;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/version.js\n// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nconst VERSION = '4.2.18';\nconst PUBLIC_VERSION = '4';\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/disclose-version/index.js\n\nif (typeof window !== 'undefined')\n  // @ts-ignore\n  (window.__svelte || (window.__svelte = {\n    v: new Set()\n  })).v.add(PUBLIC_VERSION);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTUEsT0FBTyxHQUFHLFFBQVE7QUFDeEIsTUFBTUMsY0FBYyxHQUFHLEdBQUcsQzs7QUNUMkI7QUFFNUQsSUFBSSxPQUFPQyxNQUFNLEtBQUssV0FBVztFQUNoQztFQUNBLENBQUNBLE1BQU0sQ0FBQ0MsUUFBUSxLQUFLRCxNQUFNLENBQUNDLFFBQVEsR0FBRztJQUFFQyxDQUFDLEVBQUUsSUFBSUMsR0FBRyxDQUFDO0VBQUUsQ0FBQyxDQUFDLEVBQUVELENBQUMsQ0FBQ0UsR0FBRyxDQUFDTCxjQUFjLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zaGFyZWQvdmVyc2lvbi5qcz9mN2JlIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZGlzY2xvc2UtdmVyc2lvbi9pbmRleC5qcz8xZWMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWNvbXBpbGVyI3N2ZWx0ZS12ZXJzaW9uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc0LjIuMTgnO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzQnO1xuIiwiaW1wb3J0IHsgUFVCTElDX1ZFUlNJT04gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdmVyc2lvbi5qcyc7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcblx0Ly8gQHRzLWlnbm9yZVxuXHQod2luZG93Ll9fc3ZlbHRlIHx8ICh3aW5kb3cuX19zdmVsdGUgPSB7IHY6IG5ldyBTZXQoKSB9KSkudi5hZGQoUFVCTElDX1ZFUlNJT04pO1xuIl0sIm5hbWVzIjpbIlZFUlNJT04iLCJQVUJMSUNfVkVSU0lPTiIsIndpbmRvdyIsIl9fc3ZlbHRlIiwidiIsIlNldCIsImFkZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///419\n")},267:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  r7T: () => (/* reexport */ SvelteComponent),\n  Jk$: () => (/* reexport */ add_flush_callback),\n  Dti: () => (/* reexport */ scheduler_add_render_callback),\n  BCw: () => (/* reexport */ dom_append),\n  kZQ: () => (/* reexport */ append_styles),\n  kpz: () => (/* reexport */ utils_assign),\n  CFu: () => (/* reexport */ dom_attr),\n  oIE: () => (/* reexport */ bind),\n  Dnk: () => (/* reexport */ binding_callbacks),\n  GYV: () => (/* reexport */ transitions_check_outros),\n  j0C: () => (/* reexport */ component_subscribe),\n  N0i: () => (/* reexport */ create_component),\n  b7f: () => (/* reexport */ create_in_transition),\n  CUz: () => (/* reexport */ create_out_transition),\n  Of3: () => (/* reexport */ create_slot),\n  n_k: () => (/* reexport */ destroy_block),\n  Hbl: () => (/* reexport */ destroy_component),\n  ppq: () => (/* reexport */ destroy_each),\n  YoD: () => (/* reexport */ dom_detach),\n  ND4: () => (/* reexport */ dom_element),\n  Iex: () => (/* reexport */ empty),\n  rv_: () => (/* reexport */ each_ensure_array_like),\n  i32: () => (/* reexport */ get_all_dirty_from_scope),\n  sWk: () => (/* reexport */ get_slot_changes),\n  HN9: () => (/* reexport */ get_spread_update),\n  V44: () => (/* reexport */ transitions_group_outros),\n  D_O: () => (/* reexport */ identity),\n  TsN: () => (/* reexport */ init),\n  Yry: () => (/* reexport */ dom_insert),\n  Qk1: () => (/* reexport */ utils_is_function),\n  KTR: () => (/* reexport */ dom_listen),\n  HWo: () => (/* reexport */ loop_loop),\n  wSR: () => (/* reexport */ mount_component),\n  lQ1: () => (/* reexport */ utils_noop),\n  tB5: () => (/* reexport */ environment_now),\n  oEI: () => (/* reexport */ null_to_empty),\n  XP4: () => (/* reexport */ outro_and_destroy_block),\n  oOW: () => (/* reexport */ utils_run_all),\n  jXN: () => (/* reexport */ safe_not_equal),\n  iQh: () => (/* reexport */ set_data),\n  hgi: () => (/* reexport */ set_style),\n  MyT: () => (/* reexport */ set_svg_attributes),\n  xem: () => (/* reexport */ space),\n  AE: () => (/* reexport */ split_css_unit),\n  mq_: () => (/* reexport */ src_url_equal),\n  QQy: () => (/* reexport */ svg_element),\n  Qq7: () => (/* reexport */ dom_text),\n  c7F: () => (/* reexport */ transitions_transition_in),\n  Tn8: () => (/* reexport */ transitions_transition_out),\n  l7s: () => (/* reexport */ update_keyed_each),\n  nkG: () => (/* reexport */ update_slot_base)\n});\n\n// UNUSED EXPORTS: HtmlTag, HtmlTagHydration, ResizeObserverSingleton, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_iframe_resize_listener, add_location, add_styles, add_transform, afterUpdate, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, attr_dev, attribute_to_object, beforeUpdate, blank_object, bubble, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_custom_element, create_ssr_component, current_component, custom_event, dataset_dev, debug, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element_is, end_hydrating, ensure_array_like_dev, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_spread_object, get_store_value, get_svelte_dataset, globals, handle_promise, hasContext, has_prop, head_selector, init_binding_group, init_binding_group_dynamic, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_promise, is_void, listen_dev, loop_guard, merge_ssr_styles, missing_component, not_equal, object_without_properties, onDestroy, onMount, once, prevent_default, prop_dev, query_selector_all, raf, resize_observer_border_box, resize_observer_content_box, resize_observer_device_pixel_content_box, run, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, spread, srcset_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, stringify_spread, subscribe, tick, time_ranges_to_array, to_number, toggle_class, trusted, update_await_block_branch, update_slot, validate_component, validate_dynamic_element, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr\n\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/utils.js\n/** @returns {void} */\nfunction utils_noop() {}\nconst identity = x => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nfunction utils_assign(tar, src) {\n  // @ts-ignore\n  for (const k in src) tar[k] = src[k];\n  return /** @type {T & S} */tar;\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nfunction utils_is_promise(value) {\n  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof ( /** @type {any} */value.then) === 'function';\n}\n\n/** @returns {void} */\nfunction add_location(element, file, line, column, char) {\n  element.__svelte_meta = {\n    loc: {\n      file,\n      line,\n      column,\n      char\n    }\n  };\n}\nfunction run(fn) {\n  return fn();\n}\nfunction utils_blank_object() {\n  return Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nfunction utils_run_all(fns) {\n  fns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nfunction utils_is_function(thing) {\n  return typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';\n}\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n  if (element_src === url) return true;\n  if (!src_url_equal_anchor) {\n    src_url_equal_anchor = document.createElement('a');\n  }\n  // This is actually faster than doing URL(..).href\n  src_url_equal_anchor.href = url;\n  return element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n  return srcset.split(',').map(src => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element_srcset, srcset) {\n  const element_urls = split_srcset(element_srcset.srcset);\n  const urls = split_srcset(srcset || '');\n  return urls.length === element_urls.length && urls.every(([url, width], i) => width === element_urls[i][1] && (\n  // We need to test both ways because Vite will create an a full URL with\n  // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n  // relative URLs inside srcset are not automatically resolved to absolute URLs by\n  // browsers (in contrast to img.src). This means both SSR and DOM code could\n  // contain relative or absolute URLs.\n  src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0])));\n}\n\n/** @returns {boolean} */\nfunction not_equal(a, b) {\n  return a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nfunction validate_store(store, name) {\n  if (store != null && typeof store.subscribe !== 'function') {\n    throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n  }\n}\nfunction subscribe(store, ...callbacks) {\n  if (store == null) {\n    for (const callback of callbacks) {\n      callback(undefined);\n    }\n    return utils_noop;\n  }\n  const unsub = store.subscribe(...callbacks);\n  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nfunction get_store_value(store) {\n  let value;\n  subscribe(store, _ => value = _)();\n  return value;\n}\n\n/** @returns {void} */\nfunction component_subscribe(component, store, callback) {\n  component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? utils_assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === undefined) {\n      return lets;\n    }\n    if (typeof lets === 'object') {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\n\n/** @returns {void} */\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\n\n/** @returns {void} */\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n  const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n  update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\n\n/** @returns {{}} */\nfunction exclude_internal_props(props) {\n  const result = {};\n  for (const k in props) if (k[0] !== '$') result[k] = props[k];\n  return result;\n}\n\n/** @returns {{}} */\nfunction compute_rest_props(props, keys) {\n  const rest = {};\n  keys = new Set(keys);\n  for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n  return rest;\n}\n\n/** @returns {{}} */\nfunction compute_slots(slots) {\n  const result = {};\n  for (const key in slots) {\n    result[key] = true;\n  }\n  return result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nfunction once(fn) {\n  let ran = false;\n  return function (...args) {\n    if (ran) return;\n    ran = true;\n    fn.call(this, ...args);\n  };\n}\nfunction null_to_empty(value) {\n  return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n  store.set(value);\n  return ret;\n}\nconst utils_has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n  return action_result && utils_is_function(action_result.destroy) ? action_result.destroy : utils_noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nfunction split_css_unit(value) {\n  const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n  return split ? [parseFloat(split[1]), split[2] || 'px'] : [( /** @type {number} */value), 'px'];\n}\nconst utils_contenteditable_truthy_values = (/* unused pure expression or super */ null && (['', true, 1, 'true', 'contenteditable']));\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/environment.js\n\nconst is_client = typeof window !== 'undefined';\n\n/** @type {() => number} */\nlet environment_now = is_client ? () => window.performance.now() : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : utils_noop;\n\n// used internally for testing\n/** @returns {void} */\nfunction set_now(fn) {\n  environment_now = fn;\n}\n\n/** @returns {void} */\nfunction set_raf(fn) {\n  raf = fn;\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/loop.js\n\nconst tasks = new Set();\n\n/**\n * @param {number} now\n * @returns {void}\n */\nfunction run_tasks(now) {\n  tasks.forEach(task => {\n    if (!task.c(now)) {\n      tasks.delete(task);\n      task.f();\n    }\n  });\n  if (tasks.size !== 0) raf(run_tasks);\n}\n\n/**\n * For testing purposes only!\n * @returns {void}\n */\nfunction clear_loops() {\n  tasks.clear();\n}\n\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n * @param {import('./private.js').TaskCallback} callback\n * @returns {import('./private.js').Task}\n */\nfunction loop_loop(callback) {\n  /** @type {import('./private.js').TaskEntry} */\n  let task;\n  if (tasks.size === 0) raf(run_tasks);\n  return {\n    promise: new Promise(fulfill => {\n      tasks.add(task = {\n        c: callback,\n        f: fulfill\n      });\n    }),\n    abort() {\n      tasks.delete(task);\n    }\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/globals.js\n/** @type {typeof globalThis} */\nconst globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis :\n// @ts-ignore Node typings have this\nglobal;\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js\n\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n  /**\n   * @private\n   * @readonly\n   * @type {WeakMap<Element, import('./private.js').Listener>}\n   */\n  _listeners = \"WeakMap\" in globals ? new WeakMap() : undefined;\n\n  /**\n   * @private\n   * @type {ResizeObserver}\n   */\n  _observer = undefined;\n\n  /** @type {ResizeObserverOptions} */\n  options;\n\n  /** @param {ResizeObserverOptions} options */\n  constructor(options) {\n    this.options = options;\n  }\n\n  /**\n   * @param {Element} element\n   * @param {import('./private.js').Listener} listener\n   * @returns {() => void}\n   */\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element); // this line can probably be removed\n    };\n  }\n\n  /**\n   * @private\n   */\n  _getObserver() {\n    return this._observer ?? (this._observer = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        ResizeObserverSingleton.entries.set(entry.target, entry);\n        this._listeners.get(entry.target)?.(entry);\n      }\n    }));\n  }\n}\n\n// Needs to be written like this to pass the tree-shake-test\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? new WeakMap() : undefined;\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dom.js\n\n\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nfunction start_hydrating() {\n  is_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nfunction end_hydrating() {\n  is_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n  // Return first index of value larger than input value in the range [low, high)\n  while (low < high) {\n    const mid = low + (high - low >> 1);\n    if (key(mid) <= value) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n  if (target.hydrate_init) return;\n  target.hydrate_init = true;\n  // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n  let children = /** @type {ArrayLike<NodeEx2>} */target.childNodes;\n  // If target is <head>, there may be children without claim_order\n  if (target.nodeName === 'HEAD') {\n    const my_children = [];\n    for (let i = 0; i < children.length; i++) {\n      const node = children[i];\n      if (node.claim_order !== undefined) {\n        my_children.push(node);\n      }\n    }\n    children = my_children;\n  }\n  /*\n   * Reorder claimed children optimally.\n   * We can reorder claimed children optimally by finding the longest subsequence of\n   * nodes that are already claimed in order and only moving the rest. The longest\n   * subsequence of nodes that are claimed in order can be found by\n   * computing the longest increasing subsequence of .claim_order values.\n   *\n   * This algorithm is optimal in generating the least amount of reorder operations\n   * possible.\n   *\n   * Proof:\n   * We know that, given a set of reordering operations, the nodes that do not move\n   * always form an increasing subsequence, since they do not move among each other\n   * meaning that they must be already ordered among each other. Thus, the maximal\n   * set of nodes that do not move form a longest increasing subsequence.\n   */\n  // Compute longest increasing subsequence\n  // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n  const m = new Int32Array(children.length + 1);\n  // Predecessor indices + 1\n  const p = new Int32Array(children.length);\n  m[0] = -1;\n  let longest = 0;\n  for (let i = 0; i < children.length; i++) {\n    const current = children[i].claim_order;\n    // Find the largest subsequence length such that it ends in a value less than our current value\n    // upper_bound returns first greater value, so we subtract one\n    // with fast path for when we are on the current longest subsequence\n    const seq_len = (longest > 0 && children[m[longest]].claim_order <= current ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n    p[i] = m[seq_len] + 1;\n    const new_len = seq_len + 1;\n    // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n    m[new_len] = i;\n    longest = Math.max(new_len, longest);\n  }\n  // The longest increasing subsequence of nodes (initially reversed)\n\n  /**\n   * @type {NodeEx2[]}\n   */\n  const lis = [];\n  // The rest of the nodes, nodes that will be moved\n\n  /**\n   * @type {NodeEx2[]}\n   */\n  const to_move = [];\n  let last = children.length - 1;\n  for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n    lis.push(children[cur - 1]);\n    for (; last >= cur; last--) {\n      to_move.push(children[last]);\n    }\n    last--;\n  }\n  for (; last >= 0; last--) {\n    to_move.push(children[last]);\n  }\n  lis.reverse();\n  // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n  to_move.sort((a, b) => a.claim_order - b.claim_order);\n  // Finally, we move the nodes\n  for (let i = 0, j = 0; i < to_move.length; i++) {\n    while (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n      j++;\n    }\n    const anchor = j < lis.length ? lis[j] : null;\n    target.insertBefore(to_move[i], anchor);\n  }\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nfunction dom_append(target, node) {\n  target.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = dom_element('style');\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nfunction get_root_for_style(node) {\n  if (!node) return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && /** @type {ShadowRoot} */root.host) {\n    return /** @type {ShadowRoot} */root;\n  }\n  return node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nfunction append_empty_stylesheet(node) {\n  const style_element = dom_element('style');\n  // For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n  // these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n  // Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n  // So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n  // The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n  style_element.textContent = '/* empty */';\n  append_stylesheet(get_root_for_style(node), style_element);\n  return style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n  dom_append( /** @type {Document} */node.head || node, style);\n  return style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nfunction dom_append_hydration(target, node) {\n  if (is_hydrating) {\n    init_hydrate(target);\n    if (target.actual_end_child === undefined || target.actual_end_child !== null && target.actual_end_child.parentNode !== target) {\n      target.actual_end_child = target.firstChild;\n    }\n    // Skip nodes of undefined ordering\n    while (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n      target.actual_end_child = target.actual_end_child.nextSibling;\n    }\n    if (node !== target.actual_end_child) {\n      // We only insert if the ordering of this node should be modified or the parent node is not target\n      if (node.claim_order !== undefined || node.parentNode !== target) {\n        target.insertBefore(node, target.actual_end_child);\n      }\n    } else {\n      target.actual_end_child = node.nextSibling;\n    }\n  } else if (node.parentNode !== target || node.nextSibling !== null) {\n    target.appendChild(node);\n  }\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nfunction dom_insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nfunction dom_insert_hydration(target, node, anchor) {\n  if (is_hydrating && !anchor) {\n    dom_append_hydration(target, node);\n  } else if (node.parentNode !== target || node.nextSibling != anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nfunction dom_detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * @returns {void} */\nfunction destroy_each(iterations, detaching) {\n  for (let i = 0; i < iterations.length; i += 1) {\n    if (iterations[i]) iterations[i].d(detaching);\n  }\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nfunction dom_element(name) {\n  return document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nfunction element_is(name, is) {\n  return document.createElement(name, {\n    is\n  });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nfunction object_without_properties(obj, exclude) {\n  const target = /** @type {Pick<T, Exclude<keyof T, K>>} */{};\n  for (const k in obj) {\n    if (has_prop(obj, k) &&\n    // @ts-ignore\n    exclude.indexOf(k) === -1) {\n      // @ts-ignore\n      target[k] = obj[k];\n    }\n  }\n  return target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nfunction svg_element(name) {\n  return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nfunction dom_text(data) {\n  return document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nfunction space() {\n  return dom_text(' ');\n}\n\n/**\n * @returns {Text} */\nfunction empty() {\n  return dom_text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nfunction comment(content) {\n  return document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nfunction dom_listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nfunction prevent_default(fn) {\n  return function (event) {\n    event.preventDefault();\n    // @ts-ignore\n    return fn.call(this, event);\n  };\n}\n\n/**\n * @returns {(event: any) => any} */\nfunction stop_propagation(fn) {\n  return function (event) {\n    event.stopPropagation();\n    // @ts-ignore\n    return fn.call(this, event);\n  };\n}\n\n/**\n * @returns {(event: any) => any} */\nfunction stop_immediate_propagation(fn) {\n  return function (event) {\n    event.stopImmediatePropagation();\n    // @ts-ignore\n    return fn.call(this, event);\n  };\n}\n\n/**\n * @returns {(event: any) => void} */\nfunction dom_self(fn) {\n  return function (event) {\n    // @ts-ignore\n    if (event.target === this) fn.call(this, event);\n  };\n}\n\n/**\n * @returns {(event: any) => void} */\nfunction trusted(fn) {\n  return function (event) {\n    // @ts-ignore\n    if (event.isTrusted) fn.call(this, event);\n  };\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nfunction dom_attr(node, attribute, value) {\n  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = (/* unused pure expression or super */ null && (['width', 'height']));\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nfunction set_attributes(node, attributes) {\n  // @ts-ignore\n  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n  for (const key in attributes) {\n    if (attributes[key] == null) {\n      node.removeAttribute(key);\n    } else if (key === 'style') {\n      node.style.cssText = attributes[key];\n    } else if (key === '__value') {\n      /** @type {any} */node.value = node[key] = attributes[key];\n    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n      node[key] = attributes[key];\n    } else {\n      dom_attr(node, key, attributes[key]);\n    }\n  }\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nfunction set_svg_attributes(node, attributes) {\n  for (const key in attributes) {\n    dom_attr(node, key, attributes[key]);\n  }\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nfunction set_custom_element_data_map(node, data_map) {\n  Object.keys(data_map).forEach(key => {\n    set_custom_element_data(node, key, data_map[key]);\n  });\n}\n\n/**\n * @returns {void} */\nfunction set_custom_element_data(node, prop, value) {\n  const lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n  if (lower in node) {\n    node[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n  } else if (prop in node) {\n    node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n  } else {\n    dom_attr(node, prop, value);\n  }\n}\n\n/**\n * @param {string} tag\n */\nfunction set_dynamic_element_data(tag) {\n  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nfunction xlink_attr(node, attribute, value) {\n  node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nfunction get_svelte_dataset(node) {\n  return node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nfunction get_binding_group_value(group, __value, checked) {\n  const value = new Set();\n  for (let i = 0; i < group.length; i += 1) {\n    if (group[i].checked) value.add(group[i].__value);\n  }\n  if (!checked) {\n    value.delete(__value);\n  }\n  return Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nfunction init_binding_group(group) {\n  /**\n   * @type {HTMLInputElement[]} */\n  let _inputs;\n  return {\n    /* push */p(...inputs) {\n      _inputs = inputs;\n      _inputs.forEach(input => group.push(input));\n    },\n    /* remove */r() {\n      _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n    }\n  };\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nfunction init_binding_group_dynamic(group, indexes) {\n  /**\n   * @type {HTMLInputElement[]} */\n  let _group = get_binding_group(group);\n\n  /**\n   * @type {HTMLInputElement[]} */\n  let _inputs;\n  function get_binding_group(group) {\n    for (let i = 0; i < indexes.length; i++) {\n      group = group[indexes[i]] = group[indexes[i]] || [];\n    }\n    return group;\n  }\n\n  /**\n   * @returns {void} */\n  function push() {\n    _inputs.forEach(input => _group.push(input));\n  }\n\n  /**\n   * @returns {void} */\n  function remove() {\n    _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n  }\n  return {\n    /* update */u(new_indexes) {\n      indexes = new_indexes;\n      const new_group = get_binding_group(group);\n      if (new_group !== _group) {\n        remove();\n        _group = new_group;\n        push();\n      }\n    },\n    /* push */p(...inputs) {\n      _inputs = inputs;\n      push();\n    },\n    /* remove */r: remove\n  };\n}\n\n/** @returns {number} */\nfunction to_number(value) {\n  return value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nfunction time_ranges_to_array(ranges) {\n  const array = [];\n  for (let i = 0; i < ranges.length; i += 1) {\n    array.push({\n      start: ranges.start(i),\n      end: ranges.end(i)\n    });\n  }\n  return array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n  if (nodes.claim_info === undefined) {\n    nodes.claim_info = {\n      last_index: 0,\n      total_claimed: 0\n    };\n  }\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n  // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n  init_claim_info(nodes);\n  const result_node = (() => {\n    // We first try to find an element after the previous one\n    for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (predicate(node)) {\n        const replacement = process_node(node);\n        if (replacement === undefined) {\n          nodes.splice(i, 1);\n        } else {\n          nodes[i] = replacement;\n        }\n        if (!dont_update_last_index) {\n          nodes.claim_info.last_index = i;\n        }\n        return node;\n      }\n    }\n    // Otherwise, we try to find one before\n    // We iterate in reverse so that we don't go too far back\n    for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n      const node = nodes[i];\n      if (predicate(node)) {\n        const replacement = process_node(node);\n        if (replacement === undefined) {\n          nodes.splice(i, 1);\n        } else {\n          nodes[i] = replacement;\n        }\n        if (!dont_update_last_index) {\n          nodes.claim_info.last_index = i;\n        } else if (replacement === undefined) {\n          // Since we spliced before the last_index, we decrease it\n          nodes.claim_info.last_index--;\n        }\n        return node;\n      }\n    }\n    // If we can't find any matching node, we create a new one\n    return create_node();\n  })();\n  result_node.claim_order = nodes.claim_info.total_claimed;\n  nodes.claim_info.total_claimed += 1;\n  return result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n  return claim_node(nodes, /** @returns {node is Element | SVGElement} */\n  node => node.nodeName === name, /** @param {Element} node */\n  node => {\n    const remove = [];\n    for (let j = 0; j < node.attributes.length; j++) {\n      const attribute = node.attributes[j];\n      if (!attributes[attribute.name]) {\n        remove.push(attribute.name);\n      }\n    }\n    remove.forEach(v => node.removeAttribute(v));\n    return undefined;\n  }, () => create_element(name));\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nfunction claim_element(nodes, name, attributes) {\n  return claim_element_base(nodes, name, attributes, dom_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nfunction claim_svg_element(nodes, name, attributes) {\n  return claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nfunction claim_text(nodes, data) {\n  return claim_node(nodes, /** @returns {node is Text} */\n  node => node.nodeType === 3, /** @param {Text} node */\n  node => {\n    const data_str = '' + data;\n    if (node.data.startsWith(data_str)) {\n      if (node.data.length !== data_str.length) {\n        return node.splitText(data_str.length);\n      }\n    } else {\n      node.data = data_str;\n    }\n  }, () => dom_text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n  );\n}\n\n/**\n * @returns {Text} */\nfunction claim_space(nodes) {\n  return claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nfunction claim_comment(nodes, data) {\n  return claim_node(nodes, /** @returns {node is Comment} */\n  node => node.nodeType === 8, /** @param {Comment} node */\n  node => {\n    node.data = '' + data;\n    return undefined;\n  }, () => comment(data), true);\n}\nfunction get_comment_idx(nodes, text, start) {\n  for (let i = start; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nfunction claim_html_tag(nodes, is_svg) {\n  // find html opening tag\n  const start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n  const end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n  if (start_index === -1 || end_index === -1) {\n    return new HtmlTagHydration(is_svg);\n  }\n  init_claim_info(nodes);\n  const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n  dom_detach(html_tag_nodes[0]);\n  dom_detach(html_tag_nodes[html_tag_nodes.length - 1]);\n  const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n  if (claimed_nodes.length === 0) {\n    return new HtmlTagHydration(is_svg);\n  }\n  for (const n of claimed_nodes) {\n    n.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n  }\n  return new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data(text, data) {\n  data = '' + data;\n  if (text.data === data) return;\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data_contenteditable(text, data) {\n  data = '' + data;\n  if (text.wholeText === data) return;\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n  if (~contenteditable_truthy_values.indexOf(attr_value)) {\n    set_data_contenteditable(text, data);\n  } else {\n    set_data(text, data);\n  }\n}\n\n/**\n * @returns {void} */\nfunction set_input_value(input, value) {\n  input.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nfunction set_input_type(input, type) {\n  try {\n    input.type = type;\n  } catch (e) {\n    // do nothing\n  }\n}\n\n/**\n * @returns {void} */\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? 'important' : '');\n  }\n}\n\n/**\n * @returns {void} */\nfunction select_option(select, value, mounting) {\n  for (let i = 0; i < select.options.length; i += 1) {\n    const option = select.options[i];\n    if (option.__value === value) {\n      option.selected = true;\n      return;\n    }\n  }\n  if (!mounting || value !== undefined) {\n    select.selectedIndex = -1; // no option should be selected\n  }\n}\n\n/**\n * @returns {void} */\nfunction select_options(select, value) {\n  for (let i = 0; i < select.options.length; i += 1) {\n    const option = select.options[i];\n    option.selected = ~value.indexOf(option.__value);\n  }\n}\nfunction select_value(select) {\n  const selected_option = select.querySelector(':checked');\n  return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n  return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nfunction is_crossorigin() {\n  if (crossorigin === undefined) {\n    crossorigin = false;\n    try {\n      if (typeof window !== 'undefined' && window.parent) {\n        void window.parent.document;\n      }\n    } catch (error) {\n      crossorigin = true;\n    }\n  }\n  return crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nfunction add_iframe_resize_listener(node, fn) {\n  const computed_style = getComputedStyle(node);\n  if (computed_style.position === 'static') {\n    node.style.position = 'relative';\n  }\n  const iframe = dom_element('iframe');\n  iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n  iframe.setAttribute('aria-hidden', 'true');\n  iframe.tabIndex = -1;\n  const crossorigin = is_crossorigin();\n\n  /**\n   * @type {() => void}\n   */\n  let unsubscribe;\n  if (crossorigin) {\n    iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>\";\n    unsubscribe = dom_listen(window, 'message', /** @param {MessageEvent} event */event => {\n      if (event.source === iframe.contentWindow) fn();\n    });\n  } else {\n    iframe.src = 'about:blank';\n    iframe.onload = () => {\n      unsubscribe = dom_listen(iframe.contentWindow, 'resize', fn);\n      // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n      // see https://github.com/sveltejs/svelte/issues/4233\n      fn();\n    };\n  }\n  dom_append(node, iframe);\n  return () => {\n    if (crossorigin) {\n      unsubscribe();\n    } else if (unsubscribe && iframe.contentWindow) {\n      unsubscribe();\n    }\n    dom_detach(iframe);\n  };\n}\nconst resize_observer_content_box = /* @__PURE__ */new ResizeObserverSingleton({\n  box: 'content-box'\n});\nconst resize_observer_border_box = /* @__PURE__ */new ResizeObserverSingleton({\n  box: 'border-box'\n});\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */new ResizeObserverSingleton({\n  box: 'device-pixel-content-box'\n});\n\n\n/**\n * @returns {void} */\nfunction toggle_class(element, name, toggle) {\n  // The `!!` is required because an `undefined` flag means flipping the current state.\n  element.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nfunction dom_custom_event(type, detail, {\n  bubbles = false,\n  cancelable = false\n} = {}) {\n  return new CustomEvent(type, {\n    detail,\n    bubbles,\n    cancelable\n  });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nfunction query_selector_all(selector, parent = document.body) {\n  return Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nfunction head_selector(nodeId, head) {\n  const result = [];\n  let started = 0;\n  for (const node of head.childNodes) {\n    if (node.nodeType === 8 /* comment node */) {\n      const comment = node.textContent.trim();\n      if (comment === `HEAD_${nodeId}_END`) {\n        started -= 1;\n        result.push(node);\n      } else if (comment === `HEAD_${nodeId}_START`) {\n        started += 1;\n        result.push(node);\n      }\n    } else if (started > 0) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/** */\nclass HtmlTag {\n  /**\n   * @private\n   * @default false\n   */\n  is_svg = false;\n  /** parent for creating node */\n  e = undefined;\n  /** html tag nodes */\n  n = undefined;\n  /** target */\n  t = undefined;\n  /** anchor */\n  a = undefined;\n  constructor(is_svg = false) {\n    this.is_svg = is_svg;\n    this.e = this.n = null;\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  c(html) {\n    this.h(html);\n  }\n\n  /**\n   * @param {string} html\n   * @param {HTMLElement | SVGElement} target\n   * @param {HTMLElement | SVGElement} anchor\n   * @returns {void}\n   */\n  m(html, target, anchor = null) {\n    if (!this.e) {\n      if (this.is_svg) this.e = svg_element( /** @type {keyof SVGElementTagNameMap} */target.nodeName);\n      /** #7364  target for <template> may be provided as #document-fragment(11) */else this.e = dom_element( /** @type {keyof HTMLElementTagNameMap} */\n      target.nodeType === 11 ? 'TEMPLATE' : target.nodeName);\n      this.t = target.tagName !== 'TEMPLATE' ? target : /** @type {HTMLTemplateElement} */target.content;\n      this.c(html);\n    }\n    this.i(anchor);\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  h(html) {\n    this.e.innerHTML = html;\n    this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n  }\n\n  /**\n   * @returns {void} */\n  i(anchor) {\n    for (let i = 0; i < this.n.length; i += 1) {\n      dom_insert(this.t, this.n[i], anchor);\n    }\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  p(html) {\n    this.d();\n    this.h(html);\n    this.i(this.a);\n  }\n\n  /**\n   * @returns {void} */\n  d() {\n    this.n.forEach(dom_detach);\n  }\n}\nclass HtmlTagHydration extends HtmlTag {\n  /** @type {Element[]} hydration claimed nodes */\n  l = undefined;\n  constructor(is_svg = false, claimed_nodes) {\n    super(is_svg);\n    this.e = this.n = null;\n    this.l = claimed_nodes;\n  }\n\n  /**\n   * @param {string} html\n   * @returns {void}\n   */\n  c(html) {\n    if (this.l) {\n      this.n = this.l;\n    } else {\n      super.c(html);\n    }\n  }\n\n  /**\n   * @returns {void} */\n  i(anchor) {\n    for (let i = 0; i < this.n.length; i += 1) {\n      dom_insert_hydration(this.t, this.n[i], anchor);\n    }\n  }\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nfunction attribute_to_object(attributes) {\n  const result = {};\n  for (const attribute of attributes) {\n    result[attribute.name] = attribute.value;\n  }\n  return result;\n}\nconst escaped = {\n  '\"': '&quot;',\n  '&': '&amp;',\n  '<': '&lt;'\n};\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n  return String(attribute).replace(regex_attribute_characters_to_escape, match => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nfunction stringify_spread(attributes) {\n  let str = ' ';\n  for (const key in attributes) {\n    if (attributes[key] != null) {\n      str += `${key}=\"${escape_attribute(attributes[key])}\" `;\n    }\n  }\n  return str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nfunction get_custom_elements_slots(element) {\n  const result = {};\n  element.childNodes.forEach( /** @param {Element} node */node => {\n    result[node.slot || 'default'] = true;\n  });\n  return result;\n}\nfunction construct_svelte_component(component, props) {\n  return new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/style_manager.js\n\n\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\n/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */\nconst managed_styles = new Map();\nlet active = 0;\n\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\n/**\n * @param {string} str\n * @returns {number}\n */\nfunction hash(str) {\n  let hash = 5381;\n  let i = str.length;\n  while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);\n  return hash >>> 0;\n}\n\n/**\n * @param {Document | ShadowRoot} doc\n * @param {Element & ElementCSSInlineStyle} node\n * @returns {{ stylesheet: any; rules: {}; }}\n */\nfunction create_style_information(doc, node) {\n  const info = {\n    stylesheet: append_empty_stylesheet(node),\n    rules: {}\n  };\n  managed_styles.set(doc, info);\n  return info;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {number} a\n * @param {number} b\n * @param {number} duration\n * @param {number} delay\n * @param {(t: number) => number} ease\n * @param {(t: number, u: number) => string} fn\n * @param {number} uid\n * @returns {string}\n */\nfunction style_manager_create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n  const step = 16.666 / duration;\n  let keyframes = '{\\n';\n  for (let p = 0; p <= 1; p += step) {\n    const t = a + (b - a) * ease(p);\n    keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n  }\n  const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n  const name = `__svelte_${hash(rule)}_${uid}`;\n  const doc = get_root_for_style(node);\n  const {\n    stylesheet,\n    rules\n  } = managed_styles.get(doc) || create_style_information(doc, node);\n  if (!rules[name]) {\n    rules[name] = true;\n    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n  }\n  const animation = node.style.animation || '';\n  node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n  active += 1;\n  return name;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {string} [name]\n * @returns {void}\n */\nfunction style_manager_delete_rule(node, name) {\n  const previous = (node.style.animation || '').split(', ');\n  const next = previous.filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation\n  : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n  );\n  const deleted = previous.length - next.length;\n  if (deleted) {\n    node.style.animation = next.join(', ');\n    active -= deleted;\n    if (!active) clear_rules();\n  }\n}\n\n/** @returns {void} */\nfunction clear_rules() {\n  raf(() => {\n    if (active) return;\n    managed_styles.forEach(info => {\n      const {\n        ownerNode\n      } = info.stylesheet;\n      // there is no ownerNode if it runs on jsdom.\n      if (ownerNode) dom_detach(ownerNode);\n    });\n    managed_styles.clear();\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/animations.js\n\n\n\n\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {import('./private.js').PositionRect} from\n * @param {import('./private.js').AnimationFn} fn\n */\nfunction create_animation(node, from, fn, params) {\n  if (!from) return noop;\n  const to = node.getBoundingClientRect();\n  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;\n  const {\n    delay = 0,\n    duration = 300,\n    easing = linear,\n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay,\n    // @ts-ignore todo:\n    end = start_time + duration,\n    tick = noop,\n    css\n  } = fn(node, {\n    from,\n    to\n  }, params);\n  let running = true;\n  let started = false;\n  let name;\n  /** @returns {void} */\n  function start() {\n    if (css) {\n      name = create_rule(node, 0, 1, duration, delay, easing, css);\n    }\n    if (!delay) {\n      started = true;\n    }\n  }\n  /** @returns {void} */\n  function stop() {\n    if (css) delete_rule(node, name);\n    running = false;\n  }\n  loop(now => {\n    if (!started && now >= start_time) {\n      started = true;\n    }\n    if (started && now >= end) {\n      tick(1, 0);\n      stop();\n    }\n    if (!running) {\n      return false;\n    }\n    if (started) {\n      const p = now - start_time;\n      const t = 0 + 1 * easing(p / duration);\n      tick(t, 1 - t);\n    }\n    return true;\n  });\n  start();\n  tick(0, 1);\n  return stop;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @returns {void}\n */\nfunction fix_position(node) {\n  const style = getComputedStyle(node);\n  if (style.position !== 'absolute' && style.position !== 'fixed') {\n    const {\n      width,\n      height\n    } = style;\n    const a = node.getBoundingClientRect();\n    node.style.position = 'absolute';\n    node.style.width = width;\n    node.style.height = height;\n    add_transform(node, a);\n  }\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {import('./private.js').PositionRect} a\n * @returns {void}\n */\nfunction add_transform(node, a) {\n  const b = node.getBoundingClientRect();\n  if (a.left !== b.left || a.top !== b.top) {\n    const style = getComputedStyle(node);\n    const transform = style.transform === 'none' ? '' : style.transform;\n    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/lifecycle.js\n\nlet lifecycle_current_component;\n\n/** @returns {void} */\nfunction lifecycle_set_current_component(component) {\n  lifecycle_current_component = component;\n}\nfunction lifecycle_get_current_component() {\n  if (!lifecycle_current_component) throw new Error('Function called outside component initialization');\n  return lifecycle_current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nfunction beforeUpdate(fn) {\n  lifecycle_get_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nfunction onMount(fn) {\n  lifecycle_get_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nfunction afterUpdate(fn) {\n  lifecycle_get_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nfunction onDestroy(fn) {\n  lifecycle_get_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nfunction createEventDispatcher() {\n  const component = lifecycle_get_current_component();\n  return (type, detail, {\n    cancelable = false\n  } = {}) => {\n    const callbacks = component.$$.callbacks[type];\n    if (callbacks) {\n      // TODO are there situations where events could be dispatched\n      // in a server (non-DOM) environment?\n      const event = custom_event( /** @type {string} */type, detail, {\n        cancelable\n      });\n      callbacks.slice().forEach(fn => {\n        fn.call(component, event);\n      });\n      return !event.defaultPrevented;\n    }\n    return true;\n  };\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nfunction setContext(key, context) {\n  lifecycle_get_current_component().$$.context.set(key, context);\n  return context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nfunction getContext(key) {\n  return lifecycle_get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nfunction getAllContexts() {\n  return lifecycle_get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nfunction hasContext(key) {\n  return lifecycle_get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nfunction bubble(component, event) {\n  const callbacks = component.$$.callbacks[event.type];\n  if (callbacks) {\n    // @ts-ignore\n    callbacks.slice().forEach(fn => fn.call(this, event));\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/scheduler.js\n\n\nconst dirty_components = [];\nconst intros = {\n  enabled: false\n};\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */Promise.resolve();\nlet update_scheduled = false;\n\n/** @returns {void} */\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(scheduler_flush);\n  }\n}\n\n/** @returns {Promise<void>} */\nfunction tick() {\n  schedule_update();\n  return resolved_promise;\n}\n\n/** @returns {void} */\nfunction scheduler_add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\n\n/** @returns {void} */\nfunction add_flush_callback(fn) {\n  flush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nfunction scheduler_flush() {\n  // Do not reenter flush while dirty components are updated, as this can\n  // result in an infinite loop. Instead, let the inner flush handle it.\n  // Reentrancy is ok afterwards for bindings etc.\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = lifecycle_current_component;\n  do {\n    // first, call beforeUpdate functions\n    // and update components\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        lifecycle_set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      // reset dirty state to not end up in a deadlocked state and then rethrow\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    lifecycle_set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length) binding_callbacks.pop()();\n    // then, once components are updated, call\n    // afterUpdate functions. This may cause\n    // subsequent updates...\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        // ...so guard against infinite loops\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  lifecycle_set_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    utils_run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(scheduler_add_render_callback);\n  }\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach(c => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach(c => c());\n  render_callbacks = filtered;\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/transitions.js\n\n\n\n\n\n\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n  if (!promise) {\n    promise = Promise.resolve();\n    promise.then(() => {\n      promise = null;\n    });\n  }\n  return promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n  node.dispatchEvent(dom_custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nfunction transitions_group_outros() {\n  outros = {\n    r: 0,\n    c: [],\n    p: outros // parent group\n  };\n}\n\n/**\n * @returns {void} */\nfunction transitions_check_outros() {\n  if (!outros.r) {\n    utils_run_all(outros.c);\n  }\n  outros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nfunction transitions_transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nfunction transitions_transition_out(block, local, detach, callback) {\n  if (block && block.o) {\n    if (outroing.has(block)) return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach) block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = {\n  duration: 0\n};\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nfunction create_in_transition(node, fn, params) {\n  /**\n   * @type {TransitionOptions} */\n  const options = {\n    direction: 'in'\n  };\n  let config = fn(node, params, options);\n  let running = false;\n  let animation_name;\n  let task;\n  let uid = 0;\n\n  /**\n   * @returns {void} */\n  function cleanup() {\n    if (animation_name) style_manager_delete_rule(node, animation_name);\n  }\n\n  /**\n   * @returns {void} */\n  function go() {\n    const {\n      delay = 0,\n      duration = 300,\n      easing = identity,\n      tick = utils_noop,\n      css\n    } = config || null_transition;\n    if (css) animation_name = style_manager_create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n    tick(0, 1);\n    const start_time = environment_now() + delay;\n    const end_time = start_time + duration;\n    if (task) task.abort();\n    running = true;\n    scheduler_add_render_callback(() => dispatch(node, true, 'start'));\n    task = loop_loop(now => {\n      if (running) {\n        if (now >= end_time) {\n          tick(1, 0);\n          dispatch(node, true, 'end');\n          cleanup();\n          return running = false;\n        }\n        if (now >= start_time) {\n          const t = easing((now - start_time) / duration);\n          tick(t, 1 - t);\n        }\n      }\n      return running;\n    });\n  }\n  let started = false;\n  return {\n    start() {\n      if (started) return;\n      started = true;\n      style_manager_delete_rule(node);\n      if (utils_is_function(config)) {\n        config = config(options);\n        wait().then(go);\n      } else {\n        go();\n      }\n    },\n    invalidate() {\n      started = false;\n    },\n    end() {\n      if (running) {\n        cleanup();\n        running = false;\n      }\n    }\n  };\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nfunction create_out_transition(node, fn, params) {\n  /** @type {TransitionOptions} */\n  const options = {\n    direction: 'out'\n  };\n  let config = fn(node, params, options);\n  let running = true;\n  let animation_name;\n  const group = outros;\n  group.r += 1;\n  /** @type {boolean} */\n  let original_inert_value;\n\n  /**\n   * @returns {void} */\n  function go() {\n    const {\n      delay = 0,\n      duration = 300,\n      easing = identity,\n      tick = utils_noop,\n      css\n    } = config || null_transition;\n    if (css) animation_name = style_manager_create_rule(node, 1, 0, duration, delay, easing, css);\n    const start_time = environment_now() + delay;\n    const end_time = start_time + duration;\n    scheduler_add_render_callback(() => dispatch(node, false, 'start'));\n    if ('inert' in node) {\n      original_inert_value = /** @type {HTMLElement} */node.inert;\n      node.inert = true;\n    }\n    loop_loop(now => {\n      if (running) {\n        if (now >= end_time) {\n          tick(0, 1);\n          dispatch(node, false, 'end');\n          if (! --group.r) {\n            // this will result in `end()` being called,\n            // so we don't need to clean up here\n            utils_run_all(group.c);\n          }\n          return false;\n        }\n        if (now >= start_time) {\n          const t = easing((now - start_time) / duration);\n          tick(1 - t, t);\n        }\n      }\n      return running;\n    });\n  }\n  if (utils_is_function(config)) {\n    wait().then(() => {\n      // @ts-ignore\n      config = config(options);\n      go();\n    });\n  } else {\n    go();\n  }\n  return {\n    end(reset) {\n      if (reset && 'inert' in node) {\n        node.inert = original_inert_value;\n      }\n      if (reset && config.tick) {\n        config.tick(1, 0);\n      }\n      if (running) {\n        if (animation_name) style_manager_delete_rule(node, animation_name);\n        running = false;\n      }\n    }\n  };\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nfunction create_bidirectional_transition(node, fn, params, intro) {\n  /**\n   * @type {TransitionOptions} */\n  const options = {\n    direction: 'both'\n  };\n  let config = fn(node, params, options);\n  let t = intro ? 0 : 1;\n\n  /**\n   * @type {Program | null} */\n  let running_program = null;\n\n  /**\n   * @type {PendingProgram | null} */\n  let pending_program = null;\n  let animation_name = null;\n\n  /** @type {boolean} */\n  let original_inert_value;\n\n  /**\n   * @returns {void} */\n  function clear_animation() {\n    if (animation_name) delete_rule(node, animation_name);\n  }\n\n  /**\n   * @param {PendingProgram} program\n   * @param {number} duration\n   * @returns {Program}\n   */\n  function init(program, duration) {\n    const d = /** @type {Program['d']} */program.b - t;\n    duration *= Math.abs(d);\n    return {\n      a: t,\n      b: program.b,\n      d,\n      duration,\n      start: program.start,\n      end: program.start + duration,\n      group: program.group\n    };\n  }\n\n  /**\n   * @param {INTRO | OUTRO} b\n   * @returns {void}\n   */\n  function go(b) {\n    const {\n      delay = 0,\n      duration = 300,\n      easing = linear,\n      tick = noop,\n      css\n    } = config || null_transition;\n\n    /**\n     * @type {PendingProgram} */\n    const program = {\n      start: now() + delay,\n      b\n    };\n    if (!b) {\n      // @ts-ignore todo: improve typings\n      program.group = outros;\n      outros.r += 1;\n    }\n    if ('inert' in node) {\n      if (b) {\n        if (original_inert_value !== undefined) {\n          // aborted/reversed outro — restore previous inert value\n          node.inert = original_inert_value;\n        }\n      } else {\n        original_inert_value = /** @type {HTMLElement} */node.inert;\n        node.inert = true;\n      }\n    }\n    if (running_program || pending_program) {\n      pending_program = program;\n    } else {\n      // if this is an intro, and there's a delay, we need to do\n      // an initial tick and/or apply CSS animation immediately\n      if (css) {\n        clear_animation();\n        animation_name = create_rule(node, t, b, duration, delay, easing, css);\n      }\n      if (b) tick(0, 1);\n      running_program = init(program, duration);\n      add_render_callback(() => dispatch(node, b, 'start'));\n      loop(now => {\n        if (pending_program && now > pending_program.start) {\n          running_program = init(pending_program, duration);\n          pending_program = null;\n          dispatch(node, running_program.b, 'start');\n          if (css) {\n            clear_animation();\n            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n          }\n        }\n        if (running_program) {\n          if (now >= running_program.end) {\n            tick(t = running_program.b, 1 - t);\n            dispatch(node, running_program.b, 'end');\n            if (!pending_program) {\n              // we're done\n              if (running_program.b) {\n                // intro — we can tidy up immediately\n                clear_animation();\n              } else {\n                // outro — needs to be coordinated\n                if (! --running_program.group.r) run_all(running_program.group.c);\n              }\n            }\n            running_program = null;\n          } else if (now >= running_program.start) {\n            const p = now - running_program.start;\n            t = running_program.a + running_program.d * easing(p / running_program.duration);\n            tick(t, 1 - t);\n          }\n        }\n        return !!(running_program || pending_program);\n      });\n    }\n  }\n  return {\n    run(b) {\n      if (is_function(config)) {\n        wait().then(() => {\n          const opts = {\n            direction: b ? 'in' : 'out'\n          };\n          // @ts-ignore\n          config = config(opts);\n          go(b);\n        });\n      } else {\n        go(b);\n      }\n    },\n    end() {\n      clear_animation();\n      running_program = pending_program = null;\n    }\n  };\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/await_block.js\n\n\n\n\n\n/**\n * @template T\n * @param {Promise<T>} promise\n * @param {import('./private.js').PromiseInfo<T>} info\n * @returns {boolean}\n */\nfunction handle_promise(promise, info) {\n  const token = info.token = {};\n  /**\n   * @param {import('./private.js').FragmentFactory} type\n   * @param {0 | 1 | 2} index\n   * @param {number} [key]\n   * @param {any} [value]\n   * @returns {void}\n   */\n  function update(type, index, key, value) {\n    if (info.token !== token) return;\n    info.resolved = value;\n    let child_ctx = info.ctx;\n    if (key !== undefined) {\n      child_ctx = child_ctx.slice();\n      child_ctx[key] = value;\n    }\n    const block = type && (info.current = type)(child_ctx);\n    let needs_flush = false;\n    if (info.block) {\n      if (info.blocks) {\n        info.blocks.forEach((block, i) => {\n          if (i !== index && block) {\n            group_outros();\n            transition_out(block, 1, 1, () => {\n              if (info.blocks[i] === block) {\n                info.blocks[i] = null;\n              }\n            });\n            check_outros();\n          }\n        });\n      } else {\n        info.block.d(1);\n      }\n      block.c();\n      transition_in(block, 1);\n      block.m(info.mount(), info.anchor);\n      needs_flush = true;\n    }\n    info.block = block;\n    if (info.blocks) info.blocks[index] = block;\n    if (needs_flush) {\n      flush();\n    }\n  }\n  if (is_promise(promise)) {\n    const current_component = get_current_component();\n    promise.then(value => {\n      set_current_component(current_component);\n      update(info.then, 1, info.value, value);\n      set_current_component(null);\n    }, error => {\n      set_current_component(current_component);\n      update(info.catch, 2, info.error, error);\n      set_current_component(null);\n      if (!info.hasCatch) {\n        throw error;\n      }\n    });\n    // if we previously had a then/catch block, destroy it\n    if (info.current !== info.pending) {\n      update(info.pending, 0);\n      return true;\n    }\n  } else {\n    if (info.current !== info.then) {\n      update(info.then, 1, info.value, promise);\n      return true;\n    }\n    info.resolved = /** @type {T} */promise;\n  }\n}\n\n/** @returns {void} */\nfunction update_await_block_branch(info, ctx, dirty) {\n  const child_ctx = ctx.slice();\n  const {\n    resolved\n  } = info;\n  if (info.current === info.then) {\n    child_ctx[info.value] = resolved;\n  }\n  if (info.current === info.catch) {\n    child_ctx[info.error] = resolved;\n  }\n  info.block.p(child_ctx, dirty);\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/each.js\n\n\n\n// general each functions:\n\nfunction each_ensure_array_like(array_like_or_iterator) {\n  return array_like_or_iterator?.length !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nfunction destroy_block(block, lookup) {\n  block.d(1);\n  lookup.delete(block.key);\n}\n\n/** @returns {void} */\nfunction outro_and_destroy_block(block, lookup) {\n  transitions_transition_out(block, 1, 1, () => {\n    lookup.delete(block.key);\n  });\n}\n\n/** @returns {void} */\nfunction fix_and_destroy_block(block, lookup) {\n  block.f();\n  destroy_block(block, lookup);\n}\n\n/** @returns {void} */\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n  block.f();\n  outro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n  let o = old_blocks.length;\n  let n = list.length;\n  let i = o;\n  const old_indexes = {};\n  while (i--) old_indexes[old_blocks[i].key] = i;\n  const new_blocks = [];\n  const new_lookup = new Map();\n  const deltas = new Map();\n  const updates = [];\n  i = n;\n  while (i--) {\n    const child_ctx = get_context(ctx, list, i);\n    const key = get_key(child_ctx);\n    let block = lookup.get(key);\n    if (!block) {\n      block = create_each_block(key, child_ctx);\n      block.c();\n    } else if (dynamic) {\n      // defer updates until all the DOM shuffling is done\n      updates.push(() => block.p(child_ctx, dirty));\n    }\n    new_lookup.set(key, new_blocks[i] = block);\n    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n  }\n  const will_move = new Set();\n  const did_move = new Set();\n  /** @returns {void} */\n  function insert(block) {\n    transitions_transition_in(block, 1);\n    block.m(node, next);\n    lookup.set(block.key, block);\n    next = block.first;\n    n--;\n  }\n  while (o && n) {\n    const new_block = new_blocks[n - 1];\n    const old_block = old_blocks[o - 1];\n    const new_key = new_block.key;\n    const old_key = old_block.key;\n    if (new_block === old_block) {\n      // do nothing\n      next = new_block.first;\n      o--;\n      n--;\n    } else if (!new_lookup.has(old_key)) {\n      // remove old block\n      destroy(old_block, lookup);\n      o--;\n    } else if (!lookup.has(new_key) || will_move.has(new_key)) {\n      insert(new_block);\n    } else if (did_move.has(old_key)) {\n      o--;\n    } else if (deltas.get(new_key) > deltas.get(old_key)) {\n      did_move.add(new_key);\n      insert(new_block);\n    } else {\n      will_move.add(old_key);\n      o--;\n    }\n  }\n  while (o--) {\n    const old_block = old_blocks[o];\n    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n  }\n  while (n) insert(new_blocks[n - 1]);\n  utils_run_all(updates);\n  return new_blocks;\n}\n\n/** @returns {void} */\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n  const keys = new Map();\n  for (let i = 0; i < list.length; i++) {\n    const key = get_key(get_context(ctx, list, i));\n    if (keys.has(key)) {\n      let value = '';\n      try {\n        value = `with value '${String(key)}' `;\n      } catch (e) {\n        // can't stringify\n      }\n      throw new Error(`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(key)} and ${i} ${value}are duplicates`);\n    }\n    keys.set(key, i);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/spread.js\n/** @returns {{}} */\nfunction get_spread_update(levels, updates) {\n  const update = {};\n  const to_null_out = {};\n  const accounted_for = {\n    $$scope: 1\n  };\n  let i = levels.length;\n  while (i--) {\n    const o = levels[i];\n    const n = updates[i];\n    if (n) {\n      for (const key in o) {\n        if (!(key in n)) to_null_out[key] = 1;\n      }\n      for (const key in n) {\n        if (!accounted_for[key]) {\n          update[key] = n[key];\n          accounted_for[key] = 1;\n        }\n      }\n      levels[i] = n;\n    } else {\n      for (const key in o) {\n        accounted_for[key] = 1;\n      }\n    }\n  }\n  for (const key in to_null_out) {\n    if (!(key in update)) update[key] = undefined;\n  }\n  return update;\n}\nfunction get_spread_object(spread_props) {\n  return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/shared/boolean_attributes.js\nconst _boolean_attributes = /** @type {const} */['allowfullscreen', 'allowpaymentrequest', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'defer', 'disabled', 'formnovalidate', 'hidden', 'inert', 'ismap', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'selected'];\n\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n *\n * @type {Set<string>}\n */\nconst boolean_attributes_boolean_attributes = new Set([..._boolean_attributes]);\n\n/** @typedef {typeof _boolean_attributes[number]} BooleanAttributes */\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/ssr.js\n\n\n\n\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\n\n/** @returns {string} */\nfunction spread(args, attrs_to_add) {\n  const attributes = Object.assign({}, ...args);\n  if (attrs_to_add) {\n    const classes_to_add = attrs_to_add.classes;\n    const styles_to_add = attrs_to_add.styles;\n    if (classes_to_add) {\n      if (attributes.class == null) {\n        attributes.class = classes_to_add;\n      } else {\n        attributes.class += ' ' + classes_to_add;\n      }\n    }\n    if (styles_to_add) {\n      if (attributes.style == null) {\n        attributes.style = style_object_to_string(styles_to_add);\n      } else {\n        attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n      }\n    }\n  }\n  let str = '';\n  Object.keys(attributes).forEach(name => {\n    if (invalid_attribute_name_character.test(name)) return;\n    const value = attributes[name];\n    if (value === true) str += ' ' + name;else if (boolean_attributes.has(name.toLowerCase())) {\n      if (value) str += ' ' + name;\n    } else if (value != null) {\n      str += ` ${name}=\"${value}\"`;\n    }\n  });\n  return str;\n}\n\n/** @returns {{}} */\nfunction merge_ssr_styles(style_attribute, style_directive) {\n  const style_object = {};\n  for (const individual_style of style_attribute.split(';')) {\n    const colon_index = individual_style.indexOf(':');\n    const name = individual_style.slice(0, colon_index).trim();\n    const value = individual_style.slice(colon_index + 1).trim();\n    if (!name) continue;\n    style_object[name] = value;\n  }\n  for (const name in style_directive) {\n    const value = style_directive[name];\n    if (value) {\n      style_object[name] = value;\n    } else {\n      delete style_object[name];\n    }\n  }\n  return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n * @param {unknown} value\n * @returns {string}\n */\nfunction ssr_escape(value, is_attr = false) {\n  const str = String(value);\n  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n  pattern.lastIndex = 0;\n  let escaped = '';\n  let last = 0;\n  while (pattern.test(str)) {\n    const i = pattern.lastIndex - 1;\n    const ch = str[i];\n    escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '\"' ? '&quot;' : '&lt;');\n    last = i + 1;\n  }\n  return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n  // keep booleans, null, and undefined for the sake of `spread`\n  const should_escape = typeof value === 'string' || value && typeof value === 'object';\n  return should_escape ? ssr_escape(value, true) : value;\n}\n\n/** @returns {{}} */\nfunction escape_object(obj) {\n  const result = {};\n  for (const key in obj) {\n    result[key] = escape_attribute_value(obj[key]);\n  }\n  return result;\n}\n\n/** @returns {string} */\nfunction each(items, fn) {\n  items = ensure_array_like(items);\n  let str = '';\n  for (let i = 0; i < items.length; i += 1) {\n    str += fn(items[i], i);\n  }\n  return str;\n}\nconst missing_component = {\n  $$render: () => ''\n};\nfunction validate_component(component, name) {\n  if (!component || !component.$$render) {\n    if (name === 'svelte:component') name += ' this={...}';\n    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n  }\n  return component;\n}\n\n/** @returns {string} */\nfunction debug(file, line, column, values) {\n  console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n  console.log(values); // eslint-disable-line no-console\n  return '';\n}\nlet on_destroy;\n\n/** @returns {{ render: (props?: {}, { $$slots, context }?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; }; $$render: (result: any, props: any, bindings: any, slots: any, context: any) => any; }} */\nfunction create_ssr_component(fn) {\n  function $$render(result, props, bindings, slots, context) {\n    const parent_component = current_component;\n    const $$ = {\n      on_destroy,\n      context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n      // these will be immediately discarded\n      on_mount: [],\n      before_update: [],\n      after_update: [],\n      callbacks: blank_object()\n    };\n    set_current_component({\n      $$\n    });\n    const html = fn(result, props, bindings, slots);\n    set_current_component(parent_component);\n    return html;\n  }\n  return {\n    render: (props = {}, {\n      $$slots = {},\n      context = new Map()\n    } = {}) => {\n      on_destroy = [];\n      const result = {\n        title: '',\n        head: '',\n        css: new Set()\n      };\n      const html = $$render(result, props, {}, $$slots, context);\n      run_all(on_destroy);\n      return {\n        html,\n        css: {\n          code: Array.from(result.css).map(css => css.code).join('\\n'),\n          map: null // TODO\n        },\n        head: result.title + result.head\n      };\n    },\n    $$render\n  };\n}\n\n/** @returns {string} */\nfunction add_attribute(name, value, boolean) {\n  if (value == null || boolean && !value) return '';\n  const assignment = boolean && value === true ? '' : `=\"${ssr_escape(value, true)}\"`;\n  return ` ${name}${assignment}`;\n}\n\n/** @returns {string} */\nfunction add_classes(classes) {\n  return classes ? ` class=\"${classes}\"` : '';\n}\n\n/** @returns {string} */\nfunction style_object_to_string(style_object) {\n  return Object.keys(style_object).filter(key => style_object[key] != null && style_object[key] !== '').map(key => `${key}: ${escape_attribute_value(style_object[key])};`).join(' ');\n}\n\n/** @returns {string} */\nfunction add_styles(style_object) {\n  const styles = style_object_to_string(style_object);\n  return styles ? ` style=\"${styles}\"` : '';\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/Component.js\n\n\n\n\n\n\n/** @returns {void} */\nfunction bind(component, name, callback) {\n  const index = component.$$.props[name];\n  if (index !== undefined) {\n    component.$$.bound[index] = callback;\n    callback(component.$$.ctx[index]);\n  }\n}\n\n/** @returns {void} */\nfunction create_component(block) {\n  block && block.c();\n}\n\n/** @returns {void} */\nfunction claim_component(block, parent_nodes) {\n  block && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nfunction mount_component(component, target, anchor) {\n  const {\n    fragment,\n    after_update\n  } = component.$$;\n  fragment && fragment.m(target, anchor);\n  // onMount happens before the initial afterUpdate\n  scheduler_add_render_callback(() => {\n    const new_on_destroy = component.$$.on_mount.map(run).filter(utils_is_function);\n    // if the component was destroyed immediately\n    // it will update the `$$.on_destroy` reference to `null`.\n    // the destructured on_destroy may still reference to the old array\n    if (component.$$.on_destroy) {\n      component.$$.on_destroy.push(...new_on_destroy);\n    } else {\n      // Edge case - component was destroyed immediately,\n      // most likely as a result of a binding initialising\n      utils_run_all(new_on_destroy);\n    }\n    component.$$.on_mount = [];\n  });\n  after_update.forEach(scheduler_add_render_callback);\n}\n\n/** @returns {void} */\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    utils_run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    // TODO null out other refs, including component.$$ (but need to\n    // preserve final state?)\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles = null, dirty = [-1]) {\n  const parent_component = lifecycle_current_component;\n  lifecycle_set_current_component(component);\n  /** @type {import('./private.js').T$$} */\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: utils_noop,\n    not_equal,\n    bound: utils_blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: utils_blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n      if (ready) make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  utils_run_all($$.before_update);\n  // `false` as a special case of no DOM component\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      // TODO: what is the correct type here?\n      // @ts-expect-error\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(dom_detach);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro) transitions_transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor);\n    end_hydrating();\n    scheduler_flush();\n  }\n  lifecycle_set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n  SvelteElement = class extends HTMLElement {\n    /** The Svelte component constructor */\n    $$ctor;\n    /** Slots */\n    $$s;\n    /** The Svelte component instance */\n    $$c;\n    /** Whether or not the custom element is connected */\n    $$cn = false;\n    /** Component props data */\n    $$d = {};\n    /** `true` if currently in the process of reflecting component props back to attributes */\n    $$r = false;\n    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n    $$p_d = {};\n    /** @type {Record<string, Function[]>} Event listeners */\n    $$l = {};\n    /** @type {Map<Function, Function>} Event listener unsubscribe functions */\n    $$l_u = new Map();\n    constructor($$componentCtor, $$slots, use_shadow_dom) {\n      super();\n      this.$$ctor = $$componentCtor;\n      this.$$s = $$slots;\n      if (use_shadow_dom) {\n        this.attachShadow({\n          mode: 'open'\n        });\n      }\n    }\n    addEventListener(type, listener, options) {\n      // We can't determine upfront if the event is a custom event or not, so we have to\n      // listen to both. If someone uses a custom event with the same name as a regular\n      // browser event, this fires twice - we can't avoid that.\n      this.$$l[type] = this.$$l[type] || [];\n      this.$$l[type].push(listener);\n      if (this.$$c) {\n        const unsub = this.$$c.$on(type, listener);\n        this.$$l_u.set(listener, unsub);\n      }\n      super.addEventListener(type, listener, options);\n    }\n    removeEventListener(type, listener, options) {\n      super.removeEventListener(type, listener, options);\n      if (this.$$c) {\n        const unsub = this.$$l_u.get(listener);\n        if (unsub) {\n          unsub();\n          this.$$l_u.delete(listener);\n        }\n      }\n    }\n    async connectedCallback() {\n      this.$$cn = true;\n      if (!this.$$c) {\n        // We wait one tick to let possible child slot elements be created/mounted\n        await Promise.resolve();\n        if (!this.$$cn || this.$$c) {\n          return;\n        }\n        function create_slot(name) {\n          return () => {\n            let node;\n            const obj = {\n              c: function create() {\n                node = dom_element('slot');\n                if (name !== 'default') {\n                  dom_attr(node, 'name', name);\n                }\n              },\n              /**\n               * @param {HTMLElement} target\n               * @param {HTMLElement} [anchor]\n               */\n              m: function mount(target, anchor) {\n                dom_insert(target, node, anchor);\n              },\n              d: function destroy(detaching) {\n                if (detaching) {\n                  dom_detach(node);\n                }\n              }\n            };\n            return obj;\n          };\n        }\n        const $$slots = {};\n        const existing_slots = get_custom_elements_slots(this);\n        for (const name of this.$$s) {\n          if (name in existing_slots) {\n            $$slots[name] = [create_slot(name)];\n          }\n        }\n        for (const attribute of this.attributes) {\n          // this.$$data takes precedence over this.attributes\n          const name = this.$$g_p(attribute.name);\n          if (!(name in this.$$d)) {\n            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n          }\n        }\n        // Port over props that were set programmatically before ce was initialized\n        for (const key in this.$$p_d) {\n          if (!(key in this.$$d) && this[key] !== undefined) {\n            this.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n            delete this[key]; // remove the property that shadows the getter/setter\n          }\n        }\n        this.$$c = new this.$$ctor({\n          target: this.shadowRoot || this,\n          props: {\n            ...this.$$d,\n            $$slots,\n            $$scope: {\n              ctx: []\n            }\n          }\n        });\n\n        // Reflect component props as attributes\n        const reflect_attributes = () => {\n          this.$$r = true;\n          for (const key in this.$$p_d) {\n            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n            if (this.$$p_d[key].reflect) {\n              const attribute_value = get_custom_element_value(key, this.$$d[key], this.$$p_d, 'toAttribute');\n              if (attribute_value == null) {\n                this.removeAttribute(this.$$p_d[key].attribute || key);\n              } else {\n                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n              }\n            }\n          }\n          this.$$r = false;\n        };\n        this.$$c.$$.after_update.push(reflect_attributes);\n        reflect_attributes(); // once initially because after_update is added too late for first render\n\n        for (const type in this.$$l) {\n          for (const listener of this.$$l[type]) {\n            const unsub = this.$$c.$on(type, listener);\n            this.$$l_u.set(listener, unsub);\n          }\n        }\n        this.$$l = {};\n      }\n    }\n\n    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n    // and setting attributes through setAttribute etc, this is helpful\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      if (this.$$r) return;\n      attr = this.$$g_p(attr);\n      this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n      this.$$c?.$set({\n        [attr]: this.$$d[attr]\n      });\n    }\n    disconnectedCallback() {\n      this.$$cn = false;\n      // In a microtask, because this could be a move within the DOM\n      Promise.resolve().then(() => {\n        if (!this.$$cn && this.$$c) {\n          this.$$c.$destroy();\n          this.$$c = undefined;\n        }\n      });\n    }\n    $$g_p(attribute_name) {\n      return Object.keys(this.$$p_d).find(key => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name) || attribute_name;\n    }\n  };\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n  const type = props_definition[prop]?.type;\n  value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n  if (!transform || !props_definition[prop]) {\n    return value;\n  } else if (transform === 'toAttribute') {\n    switch (type) {\n      case 'Object':\n      case 'Array':\n        return value == null ? null : JSON.stringify(value);\n      case 'Boolean':\n        return value ? '' : null;\n      case 'Number':\n        return value == null ? null : value;\n      default:\n        return value;\n    }\n  } else {\n    switch (type) {\n      case 'Object':\n      case 'Array':\n        return value && JSON.parse(value);\n      case 'Boolean':\n        return value;\n      // conversion already handled above\n      case 'Number':\n        return value != null ? +value : value;\n      default:\n        return value;\n    }\n  }\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nfunction create_custom_element(Component, props_definition, slots, accessors, use_shadow_dom, extend) {\n  let Class = class extends SvelteElement {\n    constructor() {\n      super(Component, slots, use_shadow_dom);\n      this.$$p_d = props_definition;\n    }\n    static get observedAttributes() {\n      return Object.keys(props_definition).map(key => (props_definition[key].attribute || key).toLowerCase());\n    }\n  };\n  Object.keys(props_definition).forEach(prop => {\n    Object.defineProperty(Class.prototype, prop, {\n      get() {\n        return this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n      },\n      set(value) {\n        value = get_custom_element_value(prop, value, props_definition);\n        this.$$d[prop] = value;\n        this.$$c?.$set({\n          [prop]: value\n        });\n      }\n    });\n  });\n  accessors.forEach(accessor => {\n    Object.defineProperty(Class.prototype, accessor, {\n      get() {\n        return this.$$c?.[accessor];\n      }\n    });\n  });\n  if (extend) {\n    // @ts-expect-error - assigning here is fine\n    Class = extend(Class);\n  }\n  Component.element = /** @type {any} */Class;\n  return Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nclass SvelteComponent {\n  /**\n   * ### PRIVATE API\n   *\n   * Do not use, may change at any time\n   *\n   * @type {any}\n   */\n  $$ = undefined;\n  /**\n   * ### PRIVATE API\n   *\n   * Do not use, may change at any time\n   *\n   * @type {any}\n   */\n  $$set = undefined;\n\n  /** @returns {void} */\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = utils_noop;\n  }\n\n  /**\n   * @template {Extract<keyof Events, string>} K\n   * @param {K} type\n   * @param {((e: Events[K]) => void) | null | undefined} callback\n   * @returns {() => void}\n   */\n  $on(type, callback) {\n    if (!utils_is_function(callback)) {\n      return utils_noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) callbacks.splice(index, 1);\n    };\n  }\n\n  /**\n   * @param {Partial<Props>} props\n   * @returns {void}\n   */\n  $set(props) {\n    if (this.$$set && !is_empty(props)) {\n      this.$$.skip_bound = true;\n      this.$$set(props);\n      this.$$.skip_bound = false;\n    }\n  }\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/dev.js\n\n\n\n\n\n\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @returns {void}\n */\nfunction dispatch_dev(type, detail) {\n  document.dispatchEvent(custom_event(type, {\n    version: VERSION,\n    ...detail\n  }, {\n    bubbles: true\n  }));\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nfunction append_dev(target, node) {\n  dispatch_dev('SvelteDOMInsert', {\n    target,\n    node\n  });\n  append(target, node);\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nfunction append_hydration_dev(target, node) {\n  dispatch_dev('SvelteDOMInsert', {\n    target,\n    node\n  });\n  append_hydration(target, node);\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nfunction insert_dev(target, node, anchor) {\n  dispatch_dev('SvelteDOMInsert', {\n    target,\n    node,\n    anchor\n  });\n  insert(target, node, anchor);\n}\n\n/** @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nfunction insert_hydration_dev(target, node, anchor) {\n  dispatch_dev('SvelteDOMInsert', {\n    target,\n    node,\n    anchor\n  });\n  insert_hydration(target, node, anchor);\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nfunction detach_dev(node) {\n  dispatch_dev('SvelteDOMRemove', {\n    node\n  });\n  detach(node);\n}\n\n/**\n * @param {Node} before\n * @param {Node} after\n * @returns {void}\n */\nfunction detach_between_dev(before, after) {\n  while (before.nextSibling && before.nextSibling !== after) {\n    detach_dev(before.nextSibling);\n  }\n}\n\n/**\n * @param {Node} after\n * @returns {void}\n */\nfunction detach_before_dev(after) {\n  while (after.previousSibling) {\n    detach_dev(after.previousSibling);\n  }\n}\n\n/**\n * @param {Node} before\n * @returns {void}\n */\nfunction detach_after_dev(before) {\n  while (before.nextSibling) {\n    detach_dev(before.nextSibling);\n  }\n}\n\n/**\n * @param {Node} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @param {boolean} [has_prevent_default]\n * @param {boolean} [has_stop_propagation]\n * @param {boolean} [has_stop_immediate_propagation]\n * @returns {() => void}\n */\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n  const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n  if (has_prevent_default) modifiers.push('preventDefault');\n  if (has_stop_propagation) modifiers.push('stopPropagation');\n  if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');\n  dispatch_dev('SvelteDOMAddEventListener', {\n    node,\n    event,\n    handler,\n    modifiers\n  });\n  const dispose = listen(node, event, handler, options);\n  return () => {\n    dispatch_dev('SvelteDOMRemoveEventListener', {\n      node,\n      event,\n      handler,\n      modifiers\n    });\n    dispose();\n  };\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nfunction attr_dev(node, attribute, value) {\n  attr(node, attribute, value);\n  if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {\n    node,\n    attribute\n  });else dispatch_dev('SvelteDOMSetAttribute', {\n    node,\n    attribute,\n    value\n  });\n}\n\n/**\n * @param {Element} node\n * @param {string} property\n * @param {any} [value]\n * @returns {void}\n */\nfunction prop_dev(node, property, value) {\n  node[property] = value;\n  dispatch_dev('SvelteDOMSetProperty', {\n    node,\n    property,\n    value\n  });\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} property\n * @param {any} [value]\n * @returns {void}\n */\nfunction dataset_dev(node, property, value) {\n  node.dataset[property] = value;\n  dispatch_dev('SvelteDOMSetDataset', {\n    node,\n    property,\n    value\n  });\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data_dev(text, data) {\n  data = '' + data;\n  if (text.data === data) return;\n  dispatch_dev('SvelteDOMSetData', {\n    node: text,\n    data\n  });\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nfunction set_data_contenteditable_dev(text, data) {\n  data = '' + data;\n  if (text.wholeText === data) return;\n  dispatch_dev('SvelteDOMSetData', {\n    node: text,\n    data\n  });\n  text.data = /** @type {string} */data;\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n  if (~contenteditable_truthy_values.indexOf(attr_value)) {\n    set_data_contenteditable_dev(text, data);\n  } else {\n    set_data_dev(text, data);\n  }\n}\nfunction ensure_array_like_dev(arg) {\n  if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg) && !(typeof Symbol === 'function' && arg && Symbol.iterator in arg)) {\n    throw new Error('{#each} only works with iterable values.');\n  }\n  return ensure_array_like(arg);\n}\n\n/**\n * @returns {void} */\nfunction validate_slots(name, slot, keys) {\n  for (const slot_key of Object.keys(slot)) {\n    if (!~keys.indexOf(slot_key)) {\n      console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n    }\n  }\n}\n\n/**\n * @param {unknown} tag\n * @returns {void}\n */\nfunction validate_dynamic_element(tag) {\n  const is_string = typeof tag === 'string';\n  if (tag && !is_string) {\n    throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n  }\n}\n\n/**\n * @param {undefined | string} tag\n * @returns {void}\n */\nfunction validate_void_dynamic_element(tag) {\n  if (tag && is_void(tag)) {\n    console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n  }\n}\nfunction construct_svelte_component_dev(component, props) {\n  const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n  try {\n    const instance = new component(props);\n    if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n      throw new Error(error_message);\n    }\n    return instance;\n  } catch (err) {\n    const {\n      message\n    } = err;\n    if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n      throw new Error(error_message);\n    } else {\n      throw err;\n    }\n  }\n}\n\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n *\n * Can be used to create strongly typed Svelte components.\n *\n * #### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponent } from \"svelte\";\n * export class MyComponent extends SvelteComponent<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * <\/script>\n * <MyComponent foo={'bar'} />\n * ```\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n * @template {Record<string, any>} [Slots=any]\n * @extends {SvelteComponent<Props, Events>}\n */\nclass SvelteComponentDev extends SvelteComponent {\n  /**\n   * For type checking capabilities only.\n   * Does not exist at runtime.\n   * ### DO NOT USE!\n   *\n   * @type {Props}\n   */\n  $$prop_def;\n  /**\n   * For type checking capabilities only.\n   * Does not exist at runtime.\n   * ### DO NOT USE!\n   *\n   * @type {Events}\n   */\n  $$events_def;\n  /**\n   * For type checking capabilities only.\n   * Does not exist at runtime.\n   * ### DO NOT USE!\n   *\n   * @type {Slots}\n   */\n  $$slot_def;\n\n  /** @param {import('./public.js').ComponentConstructorOptions<Props>} options */\n  constructor(options) {\n    if (!options || !options.target && !options.$$inline) {\n      throw new Error(\"'target' is a required option\");\n    }\n    super();\n  }\n\n  /** @returns {void} */\n  $destroy() {\n    super.$destroy();\n    this.$destroy = () => {\n      console.warn('Component was already destroyed'); // eslint-disable-line no-console\n    };\n  }\n\n  /** @returns {void} */\n  $capture_state() {}\n\n  /** @returns {void} */\n  $inject_state() {}\n}\n/**\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n * @template {Record<string, any>} [Slots=any]\n * @deprecated Use `SvelteComponent` instead. See PR for more information: https://github.com/sveltejs/svelte/pull/8512\n * @extends {SvelteComponentDev<Props, Events, Slots>}\n */\nclass SvelteComponentTyped extends (/* unused pure expression or super */ null && (SvelteComponentDev)) {}\n\n/** @returns {() => void} */\nfunction loop_guard(timeout) {\n  const start = Date.now();\n  return () => {\n    if (Date.now() - start > timeout) {\n      throw new Error('Infinite loop detected');\n    }\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/internal/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsK0JBQStCLENBQUM7SUFDakQ7SUFDQSxLQUFLLENBQUMsQ0FBQztFQUNSOztFQUVBO0VBQ0E4bUIsUUFBUUEsQ0FBQSxFQUFHO0lBQ1YsS0FBSyxDQUFDQSxRQUFRLENBQUMsQ0FBQztJQUNoQixJQUFJLENBQUNBLFFBQVEsR0FBRyxNQUFNO01BQ3JCM0QsT0FBTyxDQUFDNkcsSUFBSSxDQUFDLGlDQUFpQyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0VBQ0Y7O0VBRUE7RUFDQWEsY0FBY0EsQ0FBQSxFQUFHLENBQUM7O0VBRWxCO0VBQ0FDLGFBQWFBLENBQUEsRUFBRyxDQUFDO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQyxvQkFBb0IsU0FBU1AsZ0RBQUFBLGtCQUFrQixHQUFDOztBQUU3RDtBQUNPLFNBQVNRLFVBQVVBLENBQUNDLE9BQU8sRUFBRTtFQUNuQyxNQUFNcmIsS0FBSyxHQUFHdEwsSUFBSSxDQUFDRixHQUFHLENBQUMsQ0FBQztFQUN4QixPQUFPLE1BQU07SUFDWixJQUFJRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxDQUFDLEdBQUd3TCxLQUFLLEdBQUdxYixPQUFPLEVBQUU7TUFDakMsTUFBTSxJQUFJanJCLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQztJQUMxQztFQUNELENBQUM7QUFDRixDOztBQzVXZ0M7QUFDQztBQUNSO0FBQ1E7QUFDSjtBQUNIO0FBQ0s7QUFDTDtBQUNLO0FBQ0g7QUFDSDtBQUNRO0FBQ047QUFDSSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvdXRpbHMuanM/OTg0ZSIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2Vudmlyb25tZW50LmpzPzM2ZTgiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9sb29wLmpzP2Q0ZmUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9nbG9iYWxzLmpzP2YxZDIiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcz9kMjU5Iiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZG9tLmpzPzBkYWMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9zdHlsZV9tYW5hZ2VyLmpzPzlkMTYiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9hbmltYXRpb25zLmpzPzE2NzQiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9saWZlY3ljbGUuanM/MjFiMiIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3NjaGVkdWxlci5qcz8xNWY3Iiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvdHJhbnNpdGlvbnMuanM/ZWI4NyIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2F3YWl0X2Jsb2NrLmpzPzEyZmMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9lYWNoLmpzP2IyMDMiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9zcHJlYWQuanM/YTAyZiIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zaGFyZWQvYm9vbGVhbl9hdHRyaWJ1dGVzLmpzPzBiNDciLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9zc3IuanM/MzQ2OCIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL0NvbXBvbmVudC5qcz9jNGFhIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZGV2LmpzPzY2NGUiLCJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9pbmRleC5qcz9lMTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKHgpID0+IHg7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAcGFyYW0ge1R9IHRhclxuICogQHBhcmFtIHtTfSBzcmNcbiAqIEByZXR1cm5zIHtUICYgU31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGZvciAoY29uc3QgayBpbiBzcmMpIHRhcltrXSA9IHNyY1trXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VCAmIFN9ICovICh0YXIpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2VMaWtlPGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiAoXG5cdFx0ISF2YWx1ZSAmJlxuXHRcdCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiZcblx0XHR0eXBlb2YgKC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpLnRoZW4pID09PSAnZnVuY3Rpb24nXG5cdCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG5cdGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcblx0XHRsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcblx0cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcblx0Zm5zLmZvckVhY2gocnVuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8IChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG59XG5cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudF9zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG5cdGlmIChlbGVtZW50X3NyYyA9PT0gdXJsKSByZXR1cm4gdHJ1ZTtcblx0aWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuXHRcdHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHR9XG5cdC8vIFRoaXMgaXMgYWN0dWFsbHkgZmFzdGVyIHRoYW4gZG9pbmcgVVJMKC4uKS5ocmVmXG5cdHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG5cdHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXQgKi9cbmZ1bmN0aW9uIHNwbGl0X3NyY3NldChzcmNzZXQpIHtcblx0cmV0dXJuIHNyY3NldC5zcGxpdCgnLCcpLm1hcCgoc3JjKSA9PiBzcmMudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTb3VyY2VFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gZWxlbWVudF9zcmNzZXRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gc3Jjc2V0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNyY3NldF91cmxfZXF1YWwoZWxlbWVudF9zcmNzZXQsIHNyY3NldCkge1xuXHRjb25zdCBlbGVtZW50X3VybHMgPSBzcGxpdF9zcmNzZXQoZWxlbWVudF9zcmNzZXQuc3Jjc2V0KTtcblx0Y29uc3QgdXJscyA9IHNwbGl0X3NyY3NldChzcmNzZXQgfHwgJycpO1xuXG5cdHJldHVybiAoXG5cdFx0dXJscy5sZW5ndGggPT09IGVsZW1lbnRfdXJscy5sZW5ndGggJiZcblx0XHR1cmxzLmV2ZXJ5KFxuXHRcdFx0KFt1cmwsIHdpZHRoXSwgaSkgPT5cblx0XHRcdFx0d2lkdGggPT09IGVsZW1lbnRfdXJsc1tpXVsxXSAmJlxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRlc3QgYm90aCB3YXlzIGJlY2F1c2UgVml0ZSB3aWxsIGNyZWF0ZSBhbiBhIGZ1bGwgVVJMIHdpdGhcblx0XHRcdFx0Ly8gYG5ldyBVUkwoYXNzZXQsIGltcG9ydC5tZXRhLnVybCkuaHJlZmAgZm9yIHRoZSBjbGllbnQgd2hlbiBgYmFzZTogJy4vJ2AsIGFuZCB0aGVcblx0XHRcdFx0Ly8gcmVsYXRpdmUgVVJMcyBpbnNpZGUgc3Jjc2V0IGFyZSBub3QgYXV0b21hdGljYWxseSByZXNvbHZlZCB0byBhYnNvbHV0ZSBVUkxzIGJ5XG5cdFx0XHRcdC8vIGJyb3dzZXJzIChpbiBjb250cmFzdCB0byBpbWcuc3JjKS4gVGhpcyBtZWFucyBib3RoIFNTUiBhbmQgRE9NIGNvZGUgY291bGRcblx0XHRcdFx0Ly8gY29udGFpbiByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxzLlxuXHRcdFx0XHQoc3JjX3VybF9lcXVhbChlbGVtZW50X3VybHNbaV1bMF0sIHVybCkgfHwgc3JjX3VybF9lcXVhbCh1cmwsIGVsZW1lbnRfdXJsc1tpXVswXSkpXG5cdFx0KVxuXHQpO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19lbXB0eShvYmopIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcblx0aWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuXHRcdFx0Y2FsbGJhY2sodW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vb3A7XG5cdH1cblx0Y29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcblx0cmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIGEgc3RvcmUgYnkgc3Vic2NyaWJpbmcgYW5kIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJpbmcuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2dldFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9zdG9yZS9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcblx0Y29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uKSB7XG5cdFx0Y29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuXHRcdHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcblx0cmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm4gPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSkgOiAkJHNjb3BlLmN0eDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG5cdFx0Y29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcblx0XHRpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGV0cztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgbWVyZ2VkID0gW107XG5cdFx0XHRjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuXHRcdFx0XHRtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXJnZWQ7XG5cdFx0fVxuXHRcdHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcblx0fVxuXHRyZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2UoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRzbG90X2NoYW5nZXMsXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRpZiAoc2xvdF9jaGFuZ2VzKSB7XG5cdFx0Y29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG5cdFx0c2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Nsb3QoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRkaXJ0eSxcblx0Z2V0X3Nsb3RfY2hhbmdlc19mbixcblx0Z2V0X3Nsb3RfY29udGV4dF9mblxuKSB7XG5cdGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG5cdHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W10gfCAtMX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuXHRpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcblx0XHRjb25zdCBkaXJ0eSA9IFtdO1xuXHRcdGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGRpcnR5W2ldID0gLTE7XG5cdFx0fVxuXHRcdHJldHVybiBkaXJ0eTtcblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoa1swXSAhPT0gJyQnKSByZXN1bHRba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcblx0Y29uc3QgcmVzdCA9IHt9O1xuXHRrZXlzID0gbmV3IFNldChrZXlzKTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJykgcmVzdFtrXSA9IHByb3BzW2tdO1xuXHRyZXR1cm4gcmVzdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuXHRcdHJlc3VsdFtrZXldID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMgeyh0aGlzOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0bGV0IHJhbiA9IGZhbHNlO1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRpZiAocmFuKSByZXR1cm47XG5cdFx0cmFuID0gdHJ1ZTtcblx0XHRmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcblx0cmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcblx0Y29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcblx0cmV0dXJuIHNwbGl0ID8gW3BhcnNlRmxvYXQoc3BsaXRbMV0pLCBzcGxpdFsyXSB8fCAncHgnXSA6IFsvKiogQHR5cGUge251bWJlcn0gKi8gKHZhbHVlKSwgJ3B4J107XG59XG5cbmV4cG9ydCBjb25zdCBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcyA9IFsnJywgdHJ1ZSwgMSwgJ3RydWUnLCAnY29udGVudGVkaXRhYmxlJ107XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmV4cG9ydCBjb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyoqIEB0eXBlIHsoKSA9PiBudW1iZXJ9ICovXG5leHBvcnQgbGV0IG5vdyA9IGlzX2NsaWVudCA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6ICgpID0+IERhdGUubm93KCk7XG5cbmV4cG9ydCBsZXQgcmFmID0gaXNfY2xpZW50ID8gKGNiKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcblxuLy8gdXNlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X25vdyhmbikge1xuXHRub3cgPSBmbjtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcblx0cmFmID0gZm47XG59XG4iLCJpbXBvcnQgeyByYWYgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG5vd1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcblx0dGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuXHRcdGlmICghdGFzay5jKG5vdykpIHtcblx0XHRcdHRhc2tzLmRlbGV0ZSh0YXNrKTtcblx0XHRcdHRhc2suZigpO1xuXHRcdH1cblx0fSk7XG5cdGlmICh0YXNrcy5zaXplICE9PSAwKSByYWYocnVuX3Rhc2tzKTtcbn1cblxuLyoqXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5IVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcl9sb29wcygpIHtcblx0dGFza3MuY2xlYXIoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlRhc2tDYWxsYmFja30gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlRhc2t9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5UYXNrRW50cnl9ICovXG5cdGxldCB0YXNrO1xuXHRpZiAodGFza3Muc2l6ZSA9PT0gMCkgcmFmKHJ1bl90YXNrcyk7XG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZTogbmV3IFByb21pc2UoKGZ1bGZpbGwpID0+IHtcblx0XHRcdHRhc2tzLmFkZCgodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSkpO1xuXHRcdH0pLFxuXHRcdGFib3J0KCkge1xuXHRcdFx0dGFza3MuZGVsZXRlKHRhc2spO1xuXHRcdH1cblx0fTtcbn1cbiIsIi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXN9ICovXG5leHBvcnQgY29uc3QgZ2xvYmFscyA9XG5cdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG5cdFx0PyB3aW5kb3dcblx0XHQ6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuXHRcdD8gZ2xvYmFsVGhpc1xuXHRcdDogLy8gQHRzLWlnbm9yZSBOb2RlIHR5cGluZ3MgaGF2ZSB0aGlzXG5cdFx0ICBnbG9iYWw7XG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcblxuLyoqXG4gKiBSZXNpemUgb2JzZXJ2ZXIgc2luZ2xldG9uLlxuICogT25lIGxpc3RlbmVyIHBlciBlbGVtZW50IG9ubHkhXG4gKiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2cvYmxpbmstZGV2L2MvejZpZW5PTlViNUEvbS9GNS1WY1VadEJBQUpcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7V2Vha01hcDxFbGVtZW50LCBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkxpc3RlbmVyPn1cblx0ICovXG5cdF9saXN0ZW5lcnMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEB0eXBlIHtSZXNpemVPYnNlcnZlcn1cblx0ICovXG5cdF9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gKi9cblx0b3B0aW9ucztcblxuXHQvKiogQHBhcmFtIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9IG9wdGlvbnMgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcn0gbGlzdGVuZXJcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRvYnNlcnZlKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcik7XG5cdFx0dGhpcy5fZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG5cdFx0XHR0aGlzLl9vYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7IC8vIHRoaXMgbGluZSBjYW4gcHJvYmFibHkgYmUgcmVtb3ZlZFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRPYnNlcnZlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIgPz9cblx0XHRcdCh0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcblx0XHRcdFx0XHR0aGlzLl9saXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCk/LihlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKVxuXHRcdCk7XG5cdH1cbn1cblxuLy8gTmVlZHMgdG8gYmUgd3JpdHRlbiBsaWtlIHRoaXMgdG8gcGFzcyB0aGUgdHJlZS1zaGFrZS10ZXN0XG5SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMsIGhhc19wcm9wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcyc7XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuXHRpc19oeWRyYXRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5kX2h5ZHJhdGluZygpIHtcblx0aXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqIEBwYXJhbSB7KGluZGV4OiBudW1iZXIpID0+IG51bWJlcn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHVwcGVyX2JvdW5kKGxvdywgaGlnaCwga2V5LCB2YWx1ZSkge1xuXHQvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG5cdHdoaWxlIChsb3cgPCBoaWdoKSB7XG5cdFx0Y29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcblx0XHRpZiAoa2V5KG1pZCkgPD0gdmFsdWUpIHtcblx0XHRcdGxvdyA9IG1pZCArIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZ2ggPSBtaWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBsb3c7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcblx0aWYgKHRhcmdldC5oeWRyYXRlX2luaXQpIHJldHVybjtcblx0dGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG5cdC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cblxuXHRsZXQgY2hpbGRyZW4gPSAvKiogQHR5cGUge0FycmF5TGlrZTxOb2RlRXgyPn0gKi8gKHRhcmdldC5jaGlsZE5vZGVzKTtcblx0Ly8gSWYgdGFyZ2V0IGlzIDxoZWFkPiwgdGhlcmUgbWF5IGJlIGNoaWxkcmVuIHdpdGhvdXQgY2xhaW1fb3JkZXJcblx0aWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG5cdFx0Y29uc3QgbXlfY2hpbGRyZW4gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBub2RlID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG15X2NoaWxkcmVuLnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNoaWxkcmVuID0gbXlfY2hpbGRyZW47XG5cdH1cblx0Lypcblx0ICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cblx0ICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuXHQgKiBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGNsYWltZWQgaW4gb3JkZXIgYW5kIG9ubHkgbW92aW5nIHRoZSByZXN0LiBUaGUgbG9uZ2VzdFxuXHQgKiBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuXHQgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuXHQgKlxuXHQgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcblx0ICogcG9zc2libGUuXG5cdCAqXG5cdCAqIFByb29mOlxuXHQgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcblx0ICogYWx3YXlzIGZvcm0gYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSwgc2luY2UgdGhleSBkbyBub3QgbW92ZSBhbW9uZyBlYWNoIG90aGVyXG5cdCAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG5cdCAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG5cdCAqL1xuXHQvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuXHQvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG5cdGNvbnN0IG0gPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGggKyAxKTtcblx0Ly8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcblx0Y29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG5cdG1bMF0gPSAtMTtcblx0bGV0IGxvbmdlc3QgPSAwO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuXHRcdC8vIEZpbmQgdGhlIGxhcmdlc3Qgc3Vic2VxdWVuY2UgbGVuZ3RoIHN1Y2ggdGhhdCBpdCBlbmRzIGluIGEgdmFsdWUgbGVzcyB0aGFuIG91ciBjdXJyZW50IHZhbHVlXG5cdFx0Ly8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcblx0XHQvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuXHRcdGNvbnN0IHNlcV9sZW4gPVxuXHRcdFx0KGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnRcblx0XHRcdFx0PyBsb25nZXN0ICsgMVxuXHRcdFx0XHQ6IHVwcGVyX2JvdW5kKDEsIGxvbmdlc3QsIChpZHgpID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG5cdFx0cFtpXSA9IG1bc2VxX2xlbl0gKyAxO1xuXHRcdGNvbnN0IG5ld19sZW4gPSBzZXFfbGVuICsgMTtcblx0XHQvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG5cdFx0bVtuZXdfbGVuXSA9IGk7XG5cdFx0bG9uZ2VzdCA9IE1hdGgubWF4KG5ld19sZW4sIGxvbmdlc3QpO1xuXHR9XG5cdC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcblxuXHQvKipcblx0ICogQHR5cGUge05vZGVFeDJbXX1cblx0ICovXG5cdGNvbnN0IGxpcyA9IFtdO1xuXHQvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Tm9kZUV4MltdfVxuXHQgKi9cblx0Y29uc3QgdG9fbW92ZSA9IFtdO1xuXHRsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG5cdGZvciAobGV0IGN1ciA9IG1bbG9uZ2VzdF0gKyAxOyBjdXIgIT0gMDsgY3VyID0gcFtjdXIgLSAxXSkge1xuXHRcdGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcblx0XHRmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuXHRcdFx0dG9fbW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcblx0XHR9XG5cdFx0bGFzdC0tO1xuXHR9XG5cdGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuXHRcdHRvX21vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdH1cblx0bGlzLnJldmVyc2UoKTtcblx0Ly8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG5cdHRvX21vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuXHQvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuXHRmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b19tb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0d2hpbGUgKGogPCBsaXMubGVuZ3RoICYmIHRvX21vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG5cdFx0XHRqKys7XG5cdFx0fVxuXHRcdGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvX21vdmVbaV0sIGFuY2hvcik7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcblx0dGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVfc2hlZXRfaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcblx0Y29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuXHRpZiAoIWFwcGVuZF9zdHlsZXNfdG8uZ2V0RWxlbWVudEJ5SWQoc3R5bGVfc2hlZXRfaWQpKSB7XG5cdFx0Y29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuXHRcdHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG5cdFx0c3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZXM7XG5cdFx0YXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7U2hhZG93Um9vdCB8IERvY3VtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcblx0aWYgKCFub2RlKSByZXR1cm4gZG9jdW1lbnQ7XG5cdGNvbnN0IHJvb3QgPSBub2RlLmdldFJvb3ROb2RlID8gbm9kZS5nZXRSb290Tm9kZSgpIDogbm9kZS5vd25lckRvY3VtZW50O1xuXHRpZiAocm9vdCAmJiAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KS5ob3N0KSB7XG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpO1xuXHR9XG5cdHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7Q1NTU3R5bGVTaGVldH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpIHtcblx0Y29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG5cdC8vIEZvciB0cmFuc2l0aW9ucyB0byB3b3JrIHdpdGhvdXQgJ3N0eWxlLXNyYzogdW5zYWZlLWlubGluZScgQ29udGVudCBTZWN1cml0eSBQb2xpY3ksXG5cdC8vIHRoZXNlIGVtcHR5IHRhZ3MgbmVlZCB0byBiZSBhbGxvd2VkIHdpdGggYSBoYXNoIGFzIGEgd29ya2Fyb3VuZCB1bnRpbCB3ZSBtb3ZlIHRvIHRoZSBXZWIgQW5pbWF0aW9ucyBBUEkuXG5cdC8vIFVzaW5nIHRoZSBoYXNoIGZvciB0aGUgZW1wdHkgc3RyaW5nIChmb3IgYW4gZW1wdHkgdGFnKSB3b3JrcyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IFNhZmFyaS5cblx0Ly8gU28gYXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgd29ya2Fyb3VuZCwgd2hlbiB3ZSBhcHBlbmQgZW1wdHkgc3R5bGUgdGFncyB3ZSBzZXQgdGhlaXIgY29udGVudCB0byAvKiBlbXB0eSAqLy5cblx0Ly8gVGhlIGhhc2ggJ3NoYTI1Ni05T2xOTzBETkVlYVZ6SEw0Ulp3Q0xzQkhBOFdCUTh0b0JwLzRGNVhWMm5jPScgd2lsbCB0aGVuIHdvcmsgZXZlbiBpbiBTYWZhcmkuXG5cdHN0eWxlX2VsZW1lbnQudGV4dENvbnRlbnQgPSAnLyogZW1wdHkgKi8nO1xuXHRhcHBlbmRfc3R5bGVzaGVldChnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSksIHN0eWxlX2VsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NoYWRvd1Jvb3QgfCBEb2N1bWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHJldHVybnMge0NTU1N0eWxlU2hlZXR9XG4gKi9cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG5cdGFwcGVuZCgvKiogQHR5cGUge0RvY3VtZW50fSAqLyAobm9kZSkuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG5cdHJldHVybiBzdHlsZS5zaGVldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVFeH0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSkge1xuXHRpZiAoaXNfaHlkcmF0aW5nKSB7XG5cdFx0aW5pdF9oeWRyYXRlKHRhcmdldCk7XG5cdFx0aWYgKFxuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0KHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsICYmIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLnBhcmVudE5vZGUgIT09IHRhcmdldClcblx0XHQpIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG5cdFx0fVxuXHRcdC8vIFNraXAgbm9kZXMgb2YgdW5kZWZpbmVkIG9yZGVyaW5nXG5cdFx0d2hpbGUgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsICYmIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHRcdGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuXHRcdFx0Ly8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcblx0XHRcdGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcblx0XHR9XG5cdH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCkge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZUV4fSBub2RlXG4gKiBAcGFyYW0ge05vZGVFeH0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHRpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcblx0XHRhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG5cdH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPSBhbmNob3IpIHtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuXHRpZiAobm9kZS5wYXJlbnROb2RlKSB7XG5cdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoaXRlcmF0aW9uc1tpXSkgaXRlcmF0aW9uc1tpXS5kKGRldGFjaGluZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpc1xuICogQHJldHVybnMge0hUTUxFbGVtZW50VGFnTmFtZU1hcFtLXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSwgeyBpcyB9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtrZXlvZiBUfSBLXG4gKiBAcGFyYW0ge1R9IG9ialxuICogQHBhcmFtIHtLW119IGV4Y2x1ZGVcbiAqIEByZXR1cm5zIHtQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcblx0Y29uc3QgdGFyZ2V0ID0gLyoqIEB0eXBlIHtQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+fSAqLyAoe30pO1xuXHRmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG5cdFx0aWYgKFxuXHRcdFx0aGFzX3Byb3Aob2JqLCBrKSAmJlxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZXhjbHVkZS5pbmRleE9mKGspID09PSAtMVxuXHRcdCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0dGFyZ2V0W2tdID0gb2JqW2tdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdmdfZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dChkYXRhKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGFjZSgpIHtcblx0cmV0dXJuIHRleHQoJyAnKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eSgpIHtcblx0cmV0dXJuIHRleHQoJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcmV0dXJucyB7Q29tbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1lbnQoY29udGVudCkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250ZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCBFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuXHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXHRyZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxmKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykgZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQuaXNUcnVzdGVkKSBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0ZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSAhPT0gdmFsdWUpIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuLyoqXG4gKiBMaXN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYWx3YXlzIGJlIHNldCB0aHJvdWdoIHRoZSBhdHRyIG1ldGhvZCxcbiAqIGJlY2F1c2UgdXBkYXRpbmcgdGhlbSB0aHJvdWdoIHRoZSBwcm9wZXJ0eSBzZXR0ZXIgZG9lc24ndCB3b3JrIHJlbGlhYmx5LlxuICogSW4gdGhlIGV4YW1wbGUgb2YgYHdpZHRoYC9gaGVpZ2h0YCwgdGhlIHByb2JsZW0gaXMgdGhhdCB0aGUgc2V0dGVyIG9ubHlcbiAqIGFjY2VwdHMgbnVtZXJpYyB2YWx1ZXMsIGJ1dCB0aGUgYXR0cmlidXRlIGNhbiBhbHNvIGJlIHNldCB0byBhIHN0cmluZyBsaWtlIGA1MCVgLlxuICogSWYgdGhpcyBsaXN0IGJlY29tZXMgdG9vIGJpZywgcmV0aGluayB0aGlzIGFwcHJvYWNoLlxuICovXG5jb25zdCBhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZSA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge3sgW3g6IHN0cmluZ106IHN0cmluZyB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuXHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0bm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcblx0XHRcdC8qKiBAdHlwZSB7YW55fSAqLyAobm9kZSkudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0gJiZcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0uc2V0ICYmXG5cdFx0XHRhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZS5pbmRleE9mKGtleSkgPT09IC0xXG5cdFx0KSB7XG5cdFx0XHRub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHt7IFt4OiBzdHJpbmddOiBzdHJpbmcgfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0YXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBkYXRhX21hcFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAobm9kZSwgZGF0YV9tYXApIHtcblx0T2JqZWN0LmtleXMoZGF0YV9tYXApLmZvckVhY2goKGtleSkgPT4ge1xuXHRcdHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIGtleSwgZGF0YV9tYXBba2V5XSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG5cdGNvbnN0IGxvd2VyID0gcHJvcC50b0xvd2VyQ2FzZSgpOyAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBiZWhhdmlvciB3ZSBkbyBsb3dlcmNhc2UgZmlyc3Rcblx0aWYgKGxvd2VyIGluIG5vZGUpIHtcblx0XHRub2RlW2xvd2VyXSA9IHR5cGVvZiBub2RlW2xvd2VyXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcblx0fSBlbHNlIGlmIChwcm9wIGluIG5vZGUpIHtcblx0XHRub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0YXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZHluYW1pY19lbGVtZW50X2RhdGEodGFnKSB7XG5cdHJldHVybiAvLS8udGVzdCh0YWcpID8gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwIDogc2V0X2F0dHJpYnV0ZXM7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0bm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3ZlbHRlX2RhdGFzZXQobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5kYXRhc2V0LnN2ZWx0ZUg7XG59XG5cbi8qKlxuICogQHJldHVybnMge3Vua25vd25bXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuXHRjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChncm91cFtpXS5jaGVja2VkKSB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG5cdH1cblx0aWYgKCFjaGVja2VkKSB7XG5cdFx0dmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuXHR9XG5cdHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnRbXX0gZ3JvdXBcbiAqIEByZXR1cm5zIHt7IHAoLi4uaW5wdXRzOiBIVE1MSW5wdXRFbGVtZW50W10pOiB2b2lkOyByKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfaW5wdXRzO1xuXHRyZXR1cm4ge1xuXHRcdC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcblx0XHRcdF9pbnB1dHMgPSBpbnB1dHM7XG5cdFx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBncm91cC5wdXNoKGlucHV0KSk7XG5cdFx0fSxcblx0XHQvKiByZW1vdmUgKi8gcigpIHtcblx0XHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IGdyb3VwLnNwbGljZShncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzXG4gKiBAcmV0dXJucyB7eyB1KG5ld19pbmRleGVzOiBudW1iZXJbXSk6IHZvaWQ7IHAoLi4uaW5wdXRzOiBIVE1MSW5wdXRFbGVtZW50W10pOiB2b2lkOyByOiAoKSA9PiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwX2R5bmFtaWMoZ3JvdXAsIGluZGV4ZXMpIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfaW5wdXRzO1xuXG5cdGZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRncm91cCA9IGdyb3VwW2luZGV4ZXNbaV1dID0gZ3JvdXBbaW5kZXhlc1tpXV0gfHwgW107XG5cdFx0fVxuXHRcdHJldHVybiBncm91cDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gcHVzaCgpIHtcblx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBfZ3JvdXAucHVzaChpbnB1dCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gX2dyb3VwLnNwbGljZShfZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdC8qIHVwZGF0ZSAqLyB1KG5ld19pbmRleGVzKSB7XG5cdFx0XHRpbmRleGVzID0gbmV3X2luZGV4ZXM7XG5cdFx0XHRjb25zdCBuZXdfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG5cdFx0XHRpZiAobmV3X2dyb3VwICE9PSBfZ3JvdXApIHtcblx0XHRcdFx0cmVtb3ZlKCk7XG5cdFx0XHRcdF9ncm91cCA9IG5ld19ncm91cDtcblx0XHRcdFx0cHVzaCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuXHRcdFx0X2lucHV0cyA9IGlucHV0cztcblx0XHRcdHB1c2goKTtcblx0XHR9LFxuXHRcdC8qIHJlbW92ZSAqLyByOiByZW1vdmVcblx0fTtcbn1cblxuLyoqIEByZXR1cm5zIHtudW1iZXJ9ICovXG5leHBvcnQgZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuXHRjb25zdCBhcnJheSA9IFtdO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG5cdH1cblx0cmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0NoaWxkTm9kZVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG5cdGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcblx0XHRub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge0NoaWxkTm9kZUV4fSBSXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IG5vZGUgaXMgUn0gcHJlZGljYXRlXG4gKiBAcGFyYW0geyhub2RlOiBDaGlsZE5vZGVFeCkgPT4gQ2hpbGROb2RlRXggfCB1bmRlZmluZWR9IHByb2Nlc3Nfbm9kZVxuICogQHBhcmFtIHsoKSA9PiBSfSBjcmVhdGVfbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBkb250X3VwZGF0ZV9sYXN0X2luZGV4XG4gKiBAcmV0dXJucyB7Un1cbiAqL1xuZnVuY3Rpb24gY2xhaW1fbm9kZShub2RlcywgcHJlZGljYXRlLCBwcm9jZXNzX25vZGUsIGNyZWF0ZV9ub2RlLCBkb250X3VwZGF0ZV9sYXN0X2luZGV4ID0gZmFsc2UpIHtcblx0Ly8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Vcblx0aW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcblx0Y29uc3QgcmVzdWx0X25vZGUgPSAoKCkgPT4ge1xuXHRcdC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuXHRcdGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0aWYgKHByZWRpY2F0ZShub2RlKSkge1xuXHRcdFx0XHRjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3Nfbm9kZShub2RlKTtcblx0XHRcdFx0aWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub2Rlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZXNbaV0gPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRvbnRfdXBkYXRlX2xhc3RfaW5kZXgpIHtcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcblx0XHQvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzX25vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250X3VwZGF0ZV9sYXN0X2luZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcblx0XHRyZXR1cm4gY3JlYXRlX25vZGUoKTtcblx0fSkoKTtcblx0cmVzdWx0X25vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG5cdG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuXHRyZXR1cm4gcmVzdWx0X25vZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0geyhuYW1lOiBzdHJpbmcpID0+IEVsZW1lbnQgfCBTVkdFbGVtZW50fSBjcmVhdGVfZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSxcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdGNvbnN0IHJlbW92ZSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuXHRcdFx0XHRpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG5cdFx0XHRcdFx0cmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZW1vdmUuZm9yRWFjaCgodikgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdCgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcblx0cmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIFRleHR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsXG5cdFx0LyoqIEBwYXJhbSB7VGV4dH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRjb25zdCBkYXRhX3N0ciA9ICcnICsgZGF0YTtcblx0XHRcdGlmIChub2RlLmRhdGEuc3RhcnRzV2l0aChkYXRhX3N0cikpIHtcblx0XHRcdFx0aWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFfc3RyLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhX3N0ci5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLmRhdGEgPSBkYXRhX3N0cjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdCgpID0+IHRleHQoZGF0YSksXG5cdFx0dHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcblx0KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuXHRyZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9jb21tZW50KG5vZGVzLCBkYXRhKSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBDb21tZW50fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4LFxuXHRcdC8qKiBAcGFyYW0ge0NvbW1lbnR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0bm9kZS5kYXRhID0gJycgKyBkYXRhO1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdCgpID0+IGNvbW1lbnQoZGF0YSksXG5cdFx0dHJ1ZVxuXHQpO1xufVxuXG5mdW5jdGlvbiBnZXRfY29tbWVudF9pZHgobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG5cdGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3N2Z1xuICogQHJldHVybnMge0h0bWxUYWdIeWRyYXRpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG5cdC8vIGZpbmQgaHRtbCBvcGVuaW5nIHRhZ1xuXHRjb25zdCBzdGFydF9pbmRleCA9IGdldF9jb21tZW50X2lkeChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG5cdGNvbnN0IGVuZF9pbmRleCA9IGdldF9jb21tZW50X2lkeChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4ICsgMSk7XG5cdGlmIChzdGFydF9pbmRleCA9PT0gLTEgfHwgZW5kX2luZGV4ID09PSAtMSkge1xuXHRcdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcpO1xuXHR9XG5cblx0aW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcblx0Y29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG5cdGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG5cdGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG5cdGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcblx0aWYgKGNsYWltZWRfbm9kZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGlzX3N2Zyk7XG5cdH1cblx0Zm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcblx0XHRuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRcdG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuXHR9XG5cdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcsIGNsYWltZWRfbm9kZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQuZGF0YSA9PT0gZGF0YSkgcmV0dXJuO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSkgcmV0dXJuO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cl92YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuXHRpZiAofmNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLmluZGV4T2YoYXR0cl92YWx1ZSkpIHtcblx0XHRzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSk7XG5cdH0gZWxzZSB7XG5cdFx0c2V0X2RhdGEodGV4dCwgZGF0YSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG5cdGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcblx0dHJ5IHtcblx0XHRpbnB1dC50eXBlID0gdHlwZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGRvIG5vdGhpbmdcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdH0gZWxzZSB7XG5cdFx0bm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuXHRcdGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuXHRcdG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X3ZhbHVlKHNlbGVjdCkge1xuXHRjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcblx0cmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcblx0cmV0dXJuIFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLCAob3B0aW9uKSA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcblxuLyoqXG4gKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbmxldCBjcm9zc29yaWdpbjtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jcm9zc29yaWdpbigpIHtcblx0aWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcblx0XHRjcm9zc29yaWdpbiA9IGZhbHNlO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuXHRcdFx0XHR2b2lkIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNyb3Nzb3JpZ2luID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNyb3Nzb3JpZ2luO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2lmcmFtZV9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcblx0Y29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG5cdFx0bm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdH1cblx0Y29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG5cdGlmcmFtZS5zZXRBdHRyaWJ1dGUoXG5cdFx0J3N0eWxlJyxcblx0XHQnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcblx0XHRcdCdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnXG5cdCk7XG5cdGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblx0aWZyYW1lLnRhYkluZGV4ID0gLTE7XG5cdGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcblxuXHQvKipcblx0ICogQHR5cGUgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRsZXQgdW5zdWJzY3JpYmU7XG5cdGlmIChjcm9zc29yaWdpbikge1xuXHRcdGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuXHRcdHVuc3Vic2NyaWJlID0gbGlzdGVuKFxuXHRcdFx0d2luZG93LFxuXHRcdFx0J21lc3NhZ2UnLFxuXHRcdFx0LyoqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudCAqLyAoZXZlbnQpID0+IHtcblx0XHRcdFx0aWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpIGZuKCk7XG5cdFx0XHR9XG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcblx0XHRpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0dW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG5cdFx0XHQvLyBtYWtlIHN1cmUgYW4gaW5pdGlhbCByZXNpemUgZXZlbnQgaXMgZmlyZWQgX2FmdGVyXyB0aGUgaWZyYW1lIGlzIGxvYWRlZCAod2hpY2ggaXMgYXN5bmNocm9ub3VzKVxuXHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzQyMzNcblx0XHRcdGZuKCk7XG5cdFx0fTtcblx0fVxuXHRhcHBlbmQobm9kZSwgaWZyYW1lKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoY3Jvc3NvcmlnaW4pIHtcblx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0fSBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuXHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdFx0ZGV0YWNoKGlmcmFtZSk7XG5cdH07XG59XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2NvbnRlbnQtYm94J1xufSk7XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnYm9yZGVyLWJveCdcbn0pO1xuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9kZXZpY2VfcGl4ZWxfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKFxuXHR7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfVxuKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIH07XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuXHQvLyBUaGUgYCEhYCBpcyByZXF1aXJlZCBiZWNhdXNlIGFuIGB1bmRlZmluZWRgIGZsYWcgbWVhbnMgZmxpcHBpbmcgdGhlIGN1cnJlbnQgc3RhdGUuXG5cdGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShuYW1lLCAhIXRvZ2dsZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge3sgYnViYmxlcz86IGJvb2xlYW4sIGNhbmNlbGFibGU/OiBib29sZWFuIH19IFtvcHRpb25zXVxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge0NoaWxkTm9kZUFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG5cdHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVJZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaGVhZFxuICogQHJldHVybnMge2FueVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZF9zZWxlY3Rvcihub2RlSWQsIGhlYWQpIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBzdGFydGVkID0gMDtcblx0Zm9yIChjb25zdCBub2RlIG9mIGhlYWQuY2hpbGROb2Rlcykge1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLykge1xuXHRcdFx0Y29uc3QgY29tbWVudCA9IG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuXHRcdFx0aWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9FTkRgKSB7XG5cdFx0XHRcdHN0YXJ0ZWQgLT0gMTtcblx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9TVEFSVGApIHtcblx0XHRcdFx0c3RhcnRlZCArPSAxO1xuXHRcdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHN0YXJ0ZWQgPiAwKSB7XG5cdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIEh0bWxUYWcge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdGlzX3N2ZyA9IGZhbHNlO1xuXHQvKiogcGFyZW50IGZvciBjcmVhdGluZyBub2RlICovXG5cdGUgPSB1bmRlZmluZWQ7XG5cdC8qKiBodG1sIHRhZyBub2RlcyAqL1xuXHRuID0gdW5kZWZpbmVkO1xuXHQvKiogdGFyZ2V0ICovXG5cdHQgPSB1bmRlZmluZWQ7XG5cdC8qKiBhbmNob3IgKi9cblx0YSA9IHVuZGVmaW5lZDtcblx0Y29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UpIHtcblx0XHR0aGlzLmlzX3N2ZyA9IGlzX3N2Zztcblx0XHR0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0YyhodG1sKSB7XG5cdFx0dGhpcy5oKGh0bWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSB0YXJnZXRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IGFuY2hvclxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG5cdFx0aWYgKCF0aGlzLmUpIHtcblx0XHRcdGlmICh0aGlzLmlzX3N2Zylcblx0XHRcdFx0dGhpcy5lID0gc3ZnX2VsZW1lbnQoLyoqIEB0eXBlIHtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcH0gKi8gKHRhcmdldC5ub2RlTmFtZSkpO1xuXHRcdFx0LyoqICM3MzY0ICB0YXJnZXQgZm9yIDx0ZW1wbGF0ZT4gbWF5IGJlIHByb3ZpZGVkIGFzICNkb2N1bWVudC1mcmFnbWVudCgxMSkgKi8gZWxzZVxuXHRcdFx0XHR0aGlzLmUgPSBlbGVtZW50KFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSAqLyAoXG5cdFx0XHRcdFx0XHR0YXJnZXQubm9kZVR5cGUgPT09IDExID8gJ1RFTVBMQVRFJyA6IHRhcmdldC5ub2RlTmFtZVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblx0XHRcdHRoaXMudCA9XG5cdFx0XHRcdHRhcmdldC50YWdOYW1lICE9PSAnVEVNUExBVEUnXG5cdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHQ6IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKHRhcmdldCkuY29udGVudDtcblx0XHRcdHRoaXMuYyhodG1sKTtcblx0XHR9XG5cdFx0dGhpcy5pKGFuY2hvcik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRoKGh0bWwpIHtcblx0XHR0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcblx0XHR0aGlzLm4gPSBBcnJheS5mcm9tKFxuXHRcdFx0dGhpcy5lLm5vZGVOYW1lID09PSAnVEVNUExBVEUnID8gdGhpcy5lLmNvbnRlbnQuY2hpbGROb2RlcyA6IHRoaXMuZS5jaGlsZE5vZGVzXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0aShhbmNob3IpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdHAoaHRtbCkge1xuXHRcdHRoaXMuZCgpO1xuXHRcdHRoaXMuaChodG1sKTtcblx0XHR0aGlzLmkodGhpcy5hKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZCgpIHtcblx0XHR0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG5cdC8qKiBAdHlwZSB7RWxlbWVudFtdfSBoeWRyYXRpb24gY2xhaW1lZCBub2RlcyAqL1xuXHRsID0gdW5kZWZpbmVkO1xuXG5cdGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlLCBjbGFpbWVkX25vZGVzKSB7XG5cdFx0c3VwZXIoaXNfc3ZnKTtcblx0XHR0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuXHRcdHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjKGh0bWwpIHtcblx0XHRpZiAodGhpcy5sKSB7XG5cdFx0XHR0aGlzLm4gPSB0aGlzLmw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN1cGVyLmMoaHRtbCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRpKGFuY2hvcikge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TmFtZWROb2RlTWFwfSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcblx0XHRyZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGVzY2FwZWQgPSB7XG5cdCdcIic6ICcmcXVvdDsnLFxuXHQnJic6ICcmYW1wOycsXG5cdCc8JzogJyZsdDsnXG59O1xuXG5jb25zdCByZWdleF9hdHRyaWJ1dGVfY2hhcmFjdGVyc190b19lc2NhcGUgPSAvW1wiJjxdL2c7XG5cbi8qKlxuICogTm90ZSB0aGF0IHRoZSBhdHRyaWJ1dGUgaXRzZWxmIHNob3VsZCBiZSBzdXJyb3VuZGVkIGluIGRvdWJsZSBxdW90ZXNcbiAqIEBwYXJhbSB7YW55fSBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcblx0cmV0dXJuIFN0cmluZyhhdHRyaWJ1dGUpLnJlcGxhY2UocmVnZXhfYXR0cmlidXRlX2NoYXJhY3RlcnNfdG9fZXNjYXBlLCAobWF0Y2gpID0+IGVzY2FwZWRbbWF0Y2hdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IGF0dHJpYnV0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeV9zcHJlYWQoYXR0cmlidXRlcykge1xuXHRsZXQgc3RyID0gJyAnO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0aWYgKGF0dHJpYnV0ZXNba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRzdHIgKz0gYCR7a2V5fT1cIiR7ZXNjYXBlX2F0dHJpYnV0ZShhdHRyaWJ1dGVzW2tleV0pfVwiIGA7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKFxuXHRcdC8qKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgKi8gKG5vZGUpID0+IHtcblx0XHRcdHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG5cdFx0fVxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQoY29tcG9uZW50LCBwcm9wcykge1xuXHRyZXR1cm4gbmV3IGNvbXBvbmVudChwcm9wcyk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge05vZGUgJiB7XG4gKiBcdGNsYWltX29yZGVyPzogbnVtYmVyO1xuICogXHRoeWRyYXRlX2luaXQ/OiB0cnVlO1xuICogXHRhY3R1YWxfZW5kX2NoaWxkPzogTm9kZUV4O1xuICogXHRjaGlsZE5vZGVzOiBOb2RlTGlzdE9mPE5vZGVFeD47XG4gKiB9fSBOb2RlRXhcbiAqL1xuXG4vKiogQHR5cGVkZWYge0NoaWxkTm9kZSAmIE5vZGVFeH0gQ2hpbGROb2RlRXggKi9cblxuLyoqIEB0eXBlZGVmIHtOb2RlRXggJiB7IGNsYWltX29yZGVyOiBudW1iZXIgfX0gTm9kZUV4MiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtDaGlsZE5vZGVFeFtdICYge1xuICogXHRjbGFpbV9pbmZvPzoge1xuICogXHRcdGxhc3RfaW5kZXg6IG51bWJlcjtcbiAqIFx0XHR0b3RhbF9jbGFpbWVkOiBudW1iZXI7XG4gKiBcdH07XG4gKiB9fSBDaGlsZE5vZGVBcnJheVxuICovXG4iLCJpbXBvcnQgeyBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldCwgZGV0YWNoLCBnZXRfcm9vdF9mb3Jfc3R5bGUgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyByYWYgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcblxuLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gZm9yIG11bHRpcGxlIGRvY3VtZW50cyBiZWNhdXNlIGEgU3ZlbHRlIGFwcGxpY2F0aW9uIGNvdWxkIGFsc28gY29udGFpbiBpZnJhbWVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8zNjI0XG4vKiogQHR5cGUge01hcDxEb2N1bWVudCB8IFNoYWRvd1Jvb3QsIGltcG9ydCgnLi9wcml2YXRlLmQudHMnKS5TdHlsZUluZm9ybWF0aW9uPn0gKi9cbmNvbnN0IG1hbmFnZWRfc3R5bGVzID0gbmV3IE1hcCgpO1xuXG5sZXQgYWN0aXZlID0gMDtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcblx0bGV0IGhhc2ggPSA1MzgxO1xuXHRsZXQgaSA9IHN0ci5sZW5ndGg7XG5cdHdoaWxlIChpLS0pIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuXHRyZXR1cm4gaGFzaCA+Pj4gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50IHwgU2hhZG93Um9vdH0gZG9jXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEByZXR1cm5zIHt7IHN0eWxlc2hlZXQ6IGFueTsgcnVsZXM6IHt9OyB9fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKSB7XG5cdGNvbnN0IGluZm8gPSB7IHN0eWxlc2hlZXQ6IGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpLCBydWxlczoge30gfTtcblx0bWFuYWdlZF9zdHlsZXMuc2V0KGRvYywgaW5mbyk7XG5cdHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheVxuICogQHBhcmFtIHsodDogbnVtYmVyKSA9PiBudW1iZXJ9IGVhc2VcbiAqIEBwYXJhbSB7KHQ6IG51bWJlciwgdTogbnVtYmVyKSA9PiBzdHJpbmd9IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gdWlkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbiwgdWlkID0gMCkge1xuXHRjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG5cdGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG5cdGZvciAobGV0IHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuXHRcdGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG5cdFx0a2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcblx0fVxuXHRjb25zdCBydWxlID0ga2V5ZnJhbWVzICsgYDEwMCUgeyR7Zm4oYiwgMSAtIGIpfX1cXG59YDtcblx0Y29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG5cdGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcblx0Y29uc3QgeyBzdHlsZXNoZWV0LCBydWxlcyB9ID0gbWFuYWdlZF9zdHlsZXMuZ2V0KGRvYykgfHwgY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSk7XG5cdGlmICghcnVsZXNbbmFtZV0pIHtcblx0XHRydWxlc1tuYW1lXSA9IHRydWU7XG5cdFx0c3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcblx0fVxuXHRjb25zdCBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcblx0bm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHtcblx0XHRhbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJydcblx0fSR7bmFtZX0gJHtkdXJhdGlvbn1tcyBsaW5lYXIgJHtkZWxheX1tcyAxIGJvdGhgO1xuXHRhY3RpdmUgKz0gMTtcblx0cmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcblx0Y29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuXHRjb25zdCBuZXh0ID0gcHJldmlvdXMuZmlsdGVyKFxuXHRcdG5hbWVcblx0XHRcdD8gKGFuaW0pID0+IGFuaW0uaW5kZXhPZihuYW1lKSA8IDAgLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuXHRcdFx0OiAoYW5pbSkgPT4gYW5pbS5pbmRleE9mKCdfX3N2ZWx0ZScpID09PSAtMSAvLyByZW1vdmUgYWxsIFN2ZWx0ZSBhbmltYXRpb25zXG5cdCk7XG5cdGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcblx0aWYgKGRlbGV0ZWQpIHtcblx0XHRub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcblx0XHRhY3RpdmUgLT0gZGVsZXRlZDtcblx0XHRpZiAoIWFjdGl2ZSkgY2xlYXJfcnVsZXMoKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG5cdHJhZigoKSA9PiB7XG5cdFx0aWYgKGFjdGl2ZSkgcmV0dXJuO1xuXHRcdG1hbmFnZWRfc3R5bGVzLmZvckVhY2goKGluZm8pID0+IHtcblx0XHRcdGNvbnN0IHsgb3duZXJOb2RlIH0gPSBpbmZvLnN0eWxlc2hlZXQ7XG5cdFx0XHQvLyB0aGVyZSBpcyBubyBvd25lck5vZGUgaWYgaXQgcnVucyBvbiBqc2RvbS5cblx0XHRcdGlmIChvd25lck5vZGUpIGRldGFjaChvd25lck5vZGUpO1xuXHRcdH0pO1xuXHRcdG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG5cdH0pO1xufVxuIiwiaW1wb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyLCBub29wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmltcG9ydCB7IGxvb3AgfSBmcm9tICcuL2xvb3AuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3J1bGUsIGRlbGV0ZV9ydWxlIH0gZnJvbSAnLi9zdHlsZV9tYW5hZ2VyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Qb3NpdGlvblJlY3R9IGZyb21cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5BbmltYXRpb25Gbn0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuXHRpZiAoIWZyb20pIHJldHVybiBub29wO1xuXHRjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdGlmIChcblx0XHRmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiZcblx0XHRmcm9tLnJpZ2h0ID09PSB0by5yaWdodCAmJlxuXHRcdGZyb20udG9wID09PSB0by50b3AgJiZcblx0XHRmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tXG5cdClcblx0XHRyZXR1cm4gbm9vcDtcblx0Y29uc3Qge1xuXHRcdGRlbGF5ID0gMCxcblx0XHRkdXJhdGlvbiA9IDMwMCxcblx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0Ly8gQHRzLWlnbm9yZSB0b2RvOiBzaG91bGQgdGhpcyBiZSBzZXBhcmF0ZWQgZnJvbSBkZXN0cnVjdHVyaW5nPyBPciBzdGFydC9lbmQgYWRkZWQgdG8gcHVibGljIGFwaSBhbmQgZG9jdW1lbnRhdGlvbj9cblx0XHRzdGFydDogc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXksXG5cdFx0Ly8gQHRzLWlnbm9yZSB0b2RvOlxuXHRcdGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbixcblx0XHR0aWNrID0gbm9vcCxcblx0XHRjc3Ncblx0fSA9IGZuKG5vZGUsIHsgZnJvbSwgdG8gfSwgcGFyYW1zKTtcblx0bGV0IHJ1bm5pbmcgPSB0cnVlO1xuXHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRsZXQgbmFtZTtcblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBzdGFydCgpIHtcblx0XHRpZiAoY3NzKSB7XG5cdFx0XHRuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG5cdFx0fVxuXHRcdGlmICghZGVsYXkpIHtcblx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0aWYgKGNzcykgZGVsZXRlX3J1bGUobm9kZSwgbmFtZSk7XG5cdFx0cnVubmluZyA9IGZhbHNlO1xuXHR9XG5cdGxvb3AoKG5vdykgPT4ge1xuXHRcdGlmICghc3RhcnRlZCAmJiBub3cgPj0gc3RhcnRfdGltZSkge1xuXHRcdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmQpIHtcblx0XHRcdHRpY2soMSwgMCk7XG5cdFx0XHRzdG9wKCk7XG5cdFx0fVxuXHRcdGlmICghcnVubmluZykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoc3RhcnRlZCkge1xuXHRcdFx0Y29uc3QgcCA9IG5vdyAtIHN0YXJ0X3RpbWU7XG5cdFx0XHRjb25zdCB0ID0gMCArIDEgKiBlYXNpbmcocCAvIGR1cmF0aW9uKTtcblx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSk7XG5cdHN0YXJ0KCk7XG5cdHRpY2soMCwgMSk7XG5cdHJldHVybiBzdG9wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfcG9zaXRpb24obm9kZSkge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG5cdFx0Y29uc3QgYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0bm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0bm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdG5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGFkZF90cmFuc2Zvcm0obm9kZSwgYSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Qb3NpdGlvblJlY3R9IGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX3RyYW5zZm9ybShub2RlLCBhKSB7XG5cdGNvbnN0IGIgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG5cdFx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRcdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdFx0bm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG5cdH1cbn1cbiIsImltcG9ydCB7IGN1c3RvbV9ldmVudCB9IGZyb20gJy4vZG9tLmpzJztcblxuZXhwb3J0IGxldCBjdXJyZW50X2NvbXBvbmVudDtcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcblx0Y3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG5cdGlmICghY3VycmVudF9jb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG5cdHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZCBhZnRlciBhbnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYmVmb3JlIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNiZWZvcmV1cGRhdGVcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBJZiBhIGZ1bmN0aW9uIGlzIHJldHVybmVkIF9zeW5jaHJvbm91c2x5XyBmcm9tIGBvbk1vdW50YCwgaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBhIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXNlcnZlci1zaWRlLWNvbXBvbmVudC1hcGkpLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNvbm1vdW50XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLk5vdEZ1bmN0aW9uPFQ+IHwgUHJvbWlzZTxpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLk5vdEZ1bmN0aW9uPFQ+PiB8ICgoKSA9PiBhbnkpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1vdW50KGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBhZnRlciB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjYWZ0ZXJ1cGRhdGVcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNvbmRlc3Ryb3lcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjdGVtcGxhdGUtc3ludGF4LWNvbXBvbmVudC1kaXJlY3RpdmVzLW9uLWV2ZW50bmFtZSkuXG4gKiBFdmVudCBkaXNwYXRjaGVycyBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHRha2UgdHdvIGFyZ3VtZW50czogYG5hbWVgIGFuZCBgZGV0YWlsYC5cbiAqXG4gKiBDb21wb25lbnQgZXZlbnRzIGNyZWF0ZWQgd2l0aCBgY3JlYXRlRXZlbnREaXNwYXRjaGVyYCBjcmVhdGUgYVxuICogW0N1c3RvbUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpLlxuICogVGhlc2UgZXZlbnRzIGRvIG5vdCBbYnViYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0xlYXJuL0phdmFTY3JpcHQvQnVpbGRpbmdfYmxvY2tzL0V2ZW50cyNFdmVudF9idWJibGluZ19hbmRfY2FwdHVyZSkuXG4gKiBUaGUgYGRldGFpbGAgYXJndW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIFtDdXN0b21FdmVudC5kZXRhaWxdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9kZXRhaWwpXG4gKiBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YS5cbiAqXG4gKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBjYW4gYmUgdHlwZWQgdG8gbmFycm93IHRoZSBhbGxvd2VkIGV2ZW50IG5hbWVzIGFuZCB0aGUgdHlwZSBvZiB0aGUgYGRldGFpbGAgYXJndW1lbnQ6XG4gKiBgYGB0c1xuICogY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXI8e1xuICogIGxvYWRlZDogbmV2ZXI7IC8vIGRvZXMgbm90IHRha2UgYSBkZXRhaWwgYXJndW1lbnRcbiAqICBjaGFuZ2U6IHN0cmluZzsgLy8gdGFrZXMgYSBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcsIHdoaWNoIGlzIHJlcXVpcmVkXG4gKiAgb3B0aW9uYWw6IG51bWJlciB8IG51bGw7IC8vIHRha2VzIGFuIG9wdGlvbmFsIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIG51bWJlclxuICogfT4oKTtcbiAqIGBgYFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNjcmVhdGVldmVudGRpc3BhdGNoZXJcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50TWFwPWFueV1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuRXZlbnREaXNwYXRjaGVyPEV2ZW50TWFwPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcblx0Y29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG5cdHJldHVybiAodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pID0+IHtcblx0XHRjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuXHRcdGlmIChjYWxsYmFja3MpIHtcblx0XHRcdC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcblx0XHRcdC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cblx0XHRcdGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGRldGFpbCwgeyBjYW5jZWxhYmxlIH0pO1xuXHRcdFx0Y2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaCgoZm4pID0+IHtcblx0XHRcdFx0Zm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNzZXRjb250ZXh0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHBhcmFtIHtUfSBjb250ZXh0XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG5cdHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgYGtleWAuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNnZXRjb250ZXh0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHdob2xlIGNvbnRleHQgbWFwIHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi4gVXNlZnVsLCBmb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbXBvbmVudCBhbmQgd2FudCB0byBwYXNzIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGl0LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNnZXRhbGxjb250ZXh0c1xuICogQHRlbXBsYXRlIHtNYXA8YW55LCBhbnk+fSBbVD1NYXA8YW55LCBhbnk+XVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBga2V5YCBoYXMgYmVlbiBzZXQgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjaGFzY29udGV4dFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cblxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbi8qKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHBhcmFtIGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG5cdGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG5cdGlmIChjYWxsYmFja3MpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0Y2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaCgoZm4pID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcblx0fVxufVxuIiwiaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcblxuZXhwb3J0IGNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmV4cG9ydCBjb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5leHBvcnQgY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcblxubGV0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcblxuY29uc3QgZmx1c2hfY2FsbGJhY2tzID0gW107XG5cbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG5cdGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuXHRcdHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuXHRcdHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpY2soKSB7XG5cdHNjaGVkdWxlX3VwZGF0ZSgpO1xuXHRyZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcblx0cmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuXHRmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG5cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoKCkge1xuXHQvLyBEbyBub3QgcmVlbnRlciBmbHVzaCB3aGlsZSBkaXJ0eSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBhcyB0aGlzIGNhblxuXHQvLyByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcC4gSW5zdGVhZCwgbGV0IHRoZSBpbm5lciBmbHVzaCBoYW5kbGUgaXQuXG5cdC8vIFJlZW50cmFuY3kgaXMgb2sgYWZ0ZXJ3YXJkcyBmb3IgYmluZGluZ3MgZXRjLlxuXHRpZiAoZmx1c2hpZHggIT09IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG5cdGRvIHtcblx0XHQvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG5cdFx0Ly8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG5cdFx0dHJ5IHtcblx0XHRcdHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuXHRcdFx0XHRmbHVzaGlkeCsrO1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0XHRcdFx0dXBkYXRlKGNvbXBvbmVudC4kJCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gcmVzZXQgZGlydHkgc3RhdGUgdG8gbm90IGVuZCB1cCBpbiBhIGRlYWRsb2NrZWQgc3RhdGUgYW5kIHRoZW4gcmV0aHJvd1xuXHRcdFx0ZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0Zmx1c2hpZHggPSAwO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuXHRcdGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcblx0XHRmbHVzaGlkeCA9IDA7XG5cdFx0d2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aCkgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcblx0XHQvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcblx0XHQvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG5cdFx0Ly8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG5cdFx0XHRpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcblx0XHRcdFx0Ly8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG5cdH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcblx0d2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcblx0fVxuXHR1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5cdHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcblx0aWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG5cdFx0JCQudXBkYXRlKCk7XG5cdFx0cnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcblx0XHRjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuXHRcdCQkLmRpcnR5ID0gWy0xXTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuXHRcdCQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuXHR9XG59XG5cbi8qKlxuICogVXNlZnVsIGZvciBleGFtcGxlIHRvIGV4ZWN1dGUgcmVtYWluaW5nIGBhZnRlclVwZGF0ZWAgY2FsbGJhY2tzIGJlZm9yZSBleGVjdXRpbmcgYGRlc3Ryb3lgLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfcmVuZGVyX2NhbGxiYWNrcyhmbnMpIHtcblx0Y29uc3QgZmlsdGVyZWQgPSBbXTtcblx0Y29uc3QgdGFyZ2V0cyA9IFtdO1xuXHRyZW5kZXJfY2FsbGJhY2tzLmZvckVhY2goKGMpID0+IChmbnMuaW5kZXhPZihjKSA9PT0gLTEgPyBmaWx0ZXJlZC5wdXNoKGMpIDogdGFyZ2V0cy5wdXNoKGMpKSk7XG5cdHRhcmdldHMuZm9yRWFjaCgoYykgPT4gYygpKTtcblx0cmVuZGVyX2NhbGxiYWNrcyA9IGZpbHRlcmVkO1xufVxuIiwiaW1wb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyLCBpc19mdW5jdGlvbiwgbm9vcCwgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBsb29wIH0gZnJvbSAnLi9sb29wLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ydWxlLCBkZWxldGVfcnVsZSB9IGZyb20gJy4vc3R5bGVfbWFuYWdlci5qcyc7XG5pbXBvcnQgeyBjdXN0b21fZXZlbnQgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBhZGRfcmVuZGVyX2NhbGxiYWNrIH0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtQcm9taXNlPHZvaWQ+IHwgbnVsbH1cbiAqL1xubGV0IHByb21pc2U7XG5cbi8qKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHdhaXQoKSB7XG5cdGlmICghcHJvbWlzZSkge1xuXHRcdHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRwcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdFx0cHJvbWlzZSA9IG51bGw7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHByb21pc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0lOVFJPIHwgT1VUUk8gfCBib29sZWFufSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7J3N0YXJ0JyB8ICdlbmQnfSBraW5kXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG5cdG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cblxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHR5cGUge091dHJvfVxuICovXG5sZXQgb3V0cm9zO1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcblx0b3V0cm9zID0ge1xuXHRcdHI6IDAsXG5cdFx0YzogW10sXG5cdFx0cDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcblx0aWYgKCFvdXRyb3Mucikge1xuXHRcdHJ1bl9hbGwob3V0cm9zLmMpO1xuXHR9XG5cdG91dHJvcyA9IG91dHJvcy5wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5GcmFnbWVudH0gYmxvY2tcbiAqIEBwYXJhbSB7MCB8IDF9IFtsb2NhbF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcblx0aWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcblx0XHRvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuXHRcdGJsb2NrLmkobG9jYWwpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50fSBibG9ja1xuICogQHBhcmFtIHswIHwgMX0gbG9jYWxcbiAqIEBwYXJhbSB7MCB8IDF9IFtkZXRhY2hdXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja11cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG5cdGlmIChibG9jayAmJiBibG9jay5vKSB7XG5cdFx0aWYgKG91dHJvaW5nLmhhcyhibG9jaykpIHJldHVybjtcblx0XHRvdXRyb2luZy5hZGQoYmxvY2spO1xuXHRcdG91dHJvcy5jLnB1c2goKCkgPT4ge1xuXHRcdFx0b3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAoZGV0YWNoKSBibG9jay5kKDEpO1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGJsb2NrLm8obG9jYWwpO1xuXHR9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2soKTtcblx0fVxufVxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4uL3RyYW5zaXRpb24vcHVibGljLmpzJykuVHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7eyBzdGFydCgpOiB2b2lkOyBpbnZhbGlkYXRlKCk6IHZvaWQ7IGVuZCgpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuXHQvKipcblx0ICogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdpbicgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCBydW5uaW5nID0gZmFsc2U7XG5cdGxldCBhbmltYXRpb25fbmFtZTtcblx0bGV0IHRhc2s7XG5cdGxldCB1aWQgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXHRcdGlmIChjc3MpIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuXHRcdHRpY2soMCwgMSk7XG5cdFx0Y29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG5cdFx0Y29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG5cdFx0aWYgKHRhc2spIHRhc2suYWJvcnQoKTtcblx0XHRydW5uaW5nID0gdHJ1ZTtcblx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcblx0XHR0YXNrID0gbG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAobm93ID49IGVuZF90aW1lKSB7XG5cdFx0XHRcdFx0dGljaygxLCAwKTtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG5cdFx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRcdHJldHVybiAocnVubmluZyA9IGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ1bm5pbmc7XG5cdFx0fSk7XG5cdH1cblx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0cmV0dXJuIHtcblx0XHRzdGFydCgpIHtcblx0XHRcdGlmIChzdGFydGVkKSByZXR1cm47XG5cdFx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRcdGRlbGV0ZV9ydWxlKG5vZGUpO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuXHRcdFx0XHR3YWl0KCkudGhlbihnbyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW52YWxpZGF0ZSgpIHtcblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9LFxuXHRcdGVuZCgpIHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGNsZWFudXAoKTtcblx0XHRcdFx0cnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHJldHVybnMge3sgZW5kKHJlc2V0OiBhbnkpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnb3V0JyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHJ1bm5pbmcgPSB0cnVlO1xuXHRsZXQgYW5pbWF0aW9uX25hbWU7XG5cdGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuXHRncm91cC5yICs9IDE7XG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0bGV0IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXG5cdFx0aWYgKGNzcykgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcblxuXHRcdGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuXHRcdGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuXHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcblxuXHRcdGlmICgnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdG9yaWdpbmFsX2luZXJ0X3ZhbHVlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLmluZXJ0O1xuXHRcdFx0bm9kZS5pbmVydCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0bG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAobm93ID49IGVuZF90aW1lKSB7XG5cdFx0XHRcdFx0dGljaygwLCAxKTtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuXHRcdFx0XHRcdGlmICghLS1ncm91cC5yKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuXHRcdFx0XHRcdFx0Ly8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG5cdFx0XHRcdFx0XHRydW5fYWxsKGdyb3VwLmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG5cdFx0XHRcdFx0dGljaygxIC0gdCwgdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBydW5uaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHR3YWl0KCkudGhlbigoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG5cdFx0XHRnbygpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGdvKCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGVuZChyZXNldCkge1xuXHRcdFx0aWYgKHJlc2V0ICYmICdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0XHRub2RlLmluZXJ0ID0gb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcblx0XHRcdFx0Y29uZmlnLnRpY2soMSwgMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0XHRcdFx0cnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBpbnRyb1xuICogQHJldHVybnMge3sgcnVuKGI6IDAgfCAxKTogdm9pZDsgZW5kKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2JvdGgnIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgdCA9IGludHJvID8gMCA6IDE7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtQcm9ncmFtIHwgbnVsbH0gKi9cblx0bGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtQZW5kaW5nUHJvZ3JhbSB8IG51bGx9ICovXG5cdGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0bGV0IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuXHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGVuZGluZ1Byb2dyYW19IHByb2dyYW1cblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG5cdCAqIEByZXR1cm5zIHtQcm9ncmFtfVxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IGQgPSAvKiogQHR5cGUge1Byb2dyYW1bJ2QnXX0gKi8gKHByb2dyYW0uYiAtIHQpO1xuXHRcdGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhOiB0LFxuXHRcdFx0YjogcHJvZ3JhbS5iLFxuXHRcdFx0ZCxcblx0XHRcdGR1cmF0aW9uLFxuXHRcdFx0c3RhcnQ6IHByb2dyYW0uc3RhcnQsXG5cdFx0XHRlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcblx0XHRcdGdyb3VwOiBwcm9ncmFtLmdyb3VwXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lOVFJPIHwgT1VUUk99IGJcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBnbyhiKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1BlbmRpbmdQcm9ncmFtfSAqL1xuXHRcdGNvbnN0IHByb2dyYW0gPSB7XG5cdFx0XHRzdGFydDogbm93KCkgKyBkZWxheSxcblx0XHRcdGJcblx0XHR9O1xuXG5cdFx0aWYgKCFiKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuXHRcdFx0cHJvZ3JhbS5ncm91cCA9IG91dHJvcztcblx0XHRcdG91dHJvcy5yICs9IDE7XG5cdFx0fVxuXG5cdFx0aWYgKCdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0aWYgKGIpIHtcblx0XHRcdFx0aWYgKG9yaWdpbmFsX2luZXJ0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBhYm9ydGVkL3JldmVyc2VkIG91dHJvIOKAlCByZXN0b3JlIHByZXZpb3VzIGluZXJ0IHZhbHVlXG5cdFx0XHRcdFx0bm9kZS5pbmVydCA9IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcmlnaW5hbF9pbmVydF92YWx1ZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS5pbmVydDtcblx0XHRcdFx0bm9kZS5pbmVydCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcblx0XHRcdHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cblx0XHRcdC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuXHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0YW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcblx0XHRcdH1cblx0XHRcdGlmIChiKSB0aWNrKDAsIDEpO1xuXHRcdFx0cnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG5cdFx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcblx0XHRcdGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0XHRpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuXHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG5cdFx0XHRcdFx0cGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG5cdFx0XHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKFxuXHRcdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0XHR0LFxuXHRcdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0uYixcblx0XHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRlYXNpbmcsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5jc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5uaW5nX3Byb2dyYW0pIHtcblx0XHRcdFx0XHRpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcblx0XHRcdFx0XHRcdHRpY2soKHQgPSBydW5uaW5nX3Byb2dyYW0uYiksIDEgLSB0KTtcblx0XHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG5cdFx0XHRcdFx0XHRpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuXHRcdFx0XHRcdFx0XHQvLyB3ZSdyZSBkb25lXG5cdFx0XHRcdFx0XHRcdGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGludHJvIOKAlCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIG91dHJvIOKAlCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuXHRcdFx0XHRcdFx0XHRcdGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucikgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuXHRcdFx0XHRcdFx0dCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG5cdFx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB7XG5cdFx0cnVuKGIpIHtcblx0XHRcdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0XHRcdHdhaXQoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBvcHRzID0geyBkaXJlY3Rpb246IGIgPyAnaW4nIDogJ291dCcgfTtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdHMpO1xuXHRcdFx0XHRcdGdvKGIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdvKGIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZW5kKCkge1xuXHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqIEB0eXBlZGVmIHsxfSBJTlRSTyAqL1xuLyoqIEB0eXBlZGVmIHswfSBPVVRSTyAqL1xuLyoqIEB0eXBlZGVmIHt7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIHwgJ2JvdGgnIH19IFRyYW5zaXRpb25PcHRpb25zICovXG4vKiogQHR5cGVkZWYgeyhub2RlOiBFbGVtZW50LCBwYXJhbXM6IGFueSwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMpID0+IGltcG9ydCgnLi4vdHJhbnNpdGlvbi9wdWJsaWMuanMnKS5UcmFuc2l0aW9uQ29uZmlnfSBUcmFuc2l0aW9uRm4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPdXRyb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25bXX0gY1xuICogQHByb3BlcnR5IHtPYmplY3R9IHBcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlbmRpbmdQcm9ncmFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7SU5UUk98T1VUUk99IGJcbiAqIEBwcm9wZXJ0eSB7T3V0cm99IFtncm91cF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhXG4gKiBAcHJvcGVydHkge0lOVFJPfE9VVFJPfSBiXG4gKiBAcHJvcGVydHkgezF8LTF9IGRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kXG4gKiBAcHJvcGVydHkge091dHJvfSBbZ3JvdXBdXG4gKi9cbiIsImltcG9ydCB7IGlzX3Byb21pc2UgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGNoZWNrX291dHJvcywgZ3JvdXBfb3V0cm9zLCB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuaW1wb3J0IHsgZmx1c2ggfSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5pbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtQcm9taXNlPFQ+fSBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuUHJvbWlzZUluZm88VD59IGluZm9cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuXHRjb25zdCB0b2tlbiA9IChpbmZvLnRva2VuID0ge30pO1xuXHQvKipcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50RmFjdG9yeX0gdHlwZVxuXHQgKiBAcGFyYW0gezAgfCAxIHwgMn0gaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtrZXldXG5cdCAqIEBwYXJhbSB7YW55fSBbdmFsdWVdXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG5cdFx0aWYgKGluZm8udG9rZW4gIT09IHRva2VuKSByZXR1cm47XG5cdFx0aW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuXHRcdGxldCBjaGlsZF9jdHggPSBpbmZvLmN0eDtcblx0XHRpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuXHRcdFx0Y2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcblx0XHR9XG5cdFx0Y29uc3QgYmxvY2sgPSB0eXBlICYmIChpbmZvLmN1cnJlbnQgPSB0eXBlKShjaGlsZF9jdHgpO1xuXHRcdGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuXHRcdGlmIChpbmZvLmJsb2NrKSB7XG5cdFx0XHRpZiAoaW5mby5ibG9ja3MpIHtcblx0XHRcdFx0aW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcblx0XHRcdFx0XHRpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcblx0XHRcdFx0XHRcdGdyb3VwX291dHJvcygpO1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuXHRcdFx0XHRcdFx0XHRcdGluZm8uYmxvY2tzW2ldID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRjaGVja19vdXRyb3MoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5mby5ibG9jay5kKDEpO1xuXHRcdFx0fVxuXHRcdFx0YmxvY2suYygpO1xuXHRcdFx0dHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG5cdFx0XHRibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuXHRcdFx0bmVlZHNfZmx1c2ggPSB0cnVlO1xuXHRcdH1cblx0XHRpbmZvLmJsb2NrID0gYmxvY2s7XG5cdFx0aWYgKGluZm8uYmxvY2tzKSBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcblx0XHRpZiAobmVlZHNfZmx1c2gpIHtcblx0XHRcdGZsdXNoKCk7XG5cdFx0fVxuXHR9XG5cdGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG5cdFx0Y29uc3QgY3VycmVudF9jb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcblx0XHRwcm9taXNlLnRoZW4oXG5cdFx0XHQodmFsdWUpID0+IHtcblx0XHRcdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcblx0XHRcdFx0dXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG5cdFx0XHR9LFxuXHRcdFx0KGVycm9yKSA9PiB7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChjdXJyZW50X2NvbXBvbmVudCk7XG5cdFx0XHRcdHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcblx0XHRcdFx0aWYgKCFpbmZvLmhhc0NhdGNoKSB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHRcdC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuXHRcdGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuXHRcdFx0dXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG5cdFx0XHR1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpbmZvLnJlc29sdmVkID0gLyoqIEB0eXBlIHtUfSAqLyAocHJvbWlzZSk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2goaW5mbywgY3R4LCBkaXJ0eSkge1xuXHRjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcblx0Y29uc3QgeyByZXNvbHZlZCB9ID0gaW5mbztcblx0aWYgKGluZm8uY3VycmVudCA9PT0gaW5mby50aGVuKSB7XG5cdFx0Y2hpbGRfY3R4W2luZm8udmFsdWVdID0gcmVzb2x2ZWQ7XG5cdH1cblx0aWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuXHRcdGNoaWxkX2N0eFtpbmZvLmVycm9yXSA9IHJlc29sdmVkO1xuXHR9XG5cdGluZm8uYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbn1cbiIsImltcG9ydCB7IHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0IH0gZnJvbSAnLi90cmFuc2l0aW9ucy5qcyc7XG5pbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIGdlbmVyYWwgZWFjaCBmdW5jdGlvbnM6XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVfYXJyYXlfbGlrZShhcnJheV9saWtlX29yX2l0ZXJhdG9yKSB7XG5cdHJldHVybiBhcnJheV9saWtlX29yX2l0ZXJhdG9yPy5sZW5ndGggIT09IHVuZGVmaW5lZFxuXHRcdD8gYXJyYXlfbGlrZV9vcl9pdGVyYXRvclxuXHRcdDogQXJyYXkuZnJvbShhcnJheV9saWtlX29yX2l0ZXJhdG9yKTtcbn1cblxuLy8ga2V5ZWQgZWFjaCBmdW5jdGlvbnM6XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZCgxKTtcblx0bG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHR0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuXHRcdGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcblx0fSk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5mKCk7XG5cdGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZigpO1xuXHRvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChcblx0b2xkX2Jsb2Nrcyxcblx0ZGlydHksXG5cdGdldF9rZXksXG5cdGR5bmFtaWMsXG5cdGN0eCxcblx0bGlzdCxcblx0bG9va3VwLFxuXHRub2RlLFxuXHRkZXN0cm95LFxuXHRjcmVhdGVfZWFjaF9ibG9jayxcblx0bmV4dCxcblx0Z2V0X2NvbnRleHRcbikge1xuXHRsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuXHRsZXQgbiA9IGxpc3QubGVuZ3RoO1xuXHRsZXQgaSA9IG87XG5cdGNvbnN0IG9sZF9pbmRleGVzID0ge307XG5cdHdoaWxlIChpLS0pIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG5cdGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcblx0Y29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcblx0Y29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuXHRjb25zdCB1cGRhdGVzID0gW107XG5cdGkgPSBuO1xuXHR3aGlsZSAoaS0tKSB7XG5cdFx0Y29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcblx0XHRjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG5cdFx0bGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuXHRcdGlmICghYmxvY2spIHtcblx0XHRcdGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuXHRcdFx0YmxvY2suYygpO1xuXHRcdH0gZWxzZSBpZiAoZHluYW1pYykge1xuXHRcdFx0Ly8gZGVmZXIgdXBkYXRlcyB1bnRpbCBhbGwgdGhlIERPTSBzaHVmZmxpbmcgaXMgZG9uZVxuXHRcdFx0dXBkYXRlcy5wdXNoKCgpID0+IGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSkpO1xuXHRcdH1cblx0XHRuZXdfbG9va3VwLnNldChrZXksIChuZXdfYmxvY2tzW2ldID0gYmxvY2spKTtcblx0XHRpZiAoa2V5IGluIG9sZF9pbmRleGVzKSBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcblx0fVxuXHRjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG5cdGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuXHRcdHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuXHRcdGJsb2NrLm0obm9kZSwgbmV4dCk7XG5cdFx0bG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcblx0XHRuZXh0ID0gYmxvY2suZmlyc3Q7XG5cdFx0bi0tO1xuXHR9XG5cdHdoaWxlIChvICYmIG4pIHtcblx0XHRjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcblx0XHRjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcblx0XHRjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcblx0XHRjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcblx0XHRpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcblx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG5cdFx0XHRvLS07XG5cdFx0XHRuLS07XG5cdFx0fSBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcblx0XHRcdC8vIHJlbW92ZSBvbGQgYmxvY2tcblx0XHRcdGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuXHRcdFx0by0tO1xuXHRcdH0gZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuXHRcdFx0aW5zZXJ0KG5ld19ibG9jayk7XG5cdFx0fSBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcblx0XHRcdG8tLTtcblx0XHR9IGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG5cdFx0XHRkaWRfbW92ZS5hZGQobmV3X2tleSk7XG5cdFx0XHRpbnNlcnQobmV3X2Jsb2NrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcblx0XHRcdG8tLTtcblx0XHR9XG5cdH1cblx0d2hpbGUgKG8tLSkge1xuXHRcdGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG5cdFx0aWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSkgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG5cdH1cblx0d2hpbGUgKG4pIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG5cdHJ1bl9hbGwodXBkYXRlcyk7XG5cdHJldHVybiBuZXdfYmxvY2tzO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcblx0Y29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcblx0XHRpZiAoa2V5cy5oYXMoa2V5KSkge1xuXHRcdFx0bGV0IHZhbHVlID0gJyc7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YWx1ZSA9IGB3aXRoIHZhbHVlICcke1N0cmluZyhrZXkpfScgYDtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gY2FuJ3Qgc3RyaW5naWZ5XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2g6IEtleXMgYXQgaW5kZXggJHtrZXlzLmdldChcblx0XHRcdFx0XHRrZXlcblx0XHRcdFx0KX0gYW5kICR7aX0gJHt2YWx1ZX1hcmUgZHVwbGljYXRlc2Bcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGtleXMuc2V0KGtleSwgaSk7XG5cdH1cbn1cbiIsIi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG5cdGNvbnN0IHVwZGF0ZSA9IHt9O1xuXHRjb25zdCB0b19udWxsX291dCA9IHt9O1xuXHRjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG5cdGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcblx0d2hpbGUgKGktLSkge1xuXHRcdGNvbnN0IG8gPSBsZXZlbHNbaV07XG5cdFx0Y29uc3QgbiA9IHVwZGF0ZXNbaV07XG5cdFx0aWYgKG4pIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIG8pIHtcblx0XHRcdFx0aWYgKCEoa2V5IGluIG4pKSB0b19udWxsX291dFtrZXldID0gMTtcblx0XHRcdH1cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIG4pIHtcblx0XHRcdFx0aWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcblx0XHRcdFx0XHR1cGRhdGVba2V5XSA9IG5ba2V5XTtcblx0XHRcdFx0XHRhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsZXZlbHNbaV0gPSBuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG5cdFx0XHRcdGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG5cdFx0aWYgKCEoa2V5IGluIHVwZGF0ZSkpIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuXHR9XG5cdHJldHVybiB1cGRhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcblx0cmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuIiwiY29uc3QgX2Jvb2xlYW5fYXR0cmlidXRlcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCdhbGxvd2Z1bGxzY3JlZW4nLFxuXHQnYWxsb3dwYXltZW50cmVxdWVzdCcsXG5cdCdhc3luYycsXG5cdCdhdXRvZm9jdXMnLFxuXHQnYXV0b3BsYXknLFxuXHQnY2hlY2tlZCcsXG5cdCdjb250cm9scycsXG5cdCdkZWZhdWx0Jyxcblx0J2RlZmVyJyxcblx0J2Rpc2FibGVkJyxcblx0J2Zvcm1ub3ZhbGlkYXRlJyxcblx0J2hpZGRlbicsXG5cdCdpbmVydCcsXG5cdCdpc21hcCcsXG5cdCdsb29wJyxcblx0J211bHRpcGxlJyxcblx0J211dGVkJyxcblx0J25vbW9kdWxlJyxcblx0J25vdmFsaWRhdGUnLFxuXHQnb3BlbicsXG5cdCdwbGF5c2lubGluZScsXG5cdCdyZWFkb25seScsXG5cdCdyZXF1aXJlZCcsXG5cdCdyZXZlcnNlZCcsXG5cdCdzZWxlY3RlZCdcbl0pO1xuXG4vKipcbiAqIExpc3Qgb2YgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMgKGUuZy4gYDxpbnB1dCBkaXNhYmxlZD5gKS5cbiAqIFNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG4gKlxuICogQHR5cGUge1NldDxzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbLi4uX2Jvb2xlYW5fYXR0cmlidXRlc10pO1xuXG4vKiogQHR5cGVkZWYge3R5cGVvZiBfYm9vbGVhbl9hdHRyaWJ1dGVzW251bWJlcl19IEJvb2xlYW5BdHRyaWJ1dGVzICovXG4iLCJpbXBvcnQgeyBzZXRfY3VycmVudF9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgcnVuX2FsbCwgYmxhbmtfb2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBib29sZWFuX2F0dHJpYnV0ZXMgfSBmcm9tICcuLi8uLi9zaGFyZWQvYm9vbGVhbl9hdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IGVuc3VyZV9hcnJheV9saWtlIH0gZnJvbSAnLi9lYWNoLmpzJztcbmV4cG9ydCB7IGlzX3ZvaWQgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMvbmFtZXMuanMnO1xuXG5leHBvcnQgY29uc3QgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIgPVxuXHQvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbm9uY2hhcmFjdGVyXG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwcmVhZChhcmdzLCBhdHRyc190b19hZGQpIHtcblx0Y29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmFyZ3MpO1xuXHRpZiAoYXR0cnNfdG9fYWRkKSB7XG5cdFx0Y29uc3QgY2xhc3Nlc190b19hZGQgPSBhdHRyc190b19hZGQuY2xhc3Nlcztcblx0XHRjb25zdCBzdHlsZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLnN0eWxlcztcblx0XHRpZiAoY2xhc3Nlc190b19hZGQpIHtcblx0XHRcdGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcblx0XHRcdFx0YXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXNfdG9fYWRkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cmlidXRlcy5jbGFzcyArPSAnICcgKyBjbGFzc2VzX3RvX2FkZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN0eWxlc190b19hZGQpIHtcblx0XHRcdGlmIChhdHRyaWJ1dGVzLnN0eWxlID09IG51bGwpIHtcblx0XHRcdFx0YXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhcblx0XHRcdFx0XHRtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGxldCBzdHIgPSAnJztcblx0T2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdGlmIChpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3Rlci50ZXN0KG5hbWUpKSByZXR1cm47XG5cdFx0Y29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gdHJ1ZSkgc3RyICs9ICcgJyArIG5hbWU7XG5cdFx0ZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRpZiAodmFsdWUpIHN0ciArPSAnICcgKyBuYW1lO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0c3RyICs9IGAgJHtuYW1lfT1cIiR7dmFsdWV9XCJgO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBzdHI7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2Vfc3NyX3N0eWxlcyhzdHlsZV9hdHRyaWJ1dGUsIHN0eWxlX2RpcmVjdGl2ZSkge1xuXHRjb25zdCBzdHlsZV9vYmplY3QgPSB7fTtcblx0Zm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG5cdFx0Y29uc3QgY29sb25faW5kZXggPSBpbmRpdmlkdWFsX3N0eWxlLmluZGV4T2YoJzonKTtcblx0XHRjb25zdCBuYW1lID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZSgwLCBjb2xvbl9pbmRleCkudHJpbSgpO1xuXHRcdGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcblx0XHRpZiAoIW5hbWUpIGNvbnRpbnVlO1xuXHRcdHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHR9XG5cdGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZV9kaXJlY3RpdmUpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHN0eWxlX2RpcmVjdGl2ZVtuYW1lXTtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgc3R5bGVfb2JqZWN0W25hbWVdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuXG5jb25zdCBBVFRSX1JFR0VYID0gL1smXCJdL2c7XG5jb25zdCBDT05URU5UX1JFR0VYID0gL1smPF0vZztcblxuLyoqXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBwZXJmb3JtYW5jZSBzZW5zaXRpdmUgYW5kIGhhcyBiZWVuIG9wdGltaXplZFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzU3MDFcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuXHRjb25zdCBzdHIgPSBTdHJpbmcodmFsdWUpO1xuXHRjb25zdCBwYXR0ZXJuID0gaXNfYXR0ciA/IEFUVFJfUkVHRVggOiBDT05URU5UX1JFR0VYO1xuXHRwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG5cdGxldCBlc2NhcGVkID0gJyc7XG5cdGxldCBsYXN0ID0gMDtcblx0d2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG5cdFx0Y29uc3QgaSA9IHBhdHRlcm4ubGFzdEluZGV4IC0gMTtcblx0XHRjb25zdCBjaCA9IHN0cltpXTtcblx0XHRlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiBjaCA9PT0gJ1wiJyA/ICcmcXVvdDsnIDogJyZsdDsnKTtcblx0XHRsYXN0ID0gaSArIDE7XG5cdH1cblx0cmV0dXJuIGVzY2FwZWQgKyBzdHIuc3Vic3RyaW5nKGxhc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSh2YWx1ZSkge1xuXHQvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuXHRjb25zdCBzaG91bGRfZXNjYXBlID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jyk7XG5cdHJldHVybiBzaG91bGRfZXNjYXBlID8gZXNjYXBlKHZhbHVlLCB0cnVlKSA6IHZhbHVlO1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcblx0XHRyZXN1bHRba2V5XSA9IGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUob2JqW2tleV0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG5cdGl0ZW1zID0gZW5zdXJlX2FycmF5X2xpa2UoaXRlbXMpO1xuXHRsZXQgc3RyID0gJyc7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRzdHIgKz0gZm4oaXRlbXNbaV0sIGkpO1xuXHR9XG5cdHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBjb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcblx0JCRyZW5kZXI6ICgpID0+ICcnXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfY29tcG9uZW50KGNvbXBvbmVudCwgbmFtZSkge1xuXHRpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdzdmVsdGU6Y29tcG9uZW50JykgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGA8JHtuYW1lfT4gaXMgbm90IGEgdmFsaWQgU1NSIGNvbXBvbmVudC4gWW91IG1heSBuZWVkIHRvIHJldmlldyB5b3VyIGJ1aWxkIGNvbmZpZyB0byBlbnN1cmUgdGhhdCBkZXBlbmRlbmNpZXMgYXJlIGNvbXBpbGVkLCByYXRoZXIgdGhhbiBpbXBvcnRlZCBhcyBwcmUtY29tcGlsZWQgbW9kdWxlcy4gT3RoZXJ3aXNlIHlvdSBtYXkgbmVlZCB0byBmaXggYSA8JHtuYW1lfT4uYFxuXHRcdCk7XG5cdH1cblx0cmV0dXJuIGNvbXBvbmVudDtcbn1cblxuLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVidWcoZmlsZSwgbGluZSwgY29sdW1uLCB2YWx1ZXMpIHtcblx0Y29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHRjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0cmV0dXJuICcnO1xufVxuXG5sZXQgb25fZGVzdHJveTtcblxuLyoqIEByZXR1cm5zIHt7IHJlbmRlcjogKHByb3BzPzoge30sIHsgJCRzbG90cywgY29udGV4dCB9PzogeyAkJHNsb3RzPzoge307IGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+OyB9KSA9PiB7IGh0bWw6IGFueTsgY3NzOiB7IGNvZGU6IHN0cmluZzsgbWFwOiBhbnk7IH07IGhlYWQ6IHN0cmluZzsgfTsgJCRyZW5kZXI6IChyZXN1bHQ6IGFueSwgcHJvcHM6IGFueSwgYmluZGluZ3M6IGFueSwgc2xvdHM6IGFueSwgY29udGV4dDogYW55KSA9PiBhbnk7IH19ICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcblx0ZnVuY3Rpb24gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzLCBjb250ZXh0KSB7XG5cdFx0Y29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRcdGNvbnN0ICQkID0ge1xuXHRcdFx0b25fZGVzdHJveSxcblx0XHRcdGNvbnRleHQ6IG5ldyBNYXAoY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG5cdFx0XHQvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuXHRcdFx0b25fbW91bnQ6IFtdLFxuXHRcdFx0YmVmb3JlX3VwZGF0ZTogW10sXG5cdFx0XHRhZnRlcl91cGRhdGU6IFtdLFxuXHRcdFx0Y2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuXHRcdH07XG5cdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG5cdFx0Y29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG5cdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xuXHRcdHJldHVybiBodG1sO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0cmVuZGVyOiAocHJvcHMgPSB7fSwgeyAkJHNsb3RzID0ge30sIGNvbnRleHQgPSBuZXcgTWFwKCkgfSA9IHt9KSA9PiB7XG5cdFx0XHRvbl9kZXN0cm95ID0gW107XG5cdFx0XHRjb25zdCByZXN1bHQgPSB7IHRpdGxlOiAnJywgaGVhZDogJycsIGNzczogbmV3IFNldCgpIH07XG5cdFx0XHRjb25zdCBodG1sID0gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywge30sICQkc2xvdHMsIGNvbnRleHQpO1xuXHRcdFx0cnVuX2FsbChvbl9kZXN0cm95KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGh0bWwsXG5cdFx0XHRcdGNzczoge1xuXHRcdFx0XHRcdGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcylcblx0XHRcdFx0XHRcdC5tYXAoKGNzcykgPT4gY3NzLmNvZGUpXG5cdFx0XHRcdFx0XHQuam9pbignXFxuJyksXG5cdFx0XHRcdFx0bWFwOiBudWxsIC8vIFRPRE9cblx0XHRcdFx0fSxcblx0XHRcdFx0aGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcblx0XHRcdH07XG5cdFx0fSxcblx0XHQkJHJlbmRlclxuXHR9O1xufVxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfYXR0cmlidXRlKG5hbWUsIHZhbHVlLCBib29sZWFuKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpIHJldHVybiAnJztcblx0Y29uc3QgYXNzaWdubWVudCA9IGJvb2xlYW4gJiYgdmFsdWUgPT09IHRydWUgPyAnJyA6IGA9XCIke2VzY2FwZSh2YWx1ZSwgdHJ1ZSl9XCJgO1xuXHRyZXR1cm4gYCAke25hbWV9JHthc3NpZ25tZW50fWA7XG59XG5cbi8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcblx0cmV0dXJuIGNsYXNzZXMgPyBgIGNsYXNzPVwiJHtjbGFzc2VzfVwiYCA6ICcnO1xufVxuXG4vKiogQHJldHVybnMge3N0cmluZ30gKi9cbmZ1bmN0aW9uIHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhzdHlsZV9vYmplY3QpXG5cdFx0LmZpbHRlcigoa2V5KSA9PiBzdHlsZV9vYmplY3Rba2V5XSAhPSBudWxsICYmIHN0eWxlX29iamVjdFtrZXldICE9PSAnJylcblx0XHQubWFwKChrZXkpID0+IGAke2tleX06ICR7ZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShzdHlsZV9vYmplY3Rba2V5XSl9O2ApXG5cdFx0LmpvaW4oJyAnKTtcbn1cblxuLyoqIEByZXR1cm5zIHtzdHJpbmd9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX3N0eWxlcyhzdHlsZV9vYmplY3QpIHtcblx0Y29uc3Qgc3R5bGVzID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZV9vYmplY3QpO1xuXHRyZXR1cm4gc3R5bGVzID8gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYCA6ICcnO1xufVxuIiwiaW1wb3J0IHtcblx0YWRkX3JlbmRlcl9jYWxsYmFjayxcblx0Zmx1c2gsXG5cdGZsdXNoX3JlbmRlcl9jYWxsYmFja3MsXG5cdHNjaGVkdWxlX3VwZGF0ZSxcblx0ZGlydHlfY29tcG9uZW50c1xufSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgYmxhbmtfb2JqZWN0LCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIHJ1biwgcnVuX2FsbCwgbm9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0Y2hpbGRyZW4sXG5cdGRldGFjaCxcblx0c3RhcnRfaHlkcmF0aW5nLFxuXHRlbmRfaHlkcmF0aW5nLFxuXHRnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzLFxuXHRpbnNlcnQsXG5cdGVsZW1lbnQsXG5cdGF0dHJcbn0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgdHJhbnNpdGlvbl9pbiB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG5cdGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuXHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcblx0XHRjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcblx0YmxvY2sgJiYgYmxvY2suYygpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcblx0YmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IpIHtcblx0Y29uc3QgeyBmcmFnbWVudCwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG5cdGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuXHQvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG5cdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuXHRcdGNvbnN0IG5ld19vbl9kZXN0cm95ID0gY29tcG9uZW50LiQkLm9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG5cdFx0Ly8gaWYgdGhlIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gaXQgd2lsbCB1cGRhdGUgdGhlIGAkJC5vbl9kZXN0cm95YCByZWZlcmVuY2UgdG8gYG51bGxgLlxuXHRcdC8vIHRoZSBkZXN0cnVjdHVyZWQgb25fZGVzdHJveSBtYXkgc3RpbGwgcmVmZXJlbmNlIHRvIHRoZSBvbGQgYXJyYXlcblx0XHRpZiAoY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kpIHtcblx0XHRcdGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcblx0XHRcdC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcblx0XHRcdHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuXHRcdH1cblx0XHRjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcblx0fSk7XG5cdGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcblx0Y29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG5cdGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuXHRcdGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoJCQuYWZ0ZXJfdXBkYXRlKTtcblx0XHRydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuXHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcblx0XHQvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG5cdFx0Ly8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuXHRcdCQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG5cdFx0JCQuY3R4ID0gW107XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcblx0aWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcblx0XHRkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcblx0XHRzY2hlZHVsZV91cGRhdGUoKTtcblx0XHRjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcblx0fVxuXHRjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAxIDw8IGkgJSAzMTtcbn1cblxuLy8gVE9ETzogRG9jdW1lbnQgdGhlIG90aGVyIHBhcmFtc1xuLyoqXG4gKiBAcGFyYW0ge1N2ZWx0ZUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRDb25zdHJ1Y3Rvck9wdGlvbnN9IG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi91dGlscy5qcycpWydub3RfZXF1YWwnXX0gbm90X2VxdWFsIFVzZWQgdG8gY29tcGFyZSBwcm9wcyBhbmQgc3RhdGUgdmFsdWVzLlxuICogQHBhcmFtIHsodGFyZ2V0OiBFbGVtZW50IHwgU2hhZG93Um9vdCkgPT4gdm9pZH0gW2FwcGVuZF9zdHlsZXNdIEZ1bmN0aW9uIHRoYXQgYXBwZW5kcyBzdHlsZXMgdG8gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaXMgZmlyc3QgaW5pdGlhbGlzZWQuXG4gKiBUaGlzIHdpbGwgYmUgdGhlIGBhZGRfY3NzYCBmdW5jdGlvbiBmcm9tIHRoZSBjb21waWxlZCBjb21wb25lbnQuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KFxuXHRjb21wb25lbnQsXG5cdG9wdGlvbnMsXG5cdGluc3RhbmNlLFxuXHRjcmVhdGVfZnJhZ21lbnQsXG5cdG5vdF9lcXVhbCxcblx0cHJvcHMsXG5cdGFwcGVuZF9zdHlsZXMgPSBudWxsLFxuXHRkaXJ0eSA9IFstMV1cbikge1xuXHRjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuVCQkfSAqL1xuXHRjb25zdCAkJCA9IChjb21wb25lbnQuJCQgPSB7XG5cdFx0ZnJhZ21lbnQ6IG51bGwsXG5cdFx0Y3R4OiBbXSxcblx0XHQvLyBzdGF0ZVxuXHRcdHByb3BzLFxuXHRcdHVwZGF0ZTogbm9vcCxcblx0XHRub3RfZXF1YWwsXG5cdFx0Ym91bmQ6IGJsYW5rX29iamVjdCgpLFxuXHRcdC8vIGxpZmVjeWNsZVxuXHRcdG9uX21vdW50OiBbXSxcblx0XHRvbl9kZXN0cm95OiBbXSxcblx0XHRvbl9kaXNjb25uZWN0OiBbXSxcblx0XHRiZWZvcmVfdXBkYXRlOiBbXSxcblx0XHRhZnRlcl91cGRhdGU6IFtdLFxuXHRcdGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcblx0XHQvLyBldmVyeXRoaW5nIGVsc2Vcblx0XHRjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuXHRcdGRpcnR5LFxuXHRcdHNraXBfYm91bmQ6IGZhbHNlLFxuXHRcdHJvb3Q6IG9wdGlvbnMudGFyZ2V0IHx8IHBhcmVudF9jb21wb25lbnQuJCQucm9vdFxuXHR9KTtcblx0YXBwZW5kX3N0eWxlcyAmJiBhcHBlbmRfc3R5bGVzKCQkLnJvb3QpO1xuXHRsZXQgcmVhZHkgPSBmYWxzZTtcblx0JCQuY3R4ID0gaW5zdGFuY2Vcblx0XHQ/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcblx0XHRcdFx0aWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAoJCQuY3R4W2ldID0gdmFsdWUpKSkge1xuXHRcdFx0XHRcdGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSkgJCQuYm91bmRbaV0odmFsdWUpO1xuXHRcdFx0XHRcdGlmIChyZWFkeSkgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0ICB9KVxuXHRcdDogW107XG5cdCQkLnVwZGF0ZSgpO1xuXHRyZWFkeSA9IHRydWU7XG5cdHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG5cdC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuXHQkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG5cdGlmIChvcHRpb25zLnRhcmdldCkge1xuXHRcdGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcblx0XHRcdHN0YXJ0X2h5ZHJhdGluZygpO1xuXHRcdFx0Ly8gVE9ETzogd2hhdCBpcyB0aGUgY29ycmVjdCB0eXBlIGhlcmU/XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuXHRcdFx0bm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuXHRcdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbnRybykgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuXHRcdG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvcik7XG5cdFx0ZW5kX2h5ZHJhdGluZygpO1xuXHRcdGZsdXNoKCk7XG5cdH1cblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxuXG5leHBvcnQgbGV0IFN2ZWx0ZUVsZW1lbnQ7XG5cbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcblx0U3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXHRcdC8qKiBUaGUgU3ZlbHRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciAqL1xuXHRcdCQkY3Rvcjtcblx0XHQvKiogU2xvdHMgKi9cblx0XHQkJHM7XG5cdFx0LyoqIFRoZSBTdmVsdGUgY29tcG9uZW50IGluc3RhbmNlICovXG5cdFx0JCRjO1xuXHRcdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgY29ubmVjdGVkICovXG5cdFx0JCRjbiA9IGZhbHNlO1xuXHRcdC8qKiBDb21wb25lbnQgcHJvcHMgZGF0YSAqL1xuXHRcdCQkZCA9IHt9O1xuXHRcdC8qKiBgdHJ1ZWAgaWYgY3VycmVudGx5IGluIHRoZSBwcm9jZXNzIG9mIHJlZmxlY3RpbmcgY29tcG9uZW50IHByb3BzIGJhY2sgdG8gYXR0cmlidXRlcyAqL1xuXHRcdCQkciA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gUHJvcHMgZGVmaW5pdGlvbiAobmFtZSwgcmVmbGVjdGVkLCB0eXBlIGV0YykgKi9cblx0XHQkJHBfZCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb25bXT59IEV2ZW50IGxpc3RlbmVycyAqL1xuXHRcdCQkbCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7TWFwPEZ1bmN0aW9uLCBGdW5jdGlvbj59IEV2ZW50IGxpc3RlbmVyIHVuc3Vic2NyaWJlIGZ1bmN0aW9ucyAqL1xuXHRcdCQkbF91ID0gbmV3IE1hcCgpO1xuXG5cdFx0Y29uc3RydWN0b3IoJCRjb21wb25lbnRDdG9yLCAkJHNsb3RzLCB1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuJCRjdG9yID0gJCRjb21wb25lbnRDdG9yO1xuXHRcdFx0dGhpcy4kJHMgPSAkJHNsb3RzO1xuXHRcdFx0aWYgKHVzZV9zaGFkb3dfZG9tKSB7XG5cdFx0XHRcdHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdC8vIFdlIGNhbid0IGRldGVybWluZSB1cGZyb250IGlmIHRoZSBldmVudCBpcyBhIGN1c3RvbSBldmVudCBvciBub3QsIHNvIHdlIGhhdmUgdG9cblx0XHRcdC8vIGxpc3RlbiB0byBib3RoLiBJZiBzb21lb25lIHVzZXMgYSBjdXN0b20gZXZlbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIGEgcmVndWxhclxuXHRcdFx0Ly8gYnJvd3NlciBldmVudCwgdGhpcyBmaXJlcyB0d2ljZSAtIHdlIGNhbid0IGF2b2lkIHRoYXQuXG5cdFx0XHR0aGlzLiQkbFt0eXBlXSA9IHRoaXMuJCRsW3R5cGVdIHx8IFtdO1xuXHRcdFx0dGhpcy4kJGxbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkYy4kb24odHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHR0aGlzLiQkbF91LnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0fVxuXHRcdFx0c3VwZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0c3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkbF91LmdldChsaXN0ZW5lcik7XG5cdFx0XHRcdGlmICh1bnN1Yikge1xuXHRcdFx0XHRcdHVuc3ViKCk7XG5cdFx0XHRcdFx0dGhpcy4kJGxfdS5kZWxldGUobGlzdGVuZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSB0cnVlO1xuXHRcdFx0aWYgKCF0aGlzLiQkYykge1xuXHRcdFx0XHQvLyBXZSB3YWl0IG9uZSB0aWNrIHRvIGxldCBwb3NzaWJsZSBjaGlsZCBzbG90IGVsZW1lbnRzIGJlIGNyZWF0ZWQvbW91bnRlZFxuXHRcdFx0XHRhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24gfHwgdGhpcy4kJGMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gY3JlYXRlX3Nsb3QobmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgbm9kZTtcblx0XHRcdFx0XHRcdGNvbnN0IG9iaiA9IHtcblx0XHRcdFx0XHRcdFx0YzogZnVuY3Rpb24gY3JlYXRlKCkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtZW50KCdzbG90Jyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5hbWUgIT09ICdkZWZhdWx0Jykge1xuXHRcdFx0XHRcdFx0XHRcdFx0YXR0cihub2RlLCAnbmFtZScsIG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbYW5jaG9yXVxuXHRcdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdFx0bTogZnVuY3Rpb24gbW91bnQodGFyZ2V0LCBhbmNob3IpIHtcblx0XHRcdFx0XHRcdFx0XHRpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkOiBmdW5jdGlvbiBkZXN0cm95KGRldGFjaGluZykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRldGFjaChub2RlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgJCRzbG90cyA9IHt9O1xuXHRcdFx0XHRjb25zdCBleGlzdGluZ19zbG90cyA9IGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHModGhpcyk7XG5cdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLiQkcykge1xuXHRcdFx0XHRcdGlmIChuYW1lIGluIGV4aXN0aW5nX3Nsb3RzKSB7XG5cdFx0XHRcdFx0XHQkJHNsb3RzW25hbWVdID0gW2NyZWF0ZV9zbG90KG5hbWUpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgdGhpcy5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcy4kJGRhdGEgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMuYXR0cmlidXRlc1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSB0aGlzLiQkZ19wKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0XHRpZiAoIShuYW1lIGluIHRoaXMuJCRkKSkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRbbmFtZV0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUobmFtZSwgYXR0cmlidXRlLnZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFBvcnQgb3ZlciBwcm9wcyB0aGF0IHdlcmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgYmVmb3JlIGNlIHdhcyBpbml0aWFsaXplZFxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkcF9kKSB7XG5cdFx0XHRcdFx0aWYgKCEoa2V5IGluIHRoaXMuJCRkKSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSA9IHRoaXNba2V5XTsgLy8gZG9uJ3QgdHJhbnNmb3JtLCB0aGVzZSB3ZXJlIHNldCB0aHJvdWdoIEphdmFTY3JpcHRcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzW2tleV07IC8vIHJlbW92ZSB0aGUgcHJvcGVydHkgdGhhdCBzaGFkb3dzIHRoZSBnZXR0ZXIvc2V0dGVyXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRjID0gbmV3IHRoaXMuJCRjdG9yKHtcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMuc2hhZG93Um9vdCB8fCB0aGlzLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHQuLi50aGlzLiQkZCxcblx0XHRcdFx0XHRcdCQkc2xvdHMsXG5cdFx0XHRcdFx0XHQkJHNjb3BlOiB7XG5cdFx0XHRcdFx0XHRcdGN0eDogW11cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFJlZmxlY3QgY29tcG9uZW50IHByb3BzIGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0Y29uc3QgcmVmbGVjdF9hdHRyaWJ1dGVzID0gKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuJCRyID0gdHJ1ZTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkcF9kKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldID0gdGhpcy4kJGMuJCQuY3R4W3RoaXMuJCRjLiQkLnByb3BzW2tleV1dO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuJCRwX2Rba2V5XS5yZWZsZWN0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZV92YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShcblx0XHRcdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiQkcF9kLFxuXHRcdFx0XHRcdFx0XHRcdCd0b0F0dHJpYnV0ZSdcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZV92YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUodGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSB8fCBrZXkpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgfHwga2V5LCBhdHRyaWJ1dGVfdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuJCRyID0gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuJCRjLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKHJlZmxlY3RfYXR0cmlidXRlcyk7XG5cdFx0XHRcdHJlZmxlY3RfYXR0cmlidXRlcygpOyAvLyBvbmNlIGluaXRpYWxseSBiZWNhdXNlIGFmdGVyX3VwZGF0ZSBpcyBhZGRlZCB0b28gbGF0ZSBmb3IgZmlyc3QgcmVuZGVyXG5cblx0XHRcdFx0Zm9yIChjb25zdCB0eXBlIGluIHRoaXMuJCRsKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiQkbFt0eXBlXSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkYy4kb24odHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0dGhpcy4kJGxfdS5zZXQobGlzdGVuZXIsIHVuc3ViKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy4kJGwgPSB7fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBXZSBkb24ndCBuZWVkIHRoaXMgd2hlbiB3b3JraW5nIHdpdGhpbiBTdmVsdGUgY29kZSwgYnV0IGZvciBjb21wYXRpYmlsaXR5IG9mIHBlb3BsZSB1c2luZyB0aGlzIG91dHNpZGUgb2YgU3ZlbHRlXG5cdFx0Ly8gYW5kIHNldHRpbmcgYXR0cmlidXRlcyB0aHJvdWdoIHNldEF0dHJpYnV0ZSBldGMsIHRoaXMgaXMgaGVscGZ1bFxuXHRcdGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy4kJHIpIHJldHVybjtcblx0XHRcdGF0dHIgPSB0aGlzLiQkZ19wKGF0dHIpO1xuXHRcdFx0dGhpcy4kJGRbYXR0cl0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoYXR0ciwgbmV3VmFsdWUsIHRoaXMuJCRwX2QsICd0b1Byb3AnKTtcblx0XHRcdHRoaXMuJCRjPy4kc2V0KHsgW2F0dHJdOiB0aGlzLiQkZFthdHRyXSB9KTtcblx0XHR9XG5cblx0XHRkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuJCRjbiA9IGZhbHNlO1xuXHRcdFx0Ly8gSW4gYSBtaWNyb3Rhc2ssIGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhIG1vdmUgd2l0aGluIHRoZSBET01cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjbiAmJiB0aGlzLiQkYykge1xuXHRcdFx0XHRcdHRoaXMuJCRjLiRkZXN0cm95KCk7XG5cdFx0XHRcdFx0dGhpcy4kJGMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdCQkZ19wKGF0dHJpYnV0ZV9uYW1lKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRPYmplY3Qua2V5cyh0aGlzLiQkcF9kKS5maW5kKFxuXHRcdFx0XHRcdChrZXkpID0+XG5cdFx0XHRcdFx0XHR0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlID09PSBhdHRyaWJ1dGVfbmFtZSB8fFxuXHRcdFx0XHRcdFx0KCF0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBhdHRyaWJ1dGVfbmFtZSlcblx0XHRcdFx0KSB8fCBhdHRyaWJ1dGVfbmFtZVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uXG4gKiBAcGFyYW0geyd0b0F0dHJpYnV0ZScgfCAndG9Qcm9wJ30gW3RyYW5zZm9ybV1cbiAqL1xuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uLCB0cmFuc2Zvcm0pIHtcblx0Y29uc3QgdHlwZSA9IHByb3BzX2RlZmluaXRpb25bcHJvcF0/LnR5cGU7XG5cdHZhbHVlID0gdHlwZSA9PT0gJ0Jvb2xlYW4nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nID8gdmFsdWUgIT0gbnVsbCA6IHZhbHVlO1xuXHRpZiAoIXRyYW5zZm9ybSB8fCAhcHJvcHNfZGVmaW5pdGlvbltwcm9wXSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSBlbHNlIGlmICh0cmFuc2Zvcm0gPT09ICd0b0F0dHJpYnV0ZScpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnJyA6IG51bGw7XG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlOyAvLyBjb252ZXJzaW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZVxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICE9IG51bGwgPyArdmFsdWUgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBUdXJuIGEgU3ZlbHRlIGNvbXBvbmVudCBpbnRvIGEgY3VzdG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRUeXBlfSBDb21wb25lbnQgIEEgU3ZlbHRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uICBUaGUgcHJvcHMgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gc2xvdHMgIFRoZSBzbG90cyB0byBjcmVhdGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFjY2Vzc29ycyAgT3RoZXIgYWNjZXNzb3JzIGJlc2lkZXMgdGhlIG9uZXMgZm9yIHByb3BzIHRoZSBjb21wb25lbnQgaGFzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZV9zaGFkb3dfZG9tICBXaGV0aGVyIHRvIHVzZSBzaGFkb3cgRE9NXG4gKiBAcGFyYW0geyhjZTogbmV3ICgpID0+IEhUTUxFbGVtZW50KSA9PiBuZXcgKCkgPT4gSFRNTEVsZW1lbnR9IFtleHRlbmRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2VsZW1lbnQoXG5cdENvbXBvbmVudCxcblx0cHJvcHNfZGVmaW5pdGlvbixcblx0c2xvdHMsXG5cdGFjY2Vzc29ycyxcblx0dXNlX3NoYWRvd19kb20sXG5cdGV4dGVuZFxuKSB7XG5cdGxldCBDbGFzcyA9IGNsYXNzIGV4dGVuZHMgU3ZlbHRlRWxlbWVudCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcihDb21wb25lbnQsIHNsb3RzLCB1c2Vfc2hhZG93X2RvbSk7XG5cdFx0XHR0aGlzLiQkcF9kID0gcHJvcHNfZGVmaW5pdGlvbjtcblx0XHR9XG5cdFx0c3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMocHJvcHNfZGVmaW5pdGlvbikubWFwKChrZXkpID0+XG5cdFx0XHRcdChwcm9wc19kZWZpbml0aW9uW2tleV0uYXR0cmlidXRlIHx8IGtleSkudG9Mb3dlckNhc2UoKVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG5cdE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLmZvckVhY2goKHByb3ApID0+IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBwcm9wLCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkYyAmJiBwcm9wIGluIHRoaXMuJCRjID8gdGhpcy4kJGNbcHJvcF0gOiB0aGlzLiQkZFtwcm9wXTtcblx0XHRcdH0sXG5cdFx0XHRzZXQodmFsdWUpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUocHJvcCwgdmFsdWUsIHByb3BzX2RlZmluaXRpb24pO1xuXHRcdFx0XHR0aGlzLiQkZFtwcm9wXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLiQkYz8uJHNldCh7IFtwcm9wXTogdmFsdWUgfSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRhY2Nlc3NvcnMuZm9yRWFjaCgoYWNjZXNzb3IpID0+IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBhY2Nlc3Nvciwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGM/LlthY2Nlc3Nvcl07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRpZiAoZXh0ZW5kKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciAtIGFzc2lnbmluZyBoZXJlIGlzIGZpbmVcblx0XHRDbGFzcyA9IGV4dGVuZChDbGFzcyk7XG5cdH1cblx0Q29tcG9uZW50LmVsZW1lbnQgPSAvKiogQHR5cGUge2FueX0gKi8gKENsYXNzKTtcblx0cmV0dXJuIENsYXNzO1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Byb3BzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50cz1hbnldXG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVDb21wb25lbnQge1xuXHQvKipcblx0ICogIyMjIFBSSVZBVEUgQVBJXG5cdCAqXG5cdCAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcblx0ICpcblx0ICogQHR5cGUge2FueX1cblx0ICovXG5cdCQkID0gdW5kZWZpbmVkO1xuXHQvKipcblx0ICogIyMjIFBSSVZBVEUgQVBJXG5cdCAqXG5cdCAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcblx0ICpcblx0ICogQHR5cGUge2FueX1cblx0ICovXG5cdCQkc2V0ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGRlc3Ryb3koKSB7XG5cdFx0ZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG5cdFx0dGhpcy4kZGVzdHJveSA9IG5vb3A7XG5cdH1cblxuXHQvKipcblx0ICogQHRlbXBsYXRlIHtFeHRyYWN0PGtleW9mIEV2ZW50cywgc3RyaW5nPn0gS1xuXHQgKiBAcGFyYW0ge0t9IHR5cGVcblx0ICogQHBhcmFtIHsoKGU6IEV2ZW50c1tLXSkgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkfSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cblx0ICovXG5cdCRvbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdGlmICghaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdFx0XHRyZXR1cm4gbm9vcDtcblx0XHR9XG5cdFx0Y29uc3QgY2FsbGJhY2tzID0gdGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pO1xuXHRcdGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGFydGlhbDxQcm9wcz59IHByb3BzXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0JHNldChwcm9wcykge1xuXHRcdGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eShwcm9wcykpIHtcblx0XHRcdHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG5cdFx0XHR0aGlzLiQkc2V0KHByb3BzKTtcblx0XHRcdHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJ1dGVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWZsZWN0XVxuICogQHByb3BlcnR5IHsnU3RyaW5nJ3wnQm9vbGVhbid8J051bWJlcid8J0FycmF5J3wnT2JqZWN0J30gW3R5cGVdXG4gKi9cbiIsImltcG9ydCB7XG5cdGN1c3RvbV9ldmVudCxcblx0YXBwZW5kLFxuXHRhcHBlbmRfaHlkcmF0aW9uLFxuXHRpbnNlcnQsXG5cdGluc2VydF9oeWRyYXRpb24sXG5cdGRldGFjaCxcblx0bGlzdGVuLFxuXHRhdHRyXG59IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IFN2ZWx0ZUNvbXBvbmVudCB9IGZyb20gJy4vQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IGlzX3ZvaWQgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMvbmFtZXMuanMnO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4uLy4uL3NoYXJlZC92ZXJzaW9uLmpzJztcbmltcG9ydCB7IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVfYXJyYXlfbGlrZSB9IGZyb20gJy4vZWFjaC5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcblx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgeyB2ZXJzaW9uOiBWRVJTSU9OLCAuLi5kZXRhaWwgfSwgeyBidWJibGVzOiB0cnVlIH0pKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG5cdGFwcGVuZCh0YXJnZXQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlKSB7XG5cdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG5cdGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydF9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuXHRpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuXG4vKiogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG5cdGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmUnLCB7IG5vZGUgfSk7XG5cdGRldGFjaChub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IGJlZm9yZVxuICogQHBhcmFtIHtOb2RlfSBhZnRlclxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuXHR3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nICYmIGJlZm9yZS5uZXh0U2libGluZyAhPT0gYWZ0ZXIpIHtcblx0XHRkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IGFmdGVyXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGFjaF9iZWZvcmVfZGV2KGFmdGVyKSB7XG5cdHdoaWxlIChhZnRlci5wcmV2aW91c1NpYmxpbmcpIHtcblx0XHRkZXRhY2hfZGV2KGFmdGVyLnByZXZpb3VzU2libGluZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IGJlZm9yZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuXHR3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nKSB7XG5cdFx0ZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCBFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNfcHJldmVudF9kZWZhdWx0XVxuICogQHBhcmFtIHtib29sZWFufSBbaGFzX3N0b3BfcHJvcGFnYXRpb25dXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXNfc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb25dXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbl9kZXYoXG5cdG5vZGUsXG5cdGV2ZW50LFxuXHRoYW5kbGVyLFxuXHRvcHRpb25zLFxuXHRoYXNfcHJldmVudF9kZWZhdWx0LFxuXHRoYXNfc3RvcF9wcm9wYWdhdGlvbixcblx0aGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uXG4pIHtcblx0Y29uc3QgbW9kaWZpZXJzID1cblx0XHRvcHRpb25zID09PSB0cnVlID8gWydjYXB0dXJlJ10gOiBvcHRpb25zID8gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvcHRpb25zKSkgOiBbXTtcblx0aWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuXHRpZiAoaGFzX3N0b3BfcHJvcGFnYXRpb24pIG1vZGlmaWVycy5wdXNoKCdzdG9wUHJvcGFnYXRpb24nKTtcblx0aWYgKGhhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbikgbW9kaWZpZXJzLnB1c2goJ3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbicpO1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUFkZEV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG5cdGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcblx0XHRkaXNwb3NlKCk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyX2Rldihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlIH0pO1xuXHRlbHNlIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0QXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wX2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcblx0bm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG5cdG5vZGUuZGF0YXNldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcblx0ZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhc2V0JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQuZGF0YSA9PT0gZGF0YSkgcmV0dXJuO1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG5cdHRleHQuZGF0YSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSkgcmV0dXJuO1xuXHRkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG5cdHRleHQuZGF0YSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyX3ZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuXHRpZiAofmNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLmluZGV4T2YoYXR0cl92YWx1ZSkpIHtcblx0XHRzZXRfZGF0YV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEpO1xuXHR9IGVsc2Uge1xuXHRcdHNldF9kYXRhX2Rldih0ZXh0LCBkYXRhKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlX2FycmF5X2xpa2VfZGV2KGFyZykge1xuXHRpZiAoXG5cdFx0dHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiZcblx0XHQhKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBhcmcpICYmXG5cdFx0ISh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGFyZyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnKVxuXHQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3sjZWFjaH0gb25seSB3b3JrcyB3aXRoIGl0ZXJhYmxlIHZhbHVlcy4nKTtcblx0fVxuXHRyZXR1cm4gZW5zdXJlX2FycmF5X2xpa2UoYXJnKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG5cdGZvciAoY29uc3Qgc2xvdF9rZXkgb2YgT2JqZWN0LmtleXMoc2xvdCkpIHtcblx0XHRpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gdGFnXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcblx0Y29uc3QgaXNfc3RyaW5nID0gdHlwZW9mIHRhZyA9PT0gJ3N0cmluZyc7XG5cdGlmICh0YWcgJiYgIWlzX3N0cmluZykge1xuXHRcdHRocm93IG5ldyBFcnJvcignPHN2ZWx0ZTplbGVtZW50PiBleHBlY3RzIFwidGhpc1wiIGF0dHJpYnV0ZSB0byBiZSBhIHN0cmluZy4nKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgc3RyaW5nfSB0YWdcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnKSB7XG5cdGlmICh0YWcgJiYgaXNfdm9pZCh0YWcpKSB7XG5cdFx0Y29uc29sZS53YXJuKGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPiBpcyBzZWxmLWNsb3NpbmcgYW5kIGNhbm5vdCBoYXZlIGNvbnRlbnQuYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2Rldihjb21wb25lbnQsIHByb3BzKSB7XG5cdGNvbnN0IGVycm9yX21lc3NhZ2UgPSAndGhpcz17Li4ufSBvZiA8c3ZlbHRlOmNvbXBvbmVudD4gc2hvdWxkIHNwZWNpZnkgYSBTdmVsdGUgY29tcG9uZW50Lic7XG5cdHRyeSB7XG5cdFx0Y29uc3QgaW5zdGFuY2UgPSBuZXcgY29tcG9uZW50KHByb3BzKTtcblx0XHRpZiAoIWluc3RhbmNlLiQkIHx8ICFpbnN0YW5jZS4kc2V0IHx8ICFpbnN0YW5jZS4kb24gfHwgIWluc3RhbmNlLiRkZXN0cm95KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JfbWVzc2FnZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Y29uc3QgeyBtZXNzYWdlIH0gPSBlcnI7XG5cdFx0aWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyAmJiBtZXNzYWdlLmluZGV4T2YoJ2lzIG5vdCBhIGNvbnN0cnVjdG9yJykgIT09IC0xKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JfbWVzc2FnZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IGVycjtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIGNyZWF0ZSBzdHJvbmdseSB0eXBlZCBTdmVsdGUgY29tcG9uZW50cy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogWW91IGhhdmUgY29tcG9uZW50IGxpYnJhcnkgb24gbnBtIGNhbGxlZCBgY29tcG9uZW50LWxpYnJhcnlgLCBmcm9tIHdoaWNoXG4gKiB5b3UgZXhwb3J0IGEgY29tcG9uZW50IGNhbGxlZCBgTXlDb21wb25lbnRgLiBGb3IgU3ZlbHRlK1R5cGVTY3JpcHQgdXNlcnMsXG4gKiB5b3Ugd2FudCB0byBwcm92aWRlIHR5cGluZ3MuIFRoZXJlZm9yZSB5b3UgY3JlYXRlIGEgYGluZGV4LmQudHNgOlxuICogYGBgdHNcbiAqIGltcG9ydCB7IFN2ZWx0ZUNvbXBvbmVudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogYGBgXG4gKiBUeXBpbmcgdGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgSURFcyBsaWtlIFZTIENvZGUgd2l0aCB0aGUgU3ZlbHRlIGV4dGVuc2lvblxuICogdG8gcHJvdmlkZSBpbnRlbGxpc2Vuc2UgYW5kIHRvIHVzZSB0aGUgY29tcG9uZW50IGxpa2UgdGhpcyBpbiBhIFN2ZWx0ZSBmaWxlXG4gKiB3aXRoIFR5cGVTY3JpcHQ6XG4gKiBgYGBzdmVsdGVcbiAqIDxzY3JpcHQgbGFuZz1cInRzXCI+XG4gKiBcdGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSBcImNvbXBvbmVudC1saWJyYXJ5XCI7XG4gKiA8L3NjcmlwdD5cbiAqIDxNeUNvbXBvbmVudCBmb289eydiYXInfSAvPlxuICogYGBgXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtQcm9wcz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudHM9YW55XVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbU2xvdHM9YW55XVxuICogQGV4dGVuZHMge1N2ZWx0ZUNvbXBvbmVudDxQcm9wcywgRXZlbnRzPn1cbiAqL1xuZXhwb3J0IGNsYXNzIFN2ZWx0ZUNvbXBvbmVudERldiBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBGb3IgdHlwZSBjaGVja2luZyBjYXBhYmlsaXRpZXMgb25seS5cblx0ICogRG9lcyBub3QgZXhpc3QgYXQgcnVudGltZS5cblx0ICogIyMjIERPIE5PVCBVU0UhXG5cdCAqXG5cdCAqIEB0eXBlIHtQcm9wc31cblx0ICovXG5cdCQkcHJvcF9kZWY7XG5cdC8qKlxuXHQgKiBGb3IgdHlwZSBjaGVja2luZyBjYXBhYmlsaXRpZXMgb25seS5cblx0ICogRG9lcyBub3QgZXhpc3QgYXQgcnVudGltZS5cblx0ICogIyMjIERPIE5PVCBVU0UhXG5cdCAqXG5cdCAqIEB0eXBlIHtFdmVudHN9XG5cdCAqL1xuXHQkJGV2ZW50c19kZWY7XG5cdC8qKlxuXHQgKiBGb3IgdHlwZSBjaGVja2luZyBjYXBhYmlsaXRpZXMgb25seS5cblx0ICogRG9lcyBub3QgZXhpc3QgYXQgcnVudGltZS5cblx0ICogIyMjIERPIE5PVCBVU0UhXG5cdCAqXG5cdCAqIEB0eXBlIHtTbG90c31cblx0ICovXG5cdCQkc2xvdF9kZWY7XG5cblx0LyoqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkNvbXBvbmVudENvbnN0cnVjdG9yT3B0aW9uczxQcm9wcz59IG9wdGlvbnMgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucyB8fCAoIW9wdGlvbnMudGFyZ2V0ICYmICFvcHRpb25zLiQkaW5saW5lKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiJ3RhcmdldCcgaXMgYSByZXF1aXJlZCBvcHRpb25cIik7XG5cdFx0fVxuXHRcdHN1cGVyKCk7XG5cdH1cblxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdCRkZXN0cm95KCkge1xuXHRcdHN1cGVyLiRkZXN0cm95KCk7XG5cdFx0dGhpcy4kZGVzdHJveSA9ICgpID0+IHtcblx0XHRcdGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0XHR9O1xuXHR9XG5cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHQkY2FwdHVyZV9zdGF0ZSgpIHt9XG5cblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHQkaW5qZWN0X3N0YXRlKCkge31cbn1cbi8qKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbUHJvcHM9YW55XVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Nsb3RzPWFueV1cbiAqIEBkZXByZWNhdGVkIFVzZSBgU3ZlbHRlQ29tcG9uZW50YCBpbnN0ZWFkLiBTZWUgUFIgZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC84NTEyXG4gKiBAZXh0ZW5kcyB7U3ZlbHRlQ29tcG9uZW50RGV2PFByb3BzLCBFdmVudHMsIFNsb3RzPn1cbiAqL1xuZXhwb3J0IGNsYXNzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkIGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50RGV2IHt9XG5cbi8qKiBAcmV0dXJucyB7KCkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcblx0Y29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3AgZGV0ZWN0ZWQnKTtcblx0XHR9XG5cdH07XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL2FuaW1hdGlvbnMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hd2FpdF9ibG9jay5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2RvbS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZ2xvYmFscy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2VhY2guanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9sb29wLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc2NoZWR1bGVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc3ByZWFkLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc3NyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0NvbXBvbmVudC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Rldi5qcyc7XG4iXSwibmFtZXMiOlsibm9vcCIsImlkZW50aXR5IiwieCIsImFzc2lnbiIsInRhciIsInNyYyIsImsiLCJpc19wcm9taXNlIiwidmFsdWUiLCJ0aGVuIiwiYWRkX2xvY2F0aW9uIiwiZWxlbWVudCIsImZpbGUiLCJsaW5lIiwiY29sdW1uIiwiY2hhciIsIl9fc3ZlbHRlX21ldGEiLCJsb2MiLCJydW4iLCJmbiIsImJsYW5rX29iamVjdCIsIk9iamVjdCIsImNyZWF0ZSIsInJ1bl9hbGwiLCJmbnMiLCJmb3JFYWNoIiwiaXNfZnVuY3Rpb24iLCJ0aGluZyIsInNhZmVfbm90X2VxdWFsIiwiYSIsImIiLCJzcmNfdXJsX2VxdWFsX2FuY2hvciIsInNyY191cmxfZXF1YWwiLCJlbGVtZW50X3NyYyIsInVybCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJzcGxpdF9zcmNzZXQiLCJzcmNzZXQiLCJzcGxpdCIsIm1hcCIsInRyaW0iLCJmaWx0ZXIiLCJCb29sZWFuIiwic3Jjc2V0X3VybF9lcXVhbCIsImVsZW1lbnRfc3Jjc2V0IiwiZWxlbWVudF91cmxzIiwidXJscyIsImxlbmd0aCIsImV2ZXJ5Iiwid2lkdGgiLCJpIiwibm90X2VxdWFsIiwiaXNfZW1wdHkiLCJvYmoiLCJrZXlzIiwidmFsaWRhdGVfc3RvcmUiLCJzdG9yZSIsIm5hbWUiLCJzdWJzY3JpYmUiLCJFcnJvciIsImNhbGxiYWNrcyIsImNhbGxiYWNrIiwidW5kZWZpbmVkIiwidW5zdWIiLCJ1bnN1YnNjcmliZSIsImdldF9zdG9yZV92YWx1ZSIsIl8iLCJjb21wb25lbnRfc3Vic2NyaWJlIiwiY29tcG9uZW50IiwiJCQiLCJvbl9kZXN0cm95IiwicHVzaCIsImNyZWF0ZV9zbG90IiwiZGVmaW5pdGlvbiIsImN0eCIsIiQkc2NvcGUiLCJzbG90X2N0eCIsImdldF9zbG90X2NvbnRleHQiLCJzbGljZSIsImdldF9zbG90X2NoYW5nZXMiLCJkaXJ0eSIsImxldHMiLCJtZXJnZWQiLCJsZW4iLCJNYXRoIiwibWF4IiwidXBkYXRlX3Nsb3RfYmFzZSIsInNsb3QiLCJzbG90X2RlZmluaXRpb24iLCJzbG90X2NoYW5nZXMiLCJnZXRfc2xvdF9jb250ZXh0X2ZuIiwic2xvdF9jb250ZXh0IiwicCIsInVwZGF0ZV9zbG90IiwiZ2V0X3Nsb3RfY2hhbmdlc19mbiIsImdldF9hbGxfZGlydHlfZnJvbV9zY29wZSIsImV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMiLCJwcm9wcyIsInJlc3VsdCIsImNvbXB1dGVfcmVzdF9wcm9wcyIsInJlc3QiLCJTZXQiLCJoYXMiLCJjb21wdXRlX3Nsb3RzIiwic2xvdHMiLCJrZXkiLCJvbmNlIiwicmFuIiwiYXJncyIsImNhbGwiLCJudWxsX3RvX2VtcHR5Iiwic2V0X3N0b3JlX3ZhbHVlIiwicmV0Iiwic2V0IiwiaGFzX3Byb3AiLCJwcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJhY3Rpb25fZGVzdHJveWVyIiwiYWN0aW9uX3Jlc3VsdCIsImRlc3Ryb3kiLCJzcGxpdF9jc3NfdW5pdCIsIm1hdGNoIiwicGFyc2VGbG9hdCIsImNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzIiwiaXNfY2xpZW50Iiwid2luZG93Iiwibm93IiwicGVyZm9ybWFuY2UiLCJEYXRlIiwicmFmIiwiY2IiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRfbm93Iiwic2V0X3JhZiIsInRhc2tzIiwicnVuX3Rhc2tzIiwidGFzayIsImMiLCJkZWxldGUiLCJmIiwic2l6ZSIsImNsZWFyX2xvb3BzIiwiY2xlYXIiLCJsb29wIiwicHJvbWlzZSIsIlByb21pc2UiLCJmdWxmaWxsIiwiYWRkIiwiYWJvcnQiLCJnbG9iYWxzIiwiZ2xvYmFsVGhpcyIsImdsb2JhbCIsIlJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIiwiX2xpc3RlbmVycyIsIldlYWtNYXAiLCJfb2JzZXJ2ZXIiLCJvcHRpb25zIiwiY29uc3RydWN0b3IiLCJvYnNlcnZlIiwibGlzdGVuZXIiLCJfZ2V0T2JzZXJ2ZXIiLCJ1bm9ic2VydmUiLCJSZXNpemVPYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsInRhcmdldCIsImdldCIsImlzX2h5ZHJhdGluZyIsInN0YXJ0X2h5ZHJhdGluZyIsImVuZF9oeWRyYXRpbmciLCJ1cHBlcl9ib3VuZCIsImxvdyIsImhpZ2giLCJtaWQiLCJpbml0X2h5ZHJhdGUiLCJoeWRyYXRlX2luaXQiLCJjaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJub2RlTmFtZSIsIm15X2NoaWxkcmVuIiwibm9kZSIsImNsYWltX29yZGVyIiwibSIsIkludDMyQXJyYXkiLCJsb25nZXN0IiwiY3VycmVudCIsInNlcV9sZW4iLCJpZHgiLCJuZXdfbGVuIiwibGlzIiwidG9fbW92ZSIsImxhc3QiLCJjdXIiLCJyZXZlcnNlIiwic29ydCIsImoiLCJhbmNob3IiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmQiLCJhcHBlbmRDaGlsZCIsImFwcGVuZF9zdHlsZXMiLCJzdHlsZV9zaGVldF9pZCIsInN0eWxlcyIsImFwcGVuZF9zdHlsZXNfdG8iLCJnZXRfcm9vdF9mb3Jfc3R5bGUiLCJnZXRFbGVtZW50QnlJZCIsInN0eWxlIiwiaWQiLCJ0ZXh0Q29udGVudCIsImFwcGVuZF9zdHlsZXNoZWV0Iiwicm9vdCIsImdldFJvb3ROb2RlIiwib3duZXJEb2N1bWVudCIsImhvc3QiLCJhcHBlbmRfZW1wdHlfc3R5bGVzaGVldCIsInN0eWxlX2VsZW1lbnQiLCJzaGVldCIsImhlYWQiLCJhcHBlbmRfaHlkcmF0aW9uIiwiYWN0dWFsX2VuZF9jaGlsZCIsInBhcmVudE5vZGUiLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJpbnNlcnQiLCJpbnNlcnRfaHlkcmF0aW9uIiwiZGV0YWNoIiwicmVtb3ZlQ2hpbGQiLCJkZXN0cm95X2VhY2giLCJpdGVyYXRpb25zIiwiZGV0YWNoaW5nIiwiZCIsImVsZW1lbnRfaXMiLCJpcyIsIm9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMiLCJleGNsdWRlIiwiaW5kZXhPZiIsInN2Z19lbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwidGV4dCIsImRhdGEiLCJjcmVhdGVUZXh0Tm9kZSIsInNwYWNlIiwiZW1wdHkiLCJjb21tZW50IiwiY29udGVudCIsImNyZWF0ZUNvbW1lbnQiLCJsaXN0ZW4iLCJldmVudCIsImhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInByZXZlbnRfZGVmYXVsdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcF9wcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsInN0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwic2VsZiIsInRydXN0ZWQiLCJpc1RydXN0ZWQiLCJhdHRyIiwiYXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiYWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUiLCJzZXRfYXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJkZXNjcmlwdG9ycyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJfX3Byb3RvX18iLCJjc3NUZXh0Iiwic2V0X3N2Z19hdHRyaWJ1dGVzIiwic2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwIiwiZGF0YV9tYXAiLCJzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YSIsImxvd2VyIiwidG9Mb3dlckNhc2UiLCJzZXRfZHluYW1pY19lbGVtZW50X2RhdGEiLCJ0YWciLCJ0ZXN0IiwieGxpbmtfYXR0ciIsInNldEF0dHJpYnV0ZU5TIiwiZ2V0X3N2ZWx0ZV9kYXRhc2V0IiwiZGF0YXNldCIsInN2ZWx0ZUgiLCJnZXRfYmluZGluZ19ncm91cF92YWx1ZSIsImdyb3VwIiwiX192YWx1ZSIsImNoZWNrZWQiLCJBcnJheSIsImZyb20iLCJpbml0X2JpbmRpbmdfZ3JvdXAiLCJfaW5wdXRzIiwiaW5wdXRzIiwiaW5wdXQiLCJyIiwic3BsaWNlIiwiaW5pdF9iaW5kaW5nX2dyb3VwX2R5bmFtaWMiLCJpbmRleGVzIiwiX2dyb3VwIiwiZ2V0X2JpbmRpbmdfZ3JvdXAiLCJyZW1vdmUiLCJ1IiwibmV3X2luZGV4ZXMiLCJuZXdfZ3JvdXAiLCJ0b19udW1iZXIiLCJ0aW1lX3Jhbmdlc190b19hcnJheSIsInJhbmdlcyIsImFycmF5Iiwic3RhcnQiLCJlbmQiLCJpbml0X2NsYWltX2luZm8iLCJub2RlcyIsImNsYWltX2luZm8iLCJsYXN0X2luZGV4IiwidG90YWxfY2xhaW1lZCIsImNsYWltX25vZGUiLCJwcmVkaWNhdGUiLCJwcm9jZXNzX25vZGUiLCJjcmVhdGVfbm9kZSIsImRvbnRfdXBkYXRlX2xhc3RfaW5kZXgiLCJyZXN1bHRfbm9kZSIsInJlcGxhY2VtZW50IiwiY2xhaW1fZWxlbWVudF9iYXNlIiwiY3JlYXRlX2VsZW1lbnQiLCJ2IiwiY2xhaW1fZWxlbWVudCIsImNsYWltX3N2Z19lbGVtZW50IiwiY2xhaW1fdGV4dCIsIm5vZGVUeXBlIiwiZGF0YV9zdHIiLCJzdGFydHNXaXRoIiwic3BsaXRUZXh0IiwiY2xhaW1fc3BhY2UiLCJjbGFpbV9jb21tZW50IiwiZ2V0X2NvbW1lbnRfaWR4IiwiY2xhaW1faHRtbF90YWciLCJpc19zdmciLCJzdGFydF9pbmRleCIsImVuZF9pbmRleCIsIkh0bWxUYWdIeWRyYXRpb24iLCJodG1sX3RhZ19ub2RlcyIsImNsYWltZWRfbm9kZXMiLCJuIiwic2V0X2RhdGEiLCJzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUiLCJ3aG9sZVRleHQiLCJzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUiLCJhdHRyX3ZhbHVlIiwic2V0X2lucHV0X3ZhbHVlIiwic2V0X2lucHV0X3R5cGUiLCJ0eXBlIiwiZSIsInNldF9zdHlsZSIsImltcG9ydGFudCIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJzZWxlY3Rfb3B0aW9uIiwic2VsZWN0IiwibW91bnRpbmciLCJvcHRpb24iLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5kZXgiLCJzZWxlY3Rfb3B0aW9ucyIsInNlbGVjdF92YWx1ZSIsInNlbGVjdGVkX29wdGlvbiIsInF1ZXJ5U2VsZWN0b3IiLCJzZWxlY3RfbXVsdGlwbGVfdmFsdWUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY3Jvc3NvcmlnaW4iLCJpc19jcm9zc29yaWdpbiIsInBhcmVudCIsImVycm9yIiwiYWRkX2lmcmFtZV9yZXNpemVfbGlzdGVuZXIiLCJjb21wdXRlZF9zdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJwb3NpdGlvbiIsImlmcmFtZSIsInRhYkluZGV4Iiwic291cmNlIiwiY29udGVudFdpbmRvdyIsIm9ubG9hZCIsInJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCIsImJveCIsInJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94IiwicmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCIsInRvZ2dsZV9jbGFzcyIsInRvZ2dsZSIsImNsYXNzTGlzdCIsImN1c3RvbV9ldmVudCIsImRldGFpbCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiQ3VzdG9tRXZlbnQiLCJxdWVyeV9zZWxlY3Rvcl9hbGwiLCJzZWxlY3RvciIsImJvZHkiLCJoZWFkX3NlbGVjdG9yIiwibm9kZUlkIiwic3RhcnRlZCIsIkh0bWxUYWciLCJ0IiwiaHRtbCIsImgiLCJ0YWdOYW1lIiwiaW5uZXJIVE1MIiwibCIsImF0dHJpYnV0ZV90b19vYmplY3QiLCJlc2NhcGVkIiwicmVnZXhfYXR0cmlidXRlX2NoYXJhY3RlcnNfdG9fZXNjYXBlIiwiZXNjYXBlX2F0dHJpYnV0ZSIsIlN0cmluZyIsInJlcGxhY2UiLCJzdHJpbmdpZnlfc3ByZWFkIiwic3RyIiwiZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyIsImNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50IiwibWFuYWdlZF9zdHlsZXMiLCJNYXAiLCJhY3RpdmUiLCJoYXNoIiwiY2hhckNvZGVBdCIsImNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbiIsImRvYyIsImluZm8iLCJzdHlsZXNoZWV0IiwicnVsZXMiLCJjcmVhdGVfcnVsZSIsImR1cmF0aW9uIiwiZGVsYXkiLCJlYXNlIiwidWlkIiwic3RlcCIsImtleWZyYW1lcyIsInJ1bGUiLCJpbnNlcnRSdWxlIiwiY3NzUnVsZXMiLCJhbmltYXRpb24iLCJkZWxldGVfcnVsZSIsInByZXZpb3VzIiwibmV4dCIsImFuaW0iLCJkZWxldGVkIiwiam9pbiIsImNsZWFyX3J1bGVzIiwib3duZXJOb2RlIiwibGluZWFyIiwiY3JlYXRlX2FuaW1hdGlvbiIsInBhcmFtcyIsInRvIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwiZWFzaW5nIiwic3RhcnRfdGltZSIsInRpY2siLCJjc3MiLCJydW5uaW5nIiwic3RvcCIsImZpeF9wb3NpdGlvbiIsImhlaWdodCIsImFkZF90cmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJjdXJyZW50X2NvbXBvbmVudCIsInNldF9jdXJyZW50X2NvbXBvbmVudCIsImdldF9jdXJyZW50X2NvbXBvbmVudCIsImJlZm9yZVVwZGF0ZSIsImJlZm9yZV91cGRhdGUiLCJvbk1vdW50Iiwib25fbW91bnQiLCJhZnRlclVwZGF0ZSIsImFmdGVyX3VwZGF0ZSIsIm9uRGVzdHJveSIsImNyZWF0ZUV2ZW50RGlzcGF0Y2hlciIsImRlZmF1bHRQcmV2ZW50ZWQiLCJzZXRDb250ZXh0IiwiY29udGV4dCIsImdldENvbnRleHQiLCJnZXRBbGxDb250ZXh0cyIsImhhc0NvbnRleHQiLCJidWJibGUiLCJkaXJ0eV9jb21wb25lbnRzIiwiaW50cm9zIiwiZW5hYmxlZCIsImJpbmRpbmdfY2FsbGJhY2tzIiwicmVuZGVyX2NhbGxiYWNrcyIsImZsdXNoX2NhbGxiYWNrcyIsInJlc29sdmVkX3Byb21pc2UiLCJyZXNvbHZlIiwidXBkYXRlX3NjaGVkdWxlZCIsInNjaGVkdWxlX3VwZGF0ZSIsImZsdXNoIiwiYWRkX3JlbmRlcl9jYWxsYmFjayIsImFkZF9mbHVzaF9jYWxsYmFjayIsInNlZW5fY2FsbGJhY2tzIiwiZmx1c2hpZHgiLCJzYXZlZF9jb21wb25lbnQiLCJ1cGRhdGUiLCJwb3AiLCJmcmFnbWVudCIsImZsdXNoX3JlbmRlcl9jYWxsYmFja3MiLCJmaWx0ZXJlZCIsInRhcmdldHMiLCJ3YWl0IiwiZGlzcGF0Y2giLCJkaXJlY3Rpb24iLCJraW5kIiwiZGlzcGF0Y2hFdmVudCIsIm91dHJvaW5nIiwib3V0cm9zIiwiZ3JvdXBfb3V0cm9zIiwiY2hlY2tfb3V0cm9zIiwidHJhbnNpdGlvbl9pbiIsImJsb2NrIiwibG9jYWwiLCJ0cmFuc2l0aW9uX291dCIsIm8iLCJudWxsX3RyYW5zaXRpb24iLCJjcmVhdGVfaW5fdHJhbnNpdGlvbiIsImNvbmZpZyIsImFuaW1hdGlvbl9uYW1lIiwiY2xlYW51cCIsImdvIiwiZW5kX3RpbWUiLCJpbnZhbGlkYXRlIiwiY3JlYXRlX291dF90cmFuc2l0aW9uIiwib3JpZ2luYWxfaW5lcnRfdmFsdWUiLCJpbmVydCIsInJlc2V0IiwiY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbiIsImludHJvIiwicnVubmluZ19wcm9ncmFtIiwicGVuZGluZ19wcm9ncmFtIiwiY2xlYXJfYW5pbWF0aW9uIiwiaW5pdCIsInByb2dyYW0iLCJhYnMiLCJvcHRzIiwiaGFuZGxlX3Byb21pc2UiLCJ0b2tlbiIsImluZGV4IiwicmVzb2x2ZWQiLCJjaGlsZF9jdHgiLCJuZWVkc19mbHVzaCIsImJsb2NrcyIsIm1vdW50IiwiY2F0Y2giLCJoYXNDYXRjaCIsInBlbmRpbmciLCJ1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoIiwiZW5zdXJlX2FycmF5X2xpa2UiLCJhcnJheV9saWtlX29yX2l0ZXJhdG9yIiwiZGVzdHJveV9ibG9jayIsImxvb2t1cCIsIm91dHJvX2FuZF9kZXN0cm95X2Jsb2NrIiwiZml4X2FuZF9kZXN0cm95X2Jsb2NrIiwiZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayIsInVwZGF0ZV9rZXllZF9lYWNoIiwib2xkX2Jsb2NrcyIsImdldF9rZXkiLCJkeW5hbWljIiwibGlzdCIsImNyZWF0ZV9lYWNoX2Jsb2NrIiwiZ2V0X2NvbnRleHQiLCJvbGRfaW5kZXhlcyIsIm5ld19ibG9ja3MiLCJuZXdfbG9va3VwIiwiZGVsdGFzIiwidXBkYXRlcyIsIndpbGxfbW92ZSIsImRpZF9tb3ZlIiwiZmlyc3QiLCJuZXdfYmxvY2siLCJvbGRfYmxvY2siLCJuZXdfa2V5Iiwib2xkX2tleSIsInZhbGlkYXRlX2VhY2hfa2V5cyIsImdldF9zcHJlYWRfdXBkYXRlIiwibGV2ZWxzIiwidG9fbnVsbF9vdXQiLCJhY2NvdW50ZWRfZm9yIiwiZ2V0X3NwcmVhZF9vYmplY3QiLCJzcHJlYWRfcHJvcHMiLCJfYm9vbGVhbl9hdHRyaWJ1dGVzIiwiYm9vbGVhbl9hdHRyaWJ1dGVzIiwiaXNfdm9pZCIsImludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyIiwic3ByZWFkIiwiYXR0cnNfdG9fYWRkIiwiY2xhc3Nlc190b19hZGQiLCJjbGFzc2VzIiwic3R5bGVzX3RvX2FkZCIsImNsYXNzIiwic3R5bGVfb2JqZWN0X3RvX3N0cmluZyIsIm1lcmdlX3Nzcl9zdHlsZXMiLCJzdHlsZV9hdHRyaWJ1dGUiLCJzdHlsZV9kaXJlY3RpdmUiLCJzdHlsZV9vYmplY3QiLCJpbmRpdmlkdWFsX3N0eWxlIiwiY29sb25faW5kZXgiLCJBVFRSX1JFR0VYIiwiQ09OVEVOVF9SRUdFWCIsImVzY2FwZSIsImlzX2F0dHIiLCJwYXR0ZXJuIiwibGFzdEluZGV4IiwiY2giLCJzdWJzdHJpbmciLCJlc2NhcGVfYXR0cmlidXRlX3ZhbHVlIiwic2hvdWxkX2VzY2FwZSIsImVzY2FwZV9vYmplY3QiLCJlYWNoIiwiaXRlbXMiLCJtaXNzaW5nX2NvbXBvbmVudCIsIiQkcmVuZGVyIiwidmFsaWRhdGVfY29tcG9uZW50IiwiZGVidWciLCJ2YWx1ZXMiLCJjb25zb2xlIiwibG9nIiwiY3JlYXRlX3Nzcl9jb21wb25lbnQiLCJiaW5kaW5ncyIsInBhcmVudF9jb21wb25lbnQiLCJyZW5kZXIiLCIkJHNsb3RzIiwidGl0bGUiLCJjb2RlIiwiYWRkX2F0dHJpYnV0ZSIsImJvb2xlYW4iLCJhc3NpZ25tZW50IiwiYWRkX2NsYXNzZXMiLCJhZGRfc3R5bGVzIiwiYmluZCIsImJvdW5kIiwiY3JlYXRlX2NvbXBvbmVudCIsImNsYWltX2NvbXBvbmVudCIsInBhcmVudF9ub2RlcyIsIm1vdW50X2NvbXBvbmVudCIsIm5ld19vbl9kZXN0cm95IiwiZGVzdHJveV9jb21wb25lbnQiLCJtYWtlX2RpcnR5IiwiZmlsbCIsImluc3RhbmNlIiwiY3JlYXRlX2ZyYWdtZW50Iiwib25fZGlzY29ubmVjdCIsInNraXBfYm91bmQiLCJyZWFkeSIsImh5ZHJhdGUiLCJTdmVsdGVFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCIkJGN0b3IiLCIkJHMiLCIkJGMiLCIkJGNuIiwiJCRkIiwiJCRyIiwiJCRwX2QiLCIkJGwiLCIkJGxfdSIsIiQkY29tcG9uZW50Q3RvciIsInVzZV9zaGFkb3dfZG9tIiwiYXR0YWNoU2hhZG93IiwibW9kZSIsIiRvbiIsImNvbm5lY3RlZENhbGxiYWNrIiwiZXhpc3Rpbmdfc2xvdHMiLCIkJGdfcCIsImdldF9jdXN0b21fZWxlbWVudF92YWx1ZSIsInNoYWRvd1Jvb3QiLCJyZWZsZWN0X2F0dHJpYnV0ZXMiLCJyZWZsZWN0IiwiYXR0cmlidXRlX3ZhbHVlIiwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIiwiX29sZFZhbHVlIiwibmV3VmFsdWUiLCIkc2V0IiwiZGlzY29ubmVjdGVkQ2FsbGJhY2siLCIkZGVzdHJveSIsImF0dHJpYnV0ZV9uYW1lIiwiZmluZCIsInByb3BzX2RlZmluaXRpb24iLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2UiLCJjcmVhdGVfY3VzdG9tX2VsZW1lbnQiLCJDb21wb25lbnQiLCJhY2Nlc3NvcnMiLCJleHRlbmQiLCJDbGFzcyIsIm9ic2VydmVkQXR0cmlidXRlcyIsImRlZmluZVByb3BlcnR5IiwiYWNjZXNzb3IiLCJTdmVsdGVDb21wb25lbnQiLCIkJHNldCIsIlZFUlNJT04iLCJkaXNwYXRjaF9kZXYiLCJ2ZXJzaW9uIiwiYXBwZW5kX2RldiIsImFwcGVuZF9oeWRyYXRpb25fZGV2IiwiaW5zZXJ0X2RldiIsImluc2VydF9oeWRyYXRpb25fZGV2IiwiZGV0YWNoX2RldiIsImRldGFjaF9iZXR3ZWVuX2RldiIsImJlZm9yZSIsImFmdGVyIiwiZGV0YWNoX2JlZm9yZV9kZXYiLCJwcmV2aW91c1NpYmxpbmciLCJkZXRhY2hfYWZ0ZXJfZGV2IiwibGlzdGVuX2RldiIsImhhc19wcmV2ZW50X2RlZmF1bHQiLCJoYXNfc3RvcF9wcm9wYWdhdGlvbiIsImhhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbiIsIm1vZGlmaWVycyIsImRpc3Bvc2UiLCJhdHRyX2RldiIsInByb3BfZGV2IiwicHJvcGVydHkiLCJkYXRhc2V0X2RldiIsInNldF9kYXRhX2RldiIsInNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYiLCJzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGVfZGV2IiwiZW5zdXJlX2FycmF5X2xpa2VfZGV2IiwiYXJnIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ2YWxpZGF0ZV9zbG90cyIsInNsb3Rfa2V5Iiwid2FybiIsInZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCIsImlzX3N0cmluZyIsInZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50IiwiY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnRfZGV2IiwiZXJyb3JfbWVzc2FnZSIsImVyciIsIm1lc3NhZ2UiLCJTdmVsdGVDb21wb25lbnREZXYiLCIkJHByb3BfZGVmIiwiJCRldmVudHNfZGVmIiwiJCRzbG90X2RlZiIsIiQkaW5saW5lIiwiJGNhcHR1cmVfc3RhdGUiLCIkaW5qZWN0X3N0YXRlIiwiU3ZlbHRlQ29tcG9uZW50VHlwZWQiLCJsb29wX2d1YXJkIiwidGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///267\n")},100:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  o: () => (/* reexport */ spring)\n});\n\n// UNUSED EXPORTS: tweened\n\n// EXTERNAL MODULE: ./node_modules/svelte/src/runtime/internal/index.js + 18 modules\nvar internal = __webpack_require__(267);\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/store/index.js\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nfunction readable(value, start) {\n  return {\n    subscribe: store_writable(value, start).subscribe\n  };\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nfunction store_writable(value, start = internal/* noop */.lQ1) {\n  /** @type {import('./public.js').Unsubscriber} */\n  let stop;\n  /** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n  const subscribers = new Set();\n  /** @param {T} new_value\n   * @returns {void}\n   */\n  function set(new_value) {\n    if ((0,internal/* safe_not_equal */.jXN)(value, new_value)) {\n      value = new_value;\n      if (stop) {\n        // store is ready\n        const run_queue = !subscriber_queue.length;\n        for (const subscriber of subscribers) {\n          subscriber[1]();\n          subscriber_queue.push(subscriber, value);\n        }\n        if (run_queue) {\n          for (let i = 0; i < subscriber_queue.length; i += 2) {\n            subscriber_queue[i][0](subscriber_queue[i + 1]);\n          }\n          subscriber_queue.length = 0;\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import('./public.js').Updater<T>} fn\n   * @returns {void}\n   */\n  function update(fn) {\n    set(fn(value));\n  }\n\n  /**\n   * @param {import('./public.js').Subscriber<T>} run\n   * @param {import('./private.js').Invalidator<T>} [invalidate]\n   * @returns {import('./public.js').Unsubscriber}\n   */\n  function subscribe(run, invalidate = internal/* noop */.lQ1) {\n    /** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n    const subscriber = [run, invalidate];\n    subscribers.add(subscriber);\n    if (subscribers.size === 1) {\n      stop = start(set, update) || internal/* noop */.lQ1;\n    }\n    run(value);\n    return () => {\n      subscribers.delete(subscriber);\n      if (subscribers.size === 0 && stop) {\n        stop();\n        stop = null;\n      }\n    };\n  }\n  return {\n    set,\n    update,\n    subscribe\n  };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nfunction derived(stores, fn, initial_value) {\n  const single = !Array.isArray(stores);\n  /** @type {Array<import('./public.js').Readable<any>>} */\n  const stores_array = single ? [stores] : stores;\n  if (!stores_array.every(Boolean)) {\n    throw new Error('derived() expects stores as input, got a falsy value');\n  }\n  const auto = fn.length < 2;\n  return readable(initial_value, (set, update) => {\n    let started = false;\n    const values = [];\n    let pending = 0;\n    let cleanup = noop;\n    const sync = () => {\n      if (pending) {\n        return;\n      }\n      cleanup();\n      const result = fn(single ? values[0] : values, set, update);\n      if (auto) {\n        set(result);\n      } else {\n        cleanup = is_function(result) ? result : noop;\n      }\n    };\n    const unsubscribers = stores_array.map((store, i) => subscribe(store, value => {\n      values[i] = value;\n      pending &= ~(1 << i);\n      if (started) {\n        sync();\n      }\n    }, () => {\n      pending |= 1 << i;\n    }));\n    started = true;\n    sync();\n    return function stop() {\n      run_all(unsubscribers);\n      cleanup();\n      // We need to set this to false because callbacks can still happen despite having unsubscribed:\n      // Callbacks might already be placed in the queue which doesn't know it should no longer\n      // invoke this derived store.\n      started = false;\n    };\n  });\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nfunction readonly(store) {\n  return {\n    subscribe: store.subscribe.bind(store)\n  };\n}\n\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/motion/utils.js\n/**\n * @param {any} obj\n * @returns {boolean}\n */\nfunction utils_is_date(obj) {\n  return Object.prototype.toString.call(obj) === '[object Date]';\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/motion/spring.js\n\n\n\n\n/**\n * @template T\n * @param {import('./private.js').TickContext<T>} ctx\n * @param {T} last_value\n * @param {T} current_value\n * @param {T} target_value\n * @returns {T}\n */\nfunction tick_spring(ctx, last_value, current_value, target_value) {\n  if (typeof current_value === 'number' || utils_is_date(current_value)) {\n    // @ts-ignore\n    const delta = target_value - current_value;\n    // @ts-ignore\n    const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0\n    const spring = ctx.opts.stiffness * delta;\n    const damper = ctx.opts.damping * velocity;\n    const acceleration = (spring - damper) * ctx.inv_mass;\n    const d = (velocity + acceleration) * ctx.dt;\n    if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {\n      return target_value; // settled\n    } else {\n      ctx.settled = false; // signal loop to keep ticking\n      // @ts-ignore\n      return utils_is_date(current_value) ? new Date(current_value.getTime() + d) : current_value + d;\n    }\n  } else if (Array.isArray(current_value)) {\n    // @ts-ignore\n    return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));\n  } else if (typeof current_value === 'object') {\n    const next_value = {};\n    for (const k in current_value) {\n      // @ts-ignore\n      next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);\n    }\n    // @ts-ignore\n    return next_value;\n  } else {\n    throw new Error(`Cannot spring ${typeof current_value} values`);\n  }\n}\n\n/**\n * The spring function in Svelte creates a store whose value is animated, with a motion that simulates the behavior of a spring. This means when the value changes, instead of transitioning at a steady rate, it \"bounces\" like a spring would, depending on the physics parameters provided. This adds a level of realism to the transitions and can enhance the user experience.\n *\n * https://svelte.dev/docs/svelte-motion#spring\n * @template [T=any]\n * @param {T} [value]\n * @param {import('./private.js').SpringOpts} [opts]\n * @returns {import('./public.js').Spring<T>}\n */\nfunction spring(value, opts = {}) {\n  const store = store_writable(value);\n  const {\n    stiffness = 0.15,\n    damping = 0.8,\n    precision = 0.01\n  } = opts;\n  /** @type {number} */\n  let last_time;\n  /** @type {import('../internal/private.js').Task} */\n  let task;\n  /** @type {object} */\n  let current_token;\n  /** @type {T} */\n  let last_value = value;\n  /** @type {T} */\n  let target_value = value;\n  let inv_mass = 1;\n  let inv_mass_recovery_rate = 0;\n  let cancel_task = false;\n  /**\n   * @param {T} new_value\n   * @param {import('./private.js').SpringUpdateOpts} opts\n   * @returns {Promise<void>}\n   */\n  function set(new_value, opts = {}) {\n    target_value = new_value;\n    const token = current_token = {};\n    if (value == null || opts.hard || spring.stiffness >= 1 && spring.damping >= 1) {\n      cancel_task = true; // cancel any running animation\n      last_time = (0,internal/* now */.tB5)();\n      last_value = new_value;\n      store.set(value = target_value);\n      return Promise.resolve();\n    } else if (opts.soft) {\n      const rate = opts.soft === true ? 0.5 : +opts.soft;\n      inv_mass_recovery_rate = 1 / (rate * 60);\n      inv_mass = 0; // infinite mass, unaffected by spring forces\n    }\n    if (!task) {\n      last_time = (0,internal/* now */.tB5)();\n      cancel_task = false;\n      task = (0,internal/* loop */.HWo)(now => {\n        if (cancel_task) {\n          cancel_task = false;\n          task = null;\n          return false;\n        }\n        inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);\n        const ctx = {\n          inv_mass,\n          opts: spring,\n          settled: true,\n          dt: (now - last_time) * 60 / 1000\n        };\n        const next_value = tick_spring(ctx, last_value, value, target_value);\n        last_time = now;\n        last_value = value;\n        store.set(value = next_value);\n        if (ctx.settled) {\n          task = null;\n        }\n        return !ctx.settled;\n      });\n    }\n    return new Promise(fulfil => {\n      task.promise.then(() => {\n        if (token === current_token) fulfil();\n      });\n    });\n  }\n  /** @type {import('./public.js').Spring<T>} */\n  const spring = {\n    set,\n    update: (fn, opts) => set(fn(target_value, value), opts),\n    subscribe: store.subscribe,\n    stiffness,\n    damping,\n    precision\n  };\n  return spring;\n}\n// EXTERNAL MODULE: ./node_modules/svelte/src/runtime/easing/index.js\nvar easing = __webpack_require__(450);\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/motion/tweened.js\n\n\n\n\n\n/** @returns {(t: any) => any} */\nfunction get_interpolator(a, b) {\n  if (a === b || a !== a) return () => a;\n  const type = typeof a;\n  if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {\n    throw new Error('Cannot interpolate values of different type');\n  }\n  if (Array.isArray(a)) {\n    const arr = b.map((bi, i) => {\n      return get_interpolator(a[i], bi);\n    });\n    return t => arr.map(fn => fn(t));\n  }\n  if (type === 'object') {\n    if (!a || !b) throw new Error('Object cannot be null');\n    if (is_date(a) && is_date(b)) {\n      a = a.getTime();\n      b = b.getTime();\n      const delta = b - a;\n      return t => new Date(a + t * delta);\n    }\n    const keys = Object.keys(b);\n    const interpolators = {};\n    keys.forEach(key => {\n      interpolators[key] = get_interpolator(a[key], b[key]);\n    });\n    return t => {\n      const result = {};\n      keys.forEach(key => {\n        result[key] = interpolators[key](t);\n      });\n      return result;\n    };\n  }\n  if (type === 'number') {\n    const delta = b - a;\n    return t => a + t * delta;\n  }\n  throw new Error(`Cannot interpolate ${type} values`);\n}\n\n/**\n * A tweened store in Svelte is a special type of store that provides smooth transitions between state values over time.\n *\n * https://svelte.dev/docs/svelte-motion#tweened\n * @template T\n * @param {T} [value]\n * @param {import('./private.js').TweenedOptions<T>} [defaults]\n * @returns {import('./public.js').Tweened<T>}\n */\nfunction tweened(value, defaults = {}) {\n  const store = writable(value);\n  /** @type {import('../internal/private.js').Task} */\n  let task;\n  let target_value = value;\n  /**\n   * @param {T} new_value\n   * @param {import('./private.js').TweenedOptions<T>} [opts]\n   */\n  function set(new_value, opts) {\n    if (value == null) {\n      store.set(value = new_value);\n      return Promise.resolve();\n    }\n    target_value = new_value;\n    let previous_task = task;\n    let started = false;\n    let {\n      delay = 0,\n      duration = 400,\n      easing = linear,\n      interpolate = get_interpolator\n    } = assign(assign({}, defaults), opts);\n    if (duration === 0) {\n      if (previous_task) {\n        previous_task.abort();\n        previous_task = null;\n      }\n      store.set(value = target_value);\n      return Promise.resolve();\n    }\n    const start = now() + delay;\n    let fn;\n    task = loop(now => {\n      if (now < start) return true;\n      if (!started) {\n        fn = interpolate(value, new_value);\n        if (typeof duration === 'function') duration = duration(value, new_value);\n        started = true;\n      }\n      if (previous_task) {\n        previous_task.abort();\n        previous_task = null;\n      }\n      const elapsed = now - start;\n      if (elapsed > ( /** @type {number} */duration)) {\n        store.set(value = new_value);\n        return false;\n      }\n      // @ts-ignore\n      store.set(value = fn(easing(elapsed / duration)));\n      return true;\n    });\n    return task.promise;\n  }\n  return {\n    set,\n    update: (fn, opts) => set(fn(target_value, value), opts),\n    subscribe: store.subscribe\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/svelte/src/runtime/motion/index.js\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFOEMsS0FBSyxDQUFDOUM7RUFDbEIsQ0FBQztBQUNGLEM7O0FDbkg0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvc3RvcmUvaW5kZXguanM/ZmIyOCIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL21vdGlvbi91dGlscy5qcz9jNDdjIiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvbW90aW9uL3NwcmluZy5qcz80NzU2Iiwid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvbW90aW9uL3R3ZWVuZWQuanM/YzAxOCIsIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL21vdGlvbi9pbmRleC5qcz9kNzQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdHJ1bl9hbGwsXG5cdHN1YnNjcmliZSxcblx0bm9vcCxcblx0c2FmZV9ub3RfZXF1YWwsXG5cdGlzX2Z1bmN0aW9uLFxuXHRnZXRfc3RvcmVfdmFsdWVcbn0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXguanMnO1xuXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBSZWFkYWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI3JlYWRhYmxlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlN0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGUodmFsdWUsIHN0YXJ0KSB7XG5cdHJldHVybiB7XG5cdFx0c3Vic2NyaWJlOiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQpLnN1YnNjcmliZVxuXHR9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBXcml0YWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgYm90aCB1cGRhdGluZyBhbmQgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI3dyaXRhYmxlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlN0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLldyaXRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGFibGUodmFsdWUsIHN0YXJ0ID0gbm9vcCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5VbnN1YnNjcmliZXJ9ICovXG5cdGxldCBzdG9wO1xuXHQvKiogQHR5cGUge1NldDxpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPj59ICovXG5cdGNvbnN0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuXHQvKiogQHBhcmFtIHtUfSBuZXdfdmFsdWVcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBzZXQobmV3X3ZhbHVlKSB7XG5cdFx0aWYgKHNhZmVfbm90X2VxdWFsKHZhbHVlLCBuZXdfdmFsdWUpKSB7XG5cdFx0XHR2YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRcdGlmIChzdG9wKSB7XG5cdFx0XHRcdC8vIHN0b3JlIGlzIHJlYWR5XG5cdFx0XHRcdGNvbnN0IHJ1bl9xdWV1ZSA9ICFzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG5cdFx0XHRcdFx0c3Vic2NyaWJlclsxXSgpO1xuXHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWUucHVzaChzdWJzY3JpYmVyLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJ1bl9xdWV1ZSkge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZVtpXVswXShzdWJzY3JpYmVyX3F1ZXVlW2kgKyAxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWUubGVuZ3RoID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5VcGRhdGVyPFQ+fSBmblxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuXHRcdHNldChmbih2YWx1ZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlN1YnNjcmliZXI8VD59IHJ1blxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuSW52YWxpZGF0b3I8VD59IFtpbnZhbGlkYXRlXVxuXHQgKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlVuc3Vic2NyaWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShydW4sIGludmFsaWRhdGUgPSBub29wKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPn0gKi9cblx0XHRjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07XG5cdFx0c3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpO1xuXHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG5cdFx0XHRzdG9wID0gc3RhcnQoc2V0LCB1cGRhdGUpIHx8IG5vb3A7XG5cdFx0fVxuXHRcdHJ1bih2YWx1ZSk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcblx0XHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAwICYmIHN0b3ApIHtcblx0XHRcdFx0c3RvcCgpO1xuXHRcdFx0XHRzdG9wID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdHJldHVybiB7IHNldCwgdXBkYXRlLCBzdWJzY3JpYmUgfTtcbn1cblxuLyoqXG4gKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxuICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNkZXJpdmVkXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N9IHN0b3JlcyAtIGlucHV0IHN0b3Jlc1xuICogQHBhcmFtIHsodmFsdWVzOiBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc1ZhbHVlczxTPiwgc2V0OiAodmFsdWU6IFQpID0+IHZvaWQsIHVwZGF0ZTogKGZuOiBpbXBvcnQoJy4vcHVibGljLmpzJykuVXBkYXRlcjxUPikgPT4gdm9pZCkgPT4gaW1wb3J0KCcuL3B1YmxpYy5qcycpLlVuc3Vic2NyaWJlciB8IHZvaWR9IGZuIC0gZnVuY3Rpb24gY2FsbGJhY2sgdGhhdCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdIC0gaW5pdGlhbCB2YWx1ZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2Rlcml2ZWRcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzIC0gaW5wdXQgc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IGltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzVmFsdWVzPFM+KSA9PiBUfSBmbiAtIGZ1bmN0aW9uIGNhbGxiYWNrIHRoYXQgYWdncmVnYXRlcyB0aGUgdmFsdWVzXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXSAtIGluaXRpYWwgdmFsdWVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWQoc3RvcmVzLCBmbiwgaW5pdGlhbF92YWx1ZSkge1xuXHRjb25zdCBzaW5nbGUgPSAhQXJyYXkuaXNBcnJheShzdG9yZXMpO1xuXHQvKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxhbnk+Pn0gKi9cblx0Y29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlID8gW3N0b3Jlc10gOiBzdG9yZXM7XG5cdGlmICghc3RvcmVzX2FycmF5LmV2ZXJ5KEJvb2xlYW4pKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdkZXJpdmVkKCkgZXhwZWN0cyBzdG9yZXMgYXMgaW5wdXQsIGdvdCBhIGZhbHN5IHZhbHVlJyk7XG5cdH1cblx0Y29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG5cdHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCAoc2V0LCB1cGRhdGUpID0+IHtcblx0XHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXHRcdGxldCBwZW5kaW5nID0gMDtcblx0XHRsZXQgY2xlYW51cCA9IG5vb3A7XG5cdFx0Y29uc3Qgc3luYyA9ICgpID0+IHtcblx0XHRcdGlmIChwZW5kaW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0LCB1cGRhdGUpO1xuXHRcdFx0aWYgKGF1dG8pIHtcblx0XHRcdFx0c2V0KHJlc3VsdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbGVhbnVwID0gaXNfZnVuY3Rpb24ocmVzdWx0KSA/IHJlc3VsdCA6IG5vb3A7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcCgoc3RvcmUsIGkpID0+XG5cdFx0XHRzdWJzY3JpYmUoXG5cdFx0XHRcdHN0b3JlLFxuXHRcdFx0XHQodmFsdWUpID0+IHtcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRwZW5kaW5nICY9IH4oMSA8PCBpKTtcblx0XHRcdFx0XHRpZiAoc3RhcnRlZCkge1xuXHRcdFx0XHRcdFx0c3luYygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRcdHBlbmRpbmcgfD0gMSA8PCBpO1xuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0KTtcblx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRzeW5jKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Ly8gV2UgbmVlZCB0byBzZXQgdGhpcyB0byBmYWxzZSBiZWNhdXNlIGNhbGxiYWNrcyBjYW4gc3RpbGwgaGFwcGVuIGRlc3BpdGUgaGF2aW5nIHVuc3Vic2NyaWJlZDpcblx0XHRcdC8vIENhbGxiYWNrcyBtaWdodCBhbHJlYWR5IGJlIHBsYWNlZCBpbiB0aGUgcXVldWUgd2hpY2ggZG9lc24ndCBrbm93IGl0IHNob3VsZCBubyBsb25nZXJcblx0XHRcdC8vIGludm9rZSB0aGlzIGRlcml2ZWQgc3RvcmUuXG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzdG9yZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUgZGVyaXZlZCBmcm9tIHRoZSBvbGQgb25lIHRoYXQgaXMgcmVhZGFibGUuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI3JlYWRvbmx5XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59IHN0b3JlICAtIHN0b3JlIHRvIG1ha2UgcmVhZG9ubHlcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkb25seShzdG9yZSkge1xuXHRyZXR1cm4ge1xuXHRcdHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLmJpbmQoc3RvcmUpXG5cdH07XG59XG5cbmV4cG9ydCB7IGdldF9zdG9yZV92YWx1ZSBhcyBnZXQgfTtcbiIsIi8qKlxuICogQHBhcmFtIHthbnl9IG9ialxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19kYXRlKG9iaikge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnLi4vc3RvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgbG9vcCwgbm93IH0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXguanMnO1xuaW1wb3J0IHsgaXNfZGF0ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuVGlja0NvbnRleHQ8VD59IGN0eFxuICogQHBhcmFtIHtUfSBsYXN0X3ZhbHVlXG4gKiBAcGFyYW0ge1R9IGN1cnJlbnRfdmFsdWVcbiAqIEBwYXJhbSB7VH0gdGFyZ2V0X3ZhbHVlXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gdGlja19zcHJpbmcoY3R4LCBsYXN0X3ZhbHVlLCBjdXJyZW50X3ZhbHVlLCB0YXJnZXRfdmFsdWUpIHtcblx0aWYgKHR5cGVvZiBjdXJyZW50X3ZhbHVlID09PSAnbnVtYmVyJyB8fCBpc19kYXRlKGN1cnJlbnRfdmFsdWUpKSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGNvbnN0IGRlbHRhID0gdGFyZ2V0X3ZhbHVlIC0gY3VycmVudF92YWx1ZTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0Y29uc3QgdmVsb2NpdHkgPSAoY3VycmVudF92YWx1ZSAtIGxhc3RfdmFsdWUpIC8gKGN0eC5kdCB8fCAxIC8gNjApOyAvLyBndWFyZCBkaXYgYnkgMFxuXHRcdGNvbnN0IHNwcmluZyA9IGN0eC5vcHRzLnN0aWZmbmVzcyAqIGRlbHRhO1xuXHRcdGNvbnN0IGRhbXBlciA9IGN0eC5vcHRzLmRhbXBpbmcgKiB2ZWxvY2l0eTtcblx0XHRjb25zdCBhY2NlbGVyYXRpb24gPSAoc3ByaW5nIC0gZGFtcGVyKSAqIGN0eC5pbnZfbWFzcztcblx0XHRjb25zdCBkID0gKHZlbG9jaXR5ICsgYWNjZWxlcmF0aW9uKSAqIGN0eC5kdDtcblx0XHRpZiAoTWF0aC5hYnMoZCkgPCBjdHgub3B0cy5wcmVjaXNpb24gJiYgTWF0aC5hYnMoZGVsdGEpIDwgY3R4Lm9wdHMucHJlY2lzaW9uKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0X3ZhbHVlOyAvLyBzZXR0bGVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5zZXR0bGVkID0gZmFsc2U7IC8vIHNpZ25hbCBsb29wIHRvIGtlZXAgdGlja2luZ1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0cmV0dXJuIGlzX2RhdGUoY3VycmVudF92YWx1ZSkgPyBuZXcgRGF0ZShjdXJyZW50X3ZhbHVlLmdldFRpbWUoKSArIGQpIDogY3VycmVudF92YWx1ZSArIGQ7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudF92YWx1ZSkpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGN1cnJlbnRfdmFsdWUubWFwKChfLCBpKSA9PlxuXHRcdFx0dGlja19zcHJpbmcoY3R4LCBsYXN0X3ZhbHVlW2ldLCBjdXJyZW50X3ZhbHVlW2ldLCB0YXJnZXRfdmFsdWVbaV0pXG5cdFx0KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgY3VycmVudF92YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRjb25zdCBuZXh0X3ZhbHVlID0ge307XG5cdFx0Zm9yIChjb25zdCBrIGluIGN1cnJlbnRfdmFsdWUpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdG5leHRfdmFsdWVba10gPSB0aWNrX3NwcmluZyhjdHgsIGxhc3RfdmFsdWVba10sIGN1cnJlbnRfdmFsdWVba10sIHRhcmdldF92YWx1ZVtrXSk7XG5cdFx0fVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gbmV4dF92YWx1ZTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzcHJpbmcgJHt0eXBlb2YgY3VycmVudF92YWx1ZX0gdmFsdWVzYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgc3ByaW5nIGZ1bmN0aW9uIGluIFN2ZWx0ZSBjcmVhdGVzIGEgc3RvcmUgd2hvc2UgdmFsdWUgaXMgYW5pbWF0ZWQsIHdpdGggYSBtb3Rpb24gdGhhdCBzaW11bGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGEgc3ByaW5nLiBUaGlzIG1lYW5zIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMsIGluc3RlYWQgb2YgdHJhbnNpdGlvbmluZyBhdCBhIHN0ZWFkeSByYXRlLCBpdCBcImJvdW5jZXNcIiBsaWtlIGEgc3ByaW5nIHdvdWxkLCBkZXBlbmRpbmcgb24gdGhlIHBoeXNpY3MgcGFyYW1ldGVycyBwcm92aWRlZC4gVGhpcyBhZGRzIGEgbGV2ZWwgb2YgcmVhbGlzbSB0byB0aGUgdHJhbnNpdGlvbnMgYW5kIGNhbiBlbmhhbmNlIHRoZSB1c2VyIGV4cGVyaWVuY2UuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLW1vdGlvbiNzcHJpbmdcbiAqIEB0ZW1wbGF0ZSBbVD1hbnldXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TcHJpbmdPcHRzfSBbb3B0c11cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3ByaW5nPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ByaW5nKHZhbHVlLCBvcHRzID0ge30pIHtcblx0Y29uc3Qgc3RvcmUgPSB3cml0YWJsZSh2YWx1ZSk7XG5cdGNvbnN0IHsgc3RpZmZuZXNzID0gMC4xNSwgZGFtcGluZyA9IDAuOCwgcHJlY2lzaW9uID0gMC4wMSB9ID0gb3B0cztcblx0LyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cdGxldCBsYXN0X3RpbWU7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9pbnRlcm5hbC9wcml2YXRlLmpzJykuVGFza30gKi9cblx0bGV0IHRhc2s7XG5cdC8qKiBAdHlwZSB7b2JqZWN0fSAqL1xuXHRsZXQgY3VycmVudF90b2tlbjtcblx0LyoqIEB0eXBlIHtUfSAqL1xuXHRsZXQgbGFzdF92YWx1ZSA9IHZhbHVlO1xuXHQvKiogQHR5cGUge1R9ICovXG5cdGxldCB0YXJnZXRfdmFsdWUgPSB2YWx1ZTtcblx0bGV0IGludl9tYXNzID0gMTtcblx0bGV0IGludl9tYXNzX3JlY292ZXJ5X3JhdGUgPSAwO1xuXHRsZXQgY2FuY2VsX3Rhc2sgPSBmYWxzZTtcblx0LyoqXG5cdCAqIEBwYXJhbSB7VH0gbmV3X3ZhbHVlXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TcHJpbmdVcGRhdGVPcHRzfSBvcHRzXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG5ld192YWx1ZSwgb3B0cyA9IHt9KSB7XG5cdFx0dGFyZ2V0X3ZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdGNvbnN0IHRva2VuID0gKGN1cnJlbnRfdG9rZW4gPSB7fSk7XG5cdFx0aWYgKHZhbHVlID09IG51bGwgfHwgb3B0cy5oYXJkIHx8IChzcHJpbmcuc3RpZmZuZXNzID49IDEgJiYgc3ByaW5nLmRhbXBpbmcgPj0gMSkpIHtcblx0XHRcdGNhbmNlbF90YXNrID0gdHJ1ZTsgLy8gY2FuY2VsIGFueSBydW5uaW5nIGFuaW1hdGlvblxuXHRcdFx0bGFzdF90aW1lID0gbm93KCk7XG5cdFx0XHRsYXN0X3ZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0c3RvcmUuc2V0KCh2YWx1ZSA9IHRhcmdldF92YWx1ZSkpO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdH0gZWxzZSBpZiAob3B0cy5zb2Z0KSB7XG5cdFx0XHRjb25zdCByYXRlID0gb3B0cy5zb2Z0ID09PSB0cnVlID8gMC41IDogK29wdHMuc29mdDtcblx0XHRcdGludl9tYXNzX3JlY292ZXJ5X3JhdGUgPSAxIC8gKHJhdGUgKiA2MCk7XG5cdFx0XHRpbnZfbWFzcyA9IDA7IC8vIGluZmluaXRlIG1hc3MsIHVuYWZmZWN0ZWQgYnkgc3ByaW5nIGZvcmNlc1xuXHRcdH1cblx0XHRpZiAoIXRhc2spIHtcblx0XHRcdGxhc3RfdGltZSA9IG5vdygpO1xuXHRcdFx0Y2FuY2VsX3Rhc2sgPSBmYWxzZTtcblx0XHRcdHRhc2sgPSBsb29wKChub3cpID0+IHtcblx0XHRcdFx0aWYgKGNhbmNlbF90YXNrKSB7XG5cdFx0XHRcdFx0Y2FuY2VsX3Rhc2sgPSBmYWxzZTtcblx0XHRcdFx0XHR0YXNrID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW52X21hc3MgPSBNYXRoLm1pbihpbnZfbWFzcyArIGludl9tYXNzX3JlY292ZXJ5X3JhdGUsIDEpO1xuXHRcdFx0XHRjb25zdCBjdHggPSB7XG5cdFx0XHRcdFx0aW52X21hc3MsXG5cdFx0XHRcdFx0b3B0czogc3ByaW5nLFxuXHRcdFx0XHRcdHNldHRsZWQ6IHRydWUsXG5cdFx0XHRcdFx0ZHQ6ICgobm93IC0gbGFzdF90aW1lKSAqIDYwKSAvIDEwMDBcblx0XHRcdFx0fTtcblx0XHRcdFx0Y29uc3QgbmV4dF92YWx1ZSA9IHRpY2tfc3ByaW5nKGN0eCwgbGFzdF92YWx1ZSwgdmFsdWUsIHRhcmdldF92YWx1ZSk7XG5cdFx0XHRcdGxhc3RfdGltZSA9IG5vdztcblx0XHRcdFx0bGFzdF92YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRzdG9yZS5zZXQoKHZhbHVlID0gbmV4dF92YWx1ZSkpO1xuXHRcdFx0XHRpZiAoY3R4LnNldHRsZWQpIHtcblx0XHRcdFx0XHR0YXNrID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gIWN0eC5zZXR0bGVkO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsKSA9PiB7XG5cdFx0XHR0YXNrLnByb21pc2UudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmICh0b2tlbiA9PT0gY3VycmVudF90b2tlbikgZnVsZmlsKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5TcHJpbmc8VD59ICovXG5cdGNvbnN0IHNwcmluZyA9IHtcblx0XHRzZXQsXG5cdFx0dXBkYXRlOiAoZm4sIG9wdHMpID0+IHNldChmbih0YXJnZXRfdmFsdWUsIHZhbHVlKSwgb3B0cyksXG5cdFx0c3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUsXG5cdFx0c3RpZmZuZXNzLFxuXHRcdGRhbXBpbmcsXG5cdFx0cHJlY2lzaW9uXG5cdH07XG5cdHJldHVybiBzcHJpbmc7XG59XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJy4uL3N0b3JlL2luZGV4LmpzJztcbmltcG9ydCB7IGFzc2lnbiwgbG9vcCwgbm93IH0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXguanMnO1xuaW1wb3J0IHsgbGluZWFyIH0gZnJvbSAnLi4vZWFzaW5nL2luZGV4LmpzJztcbmltcG9ydCB7IGlzX2RhdGUgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqIEByZXR1cm5zIHsodDogYW55KSA9PiBhbnl9ICovXG5mdW5jdGlvbiBnZXRfaW50ZXJwb2xhdG9yKGEsIGIpIHtcblx0aWYgKGEgPT09IGIgfHwgYSAhPT0gYSkgcmV0dXJuICgpID0+IGE7XG5cdGNvbnN0IHR5cGUgPSB0eXBlb2YgYTtcblx0aWYgKHR5cGUgIT09IHR5cGVvZiBiIHx8IEFycmF5LmlzQXJyYXkoYSkgIT09IEFycmF5LmlzQXJyYXkoYikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnRlcnBvbGF0ZSB2YWx1ZXMgb2YgZGlmZmVyZW50IHR5cGUnKTtcblx0fVxuXHRpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuXHRcdGNvbnN0IGFyciA9IGIubWFwKChiaSwgaSkgPT4ge1xuXHRcdFx0cmV0dXJuIGdldF9pbnRlcnBvbGF0b3IoYVtpXSwgYmkpO1xuXHRcdH0pO1xuXHRcdHJldHVybiAodCkgPT4gYXJyLm1hcCgoZm4pID0+IGZuKHQpKTtcblx0fVxuXHRpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRpZiAoIWEgfHwgIWIpIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGNhbm5vdCBiZSBudWxsJyk7XG5cdFx0aWYgKGlzX2RhdGUoYSkgJiYgaXNfZGF0ZShiKSkge1xuXHRcdFx0YSA9IGEuZ2V0VGltZSgpO1xuXHRcdFx0YiA9IGIuZ2V0VGltZSgpO1xuXHRcdFx0Y29uc3QgZGVsdGEgPSBiIC0gYTtcblx0XHRcdHJldHVybiAodCkgPT4gbmV3IERhdGUoYSArIHQgKiBkZWx0YSk7XG5cdFx0fVxuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhiKTtcblx0XHRjb25zdCBpbnRlcnBvbGF0b3JzID0ge307XG5cdFx0a2V5cy5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRcdGludGVycG9sYXRvcnNba2V5XSA9IGdldF9pbnRlcnBvbGF0b3IoYVtrZXldLCBiW2tleV0pO1xuXHRcdH0pO1xuXHRcdHJldHVybiAodCkgPT4ge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0ge307XG5cdFx0XHRrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuXHRcdFx0XHRyZXN1bHRba2V5XSA9IGludGVycG9sYXRvcnNba2V5XSh0KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9XG5cdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdGNvbnN0IGRlbHRhID0gYiAtIGE7XG5cdFx0cmV0dXJuICh0KSA9PiBhICsgdCAqIGRlbHRhO1xuXHR9XG5cdHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGludGVycG9sYXRlICR7dHlwZX0gdmFsdWVzYCk7XG59XG5cbi8qKlxuICogQSB0d2VlbmVkIHN0b3JlIGluIFN2ZWx0ZSBpcyBhIHNwZWNpYWwgdHlwZSBvZiBzdG9yZSB0aGF0IHByb3ZpZGVzIHNtb290aCB0cmFuc2l0aW9ucyBiZXR3ZWVuIHN0YXRlIHZhbHVlcyBvdmVyIHRpbWUuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLW1vdGlvbiN0d2VlbmVkXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuVHdlZW5lZE9wdGlvbnM8VD59IFtkZWZhdWx0c11cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuVHdlZW5lZDxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR3ZWVuZWQodmFsdWUsIGRlZmF1bHRzID0ge30pIHtcblx0Y29uc3Qgc3RvcmUgPSB3cml0YWJsZSh2YWx1ZSk7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9pbnRlcm5hbC9wcml2YXRlLmpzJykuVGFza30gKi9cblx0bGV0IHRhc2s7XG5cdGxldCB0YXJnZXRfdmFsdWUgPSB2YWx1ZTtcblx0LyoqXG5cdCAqIEBwYXJhbSB7VH0gbmV3X3ZhbHVlXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Ud2VlbmVkT3B0aW9uczxUPn0gW29wdHNdXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXQobmV3X3ZhbHVlLCBvcHRzKSB7XG5cdFx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRcdHN0b3JlLnNldCgodmFsdWUgPSBuZXdfdmFsdWUpKTtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHR9XG5cdFx0dGFyZ2V0X3ZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdGxldCBwcmV2aW91c190YXNrID0gdGFzaztcblx0XHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRcdGxldCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IDQwMCxcblx0XHRcdGVhc2luZyA9IGxpbmVhcixcblx0XHRcdGludGVycG9sYXRlID0gZ2V0X2ludGVycG9sYXRvclxuXHRcdH0gPSBhc3NpZ24oYXNzaWduKHt9LCBkZWZhdWx0cyksIG9wdHMpO1xuXHRcdGlmIChkdXJhdGlvbiA9PT0gMCkge1xuXHRcdFx0aWYgKHByZXZpb3VzX3Rhc2spIHtcblx0XHRcdFx0cHJldmlvdXNfdGFzay5hYm9ydCgpO1xuXHRcdFx0XHRwcmV2aW91c190YXNrID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHN0b3JlLnNldCgodmFsdWUgPSB0YXJnZXRfdmFsdWUpKTtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHR9XG5cdFx0Y29uc3Qgc3RhcnQgPSBub3coKSArIGRlbGF5O1xuXHRcdGxldCBmbjtcblx0XHR0YXNrID0gbG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAobm93IDwgc3RhcnQpIHJldHVybiB0cnVlO1xuXHRcdFx0aWYgKCFzdGFydGVkKSB7XG5cdFx0XHRcdGZuID0gaW50ZXJwb2xhdGUodmFsdWUsIG5ld192YWx1ZSk7XG5cdFx0XHRcdGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIGR1cmF0aW9uID0gZHVyYXRpb24odmFsdWUsIG5ld192YWx1ZSk7XG5cdFx0XHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZpb3VzX3Rhc2spIHtcblx0XHRcdFx0cHJldmlvdXNfdGFzay5hYm9ydCgpO1xuXHRcdFx0XHRwcmV2aW91c190YXNrID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGNvbnN0IGVsYXBzZWQgPSBub3cgLSBzdGFydDtcblx0XHRcdGlmIChlbGFwc2VkID4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkdXJhdGlvbikpIHtcblx0XHRcdFx0c3RvcmUuc2V0KCh2YWx1ZSA9IG5ld192YWx1ZSkpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRzdG9yZS5zZXQoKHZhbHVlID0gZm4oZWFzaW5nKGVsYXBzZWQgLyBkdXJhdGlvbikpKSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdGFzay5wcm9taXNlO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0c2V0LFxuXHRcdHVwZGF0ZTogKGZuLCBvcHRzKSA9PiBzZXQoZm4odGFyZ2V0X3ZhbHVlLCB2YWx1ZSksIG9wdHMpLFxuXHRcdHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlXG5cdH07XG59XG4iLCJleHBvcnQgKiBmcm9tICcuL3NwcmluZy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3R3ZWVuZWQuanMnO1xuIl0sIm5hbWVzIjpbInJ1bl9hbGwiLCJzdWJzY3JpYmUiLCJub29wIiwic2FmZV9ub3RfZXF1YWwiLCJpc19mdW5jdGlvbiIsImdldF9zdG9yZV92YWx1ZSIsInN1YnNjcmliZXJfcXVldWUiLCJyZWFkYWJsZSIsInZhbHVlIiwic3RhcnQiLCJ3cml0YWJsZSIsInN0b3AiLCJzdWJzY3JpYmVycyIsIlNldCIsInNldCIsIm5ld192YWx1ZSIsInJ1bl9xdWV1ZSIsImxlbmd0aCIsInN1YnNjcmliZXIiLCJwdXNoIiwiaSIsInVwZGF0ZSIsImZuIiwicnVuIiwiaW52YWxpZGF0ZSIsImFkZCIsInNpemUiLCJkZWxldGUiLCJkZXJpdmVkIiwic3RvcmVzIiwiaW5pdGlhbF92YWx1ZSIsInNpbmdsZSIsIkFycmF5IiwiaXNBcnJheSIsInN0b3Jlc19hcnJheSIsImV2ZXJ5IiwiQm9vbGVhbiIsIkVycm9yIiwiYXV0byIsInN0YXJ0ZWQiLCJ2YWx1ZXMiLCJwZW5kaW5nIiwiY2xlYW51cCIsInN5bmMiLCJyZXN1bHQiLCJ1bnN1YnNjcmliZXJzIiwibWFwIiwic3RvcmUiLCJyZWFkb25seSIsImJpbmQiLCJnZXQiLCJpc19kYXRlIiwib2JqIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwibG9vcCIsIm5vdyIsInRpY2tfc3ByaW5nIiwiY3R4IiwibGFzdF92YWx1ZSIsImN1cnJlbnRfdmFsdWUiLCJ0YXJnZXRfdmFsdWUiLCJkZWx0YSIsInZlbG9jaXR5IiwiZHQiLCJzcHJpbmciLCJvcHRzIiwic3RpZmZuZXNzIiwiZGFtcGVyIiwiZGFtcGluZyIsImFjY2VsZXJhdGlvbiIsImludl9tYXNzIiwiZCIsIk1hdGgiLCJhYnMiLCJwcmVjaXNpb24iLCJzZXR0bGVkIiwiRGF0ZSIsImdldFRpbWUiLCJfIiwibmV4dF92YWx1ZSIsImsiLCJsYXN0X3RpbWUiLCJ0YXNrIiwiY3VycmVudF90b2tlbiIsImludl9tYXNzX3JlY292ZXJ5X3JhdGUiLCJjYW5jZWxfdGFzayIsInRva2VuIiwiaGFyZCIsIlByb21pc2UiLCJyZXNvbHZlIiwic29mdCIsInJhdGUiLCJtaW4iLCJmdWxmaWwiLCJwcm9taXNlIiwidGhlbiIsImFzc2lnbiIsImxpbmVhciIsImdldF9pbnRlcnBvbGF0b3IiLCJhIiwiYiIsInR5cGUiLCJhcnIiLCJiaSIsInQiLCJrZXlzIiwiaW50ZXJwb2xhdG9ycyIsImZvckVhY2giLCJrZXkiLCJ0d2VlbmVkIiwiZGVmYXVsdHMiLCJwcmV2aW91c190YXNrIiwiZGVsYXkiLCJkdXJhdGlvbiIsImVhc2luZyIsImludGVycG9sYXRlIiwiYWJvcnQiLCJlbGFwc2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///100\n")},56:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rv: () => (/* binding */ fade),\n/* harmony export */   _J: () => (/* binding */ fly)\n/* harmony export */ });\n/* unused harmony exports blur, slide, scale, draw, crossfade */\n/* harmony import */ var _easing_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(450);\n/* harmony import */ var _internal_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);\n\n\n\n/**\n * Animates a `blur` filter alongside an element's opacity.\n *\n * https://svelte.dev/docs/svelte-transition#blur\n * @param {Element} node\n * @param {import('./public').BlurParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction blur(node, {\n  delay = 0,\n  duration = 400,\n  easing = cubicInOut,\n  amount = 5,\n  opacity = 0\n} = {}) {\n  const style = getComputedStyle(node);\n  const target_opacity = +style.opacity;\n  const f = style.filter === 'none' ? '' : style.filter;\n  const od = target_opacity * (1 - opacity);\n  const [value, unit] = split_css_unit(amount);\n  return {\n    delay,\n    duration,\n    easing,\n    css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * value}${unit});`\n  };\n}\n\n/**\n * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.\n *\n * https://svelte.dev/docs/svelte-transition#fade\n * @param {Element} node\n * @param {import('./public').FadeParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction fade(node, {\n  delay = 0,\n  duration = 400,\n  easing = _easing_index_js__WEBPACK_IMPORTED_MODULE_0__/* .linear */ .sn\n} = {}) {\n  const o = +getComputedStyle(node).opacity;\n  return {\n    delay,\n    duration,\n    easing,\n    css: t => `opacity: ${t * o}`\n  };\n}\n\n/**\n * Animates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values.\n *\n * https://svelte.dev/docs/svelte-transition#fly\n * @param {Element} node\n * @param {import('./public').FlyParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction fly(node, {\n  delay = 0,\n  duration = 400,\n  easing = _easing_index_js__WEBPACK_IMPORTED_MODULE_0__/* .cubicOut */ .Jx,\n  x = 0,\n  y = 0,\n  opacity = 0\n} = {}) {\n  const style = getComputedStyle(node);\n  const target_opacity = +style.opacity;\n  const transform = style.transform === 'none' ? '' : style.transform;\n  const od = target_opacity * (1 - opacity);\n  const [xValue, xUnit] = (0,_internal_index_js__WEBPACK_IMPORTED_MODULE_1__/* .split_css_unit */ .AE)(x);\n  const [yValue, yUnit] = (0,_internal_index_js__WEBPACK_IMPORTED_MODULE_1__/* .split_css_unit */ .AE)(y);\n  return {\n    delay,\n    duration,\n    easing,\n    css: (t, u) => `\n\t\t\ttransform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});\n\t\t\topacity: ${target_opacity - od * u}`\n  };\n}\n\n/**\n * Slides an element in and out.\n *\n * https://svelte.dev/docs/svelte-transition#slide\n * @param {Element} node\n * @param {import('./public').SlideParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction slide(node, {\n  delay = 0,\n  duration = 400,\n  easing = cubicOut,\n  axis = 'y'\n} = {}) {\n  const style = getComputedStyle(node);\n  const opacity = +style.opacity;\n  const primary_property = axis === 'y' ? 'height' : 'width';\n  const primary_property_value = parseFloat(style[primary_property]);\n  const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];\n  const capitalized_secondary_properties = secondary_properties.map(e => `${e[0].toUpperCase()}${e.slice(1)}`);\n  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);\n  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);\n  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);\n  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);\n  const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);\n  const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);\n  return {\n    delay,\n    duration,\n    easing,\n    css: t => 'overflow: hidden;' + `opacity: ${Math.min(t * 20, 1) * opacity};` + `${primary_property}: ${t * primary_property_value}px;` + `padding-${secondary_properties[0]}: ${t * padding_start_value}px;` + `padding-${secondary_properties[1]}: ${t * padding_end_value}px;` + `margin-${secondary_properties[0]}: ${t * margin_start_value}px;` + `margin-${secondary_properties[1]}: ${t * margin_end_value}px;` + `border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` + `border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`\n  };\n}\n\n/**\n * Animates the opacity and scale of an element. `in` transitions animate from an element's current (default) values to the provided values, passed as parameters. `out` transitions animate from the provided values to an element's default values.\n *\n * https://svelte.dev/docs/svelte-transition#scale\n * @param {Element} node\n * @param {import('./public').ScaleParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction scale(node, {\n  delay = 0,\n  duration = 400,\n  easing = cubicOut,\n  start = 0,\n  opacity = 0\n} = {}) {\n  const style = getComputedStyle(node);\n  const target_opacity = +style.opacity;\n  const transform = style.transform === 'none' ? '' : style.transform;\n  const sd = 1 - start;\n  const od = target_opacity * (1 - opacity);\n  return {\n    delay,\n    duration,\n    easing,\n    css: (_t, u) => `\n\t\t\ttransform: ${transform} scale(${1 - sd * u});\n\t\t\topacity: ${target_opacity - od * u}\n\t\t`\n  };\n}\n\n/**\n * Animates the stroke of an SVG element, like a snake in a tube. `in` transitions begin with the path invisible and draw the path to the screen over time. `out` transitions start in a visible state and gradually erase the path. `draw` only works with elements that have a `getTotalLength` method, like `<path>` and `<polyline>`.\n *\n * https://svelte.dev/docs/svelte-transition#draw\n * @param {SVGElement & { getTotalLength(): number }} node\n * @param {import('./public').DrawParams} [params]\n * @returns {import('./public').TransitionConfig}\n */\nfunction draw(node, {\n  delay = 0,\n  speed,\n  duration,\n  easing = cubicInOut\n} = {}) {\n  let len = node.getTotalLength();\n  const style = getComputedStyle(node);\n  if (style.strokeLinecap !== 'butt') {\n    len += parseInt(style.strokeWidth);\n  }\n  if (duration === undefined) {\n    if (speed === undefined) {\n      duration = 800;\n    } else {\n      duration = len / speed;\n    }\n  } else if (typeof duration === 'function') {\n    duration = duration(len);\n  }\n  return {\n    delay,\n    duration,\n    easing,\n    css: (_, u) => `\n\t\t\tstroke-dasharray: ${len};\n\t\t\tstroke-dashoffset: ${u * len};\n\t\t`\n  };\n}\n\n/**\n * The `crossfade` function creates a pair of [transitions](https://svelte.dev/docs#template-syntax-element-directives-transition-fn) called `send` and `receive`. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the `fallback` transition is used.\n *\n * https://svelte.dev/docs/svelte-transition#crossfade\n * @param {import('./public').CrossfadeParams & {\n * \tfallback?: (node: Element, params: import('./public').CrossfadeParams, intro: boolean) => import('./public').TransitionConfig;\n * }} params\n * @returns {[(node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig, (node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig]}\n */\nfunction crossfade({\n  fallback,\n  ...defaults\n}) {\n  /** @type {Map<any, Element>} */\n  const to_receive = new Map();\n  /** @type {Map<any, Element>} */\n  const to_send = new Map();\n  /**\n   * @param {Element} from_node\n   * @param {Element} node\n   * @param {import('./public').CrossfadeParams} params\n   * @returns {import('./public').TransitionConfig}\n   */\n  function crossfade(from_node, node, params) {\n    const {\n      delay = 0,\n      duration = d => Math.sqrt(d) * 30,\n      easing = cubicOut\n    } = assign(assign({}, defaults), params);\n    const from = from_node.getBoundingClientRect();\n    const to = node.getBoundingClientRect();\n    const dx = from.left - to.left;\n    const dy = from.top - to.top;\n    const dw = from.width / to.width;\n    const dh = from.height / to.height;\n    const d = Math.sqrt(dx * dx + dy * dy);\n    const style = getComputedStyle(node);\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const opacity = +style.opacity;\n    return {\n      delay,\n      duration: is_function(duration) ? duration(d) : duration,\n      easing,\n      css: (t, u) => `\n\t\t\t\topacity: ${t * opacity};\n\t\t\t\ttransform-origin: top left;\n\t\t\t\ttransform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});\n\t\t\t`\n    };\n  }\n\n  /**\n   * @param {Map<any, Element>} items\n   * @param {Map<any, Element>} counterparts\n   * @param {boolean} intro\n   * @returns {(node: any, params: import('./public').CrossfadeParams & { key: any; }) => () => import('./public').TransitionConfig}\n   */\n  function transition(items, counterparts, intro) {\n    return (node, params) => {\n      items.set(params.key, node);\n      return () => {\n        if (counterparts.has(params.key)) {\n          const other_node = counterparts.get(params.key);\n          counterparts.delete(params.key);\n          return crossfade(other_node, node, params);\n        }\n        // if the node is disappearing altogether\n        // (i.e. wasn't claimed by the other list)\n        // then we need to supply an outro\n        items.delete(params.key);\n        return fallback && fallback(node, params, intro);\n      };\n    };\n  }\n  return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7UUFDeEIsT0FBT3pCLFFBQVEsSUFBSUEsUUFBUSxDQUFDNUQsSUFBSSxFQUFFa0UsTUFBTSxFQUFFaUIsS0FBSyxDQUFDO01BQ2pELENBQUM7SUFDRixDQUFDO0VBQ0Y7RUFDQSxPQUFPLENBQUNILFVBQVUsQ0FBQ2hCLE9BQU8sRUFBRUYsVUFBVSxFQUFFLEtBQUssQ0FBQyxFQUFFa0IsVUFBVSxDQUFDbEIsVUFBVSxFQUFFRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDdkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL3RyYW5zaXRpb24vaW5kZXguanM/NzE4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjdWJpY091dCwgY3ViaWNJbk91dCwgbGluZWFyIH0gZnJvbSAnLi4vZWFzaW5nL2luZGV4LmpzJztcbmltcG9ydCB7IGFzc2lnbiwgc3BsaXRfY3NzX3VuaXQsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXguanMnO1xuXG4vKipcbiAqIEFuaW1hdGVzIGEgYGJsdXJgIGZpbHRlciBhbG9uZ3NpZGUgYW4gZWxlbWVudCdzIG9wYWNpdHkuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXRyYW5zaXRpb24jYmx1clxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMnKS5CbHVyUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmx1cihcblx0bm9kZSxcblx0eyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY0luT3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9ID0ge31cbikge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IGYgPSBzdHlsZS5maWx0ZXIgPT09ICdub25lJyA/ICcnIDogc3R5bGUuZmlsdGVyO1xuXHRjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcblx0Y29uc3QgW3ZhbHVlLCB1bml0XSA9IHNwbGl0X2Nzc191bml0KGFtb3VudCk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKF90LCB1KSA9PiBgb3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIG9kICogdX07IGZpbHRlcjogJHtmfSBibHVyKCR7dSAqIHZhbHVlfSR7dW5pdH0pO2Bcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IGZyb20gMCB0byB0aGUgY3VycmVudCBvcGFjaXR5IGZvciBgaW5gIHRyYW5zaXRpb25zIGFuZCBmcm9tIHRoZSBjdXJyZW50IG9wYWNpdHkgdG8gMCBmb3IgYG91dGAgdHJhbnNpdGlvbnMuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXRyYW5zaXRpb24jZmFkZVxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMnKS5GYWRlUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGxpbmVhciB9ID0ge30pIHtcblx0Y29uc3QgbyA9ICtnZXRDb21wdXRlZFN0eWxlKG5vZGUpLm9wYWNpdHk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKHQpID0+IGBvcGFjaXR5OiAke3QgKiBvfWBcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgeCBhbmQgeSBwb3NpdGlvbnMgYW5kIHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQuIGBpbmAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIHRoZSBwcm92aWRlZCB2YWx1ZXMsIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIHRvIHRoZSBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMuIGBvdXRgIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSB0aGUgZWxlbWVudCdzIGRlZmF1bHQgdmFsdWVzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXRyYW5zaXRpb24jZmx5XG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLkZseVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZseShcblx0bm9kZSxcblx0eyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgeCA9IDAsIHkgPSAwLCBvcGFjaXR5ID0gMCB9ID0ge31cbikge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuXHRjb25zdCBbeFZhbHVlLCB4VW5pdF0gPSBzcGxpdF9jc3NfdW5pdCh4KTtcblx0Y29uc3QgW3lWYWx1ZSwgeVVuaXRdID0gc3BsaXRfY3NzX3VuaXQoeSk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKHQsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgkeygxIC0gdCkgKiB4VmFsdWV9JHt4VW5pdH0sICR7KDEgLSB0KSAqIHlWYWx1ZX0ke3lVbml0fSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fWBcblx0fTtcbn1cblxuLyoqXG4gKiBTbGlkZXMgYW4gZWxlbWVudCBpbiBhbmQgb3V0LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS10cmFuc2l0aW9uI3NsaWRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYycpLlNsaWRlUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgYXhpcyA9ICd5JyB9ID0ge30pIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IHByaW1hcnlfcHJvcGVydHkgPSBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cdGNvbnN0IHByaW1hcnlfcHJvcGVydHlfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW3ByaW1hcnlfcHJvcGVydHldKTtcblx0Y29uc3Qgc2Vjb25kYXJ5X3Byb3BlcnRpZXMgPSBheGlzID09PSAneScgPyBbJ3RvcCcsICdib3R0b20nXSA6IFsnbGVmdCcsICdyaWdodCddO1xuXHRjb25zdCBjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllcyA9IHNlY29uZGFyeV9wcm9wZXJ0aWVzLm1hcChcblx0XHQoZSkgPT4gYCR7ZVswXS50b1VwcGVyQ2FzZSgpfSR7ZS5zbGljZSgxKX1gXG5cdCk7XG5cdGNvbnN0IHBhZGRpbmdfc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BwYWRkaW5nJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1gXSk7XG5cdGNvbnN0IHBhZGRpbmdfZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgcGFkZGluZyR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19YF0pO1xuXHRjb25zdCBtYXJnaW5fc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BtYXJnaW4ke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfWBdKTtcblx0Y29uc3QgbWFyZ2luX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYG1hcmdpbiR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19YF0pO1xuXHRjb25zdCBib3JkZXJfd2lkdGhfc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KFxuXHRcdHN0eWxlW2Bib3JkZXIke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfVdpZHRoYF1cblx0KTtcblx0Y29uc3QgYm9yZGVyX3dpZHRoX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoXG5cdFx0c3R5bGVbYGJvcmRlciR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19V2lkdGhgXVxuXHQpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0KSA9PlxuXHRcdFx0J292ZXJmbG93OiBoaWRkZW47JyArXG5cdFx0XHRgb3BhY2l0eTogJHtNYXRoLm1pbih0ICogMjAsIDEpICogb3BhY2l0eX07YCArXG5cdFx0XHRgJHtwcmltYXJ5X3Byb3BlcnR5fTogJHt0ICogcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZX1weDtgICtcblx0XHRcdGBwYWRkaW5nLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19OiAke3QgKiBwYWRkaW5nX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YHBhZGRpbmctJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX06ICR7dCAqIHBhZGRpbmdfZW5kX3ZhbHVlfXB4O2AgK1xuXHRcdFx0YG1hcmdpbi0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfTogJHt0ICogbWFyZ2luX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YG1hcmdpbi0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfTogJHt0ICogbWFyZ2luX2VuZF92YWx1ZX1weDtgICtcblx0XHRcdGBib3JkZXItJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX0td2lkdGg6ICR7dCAqIGJvcmRlcl93aWR0aF9zdGFydF92YWx1ZX1weDtgICtcblx0XHRcdGBib3JkZXItJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX0td2lkdGg6ICR7dCAqIGJvcmRlcl93aWR0aF9lbmRfdmFsdWV9cHg7YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSBvcGFjaXR5IGFuZCBzY2FsZSBvZiBhbiBlbGVtZW50LiBgaW5gIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSBhbiBlbGVtZW50J3MgY3VycmVudCAoZGVmYXVsdCkgdmFsdWVzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMsIHBhc3NlZCBhcyBwYXJhbWV0ZXJzLiBgb3V0YCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIHByb3ZpZGVkIHZhbHVlcyB0byBhbiBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXRyYW5zaXRpb24jc2NhbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljJykuU2NhbGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShcblx0bm9kZSxcblx0eyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgc3RhcnQgPSAwLCBvcGFjaXR5ID0gMCB9ID0ge31cbikge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdGNvbnN0IHNkID0gMSAtIHN0YXJ0O1xuXHRjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoX3QsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHNjYWxlKCR7MSAtIHNkICogdX0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIG9kICogdX1cblx0XHRgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIHN0cm9rZSBvZiBhbiBTVkcgZWxlbWVudCwgbGlrZSBhIHNuYWtlIGluIGEgdHViZS4gYGluYCB0cmFuc2l0aW9ucyBiZWdpbiB3aXRoIHRoZSBwYXRoIGludmlzaWJsZSBhbmQgZHJhdyB0aGUgcGF0aCB0byB0aGUgc2NyZWVuIG92ZXIgdGltZS4gYG91dGAgdHJhbnNpdGlvbnMgc3RhcnQgaW4gYSB2aXNpYmxlIHN0YXRlIGFuZCBncmFkdWFsbHkgZXJhc2UgdGhlIHBhdGguIGBkcmF3YCBvbmx5IHdvcmtzIHdpdGggZWxlbWVudHMgdGhhdCBoYXZlIGEgYGdldFRvdGFsTGVuZ3RoYCBtZXRob2QsIGxpa2UgYDxwYXRoPmAgYW5kIGA8cG9seWxpbmU+YC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtdHJhbnNpdGlvbiNkcmF3XG4gKiBAcGFyYW0ge1NWR0VsZW1lbnQgJiB7IGdldFRvdGFsTGVuZ3RoKCk6IG51bWJlciB9fSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMnKS5EcmF3UGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhdyhub2RlLCB7IGRlbGF5ID0gMCwgc3BlZWQsIGR1cmF0aW9uLCBlYXNpbmcgPSBjdWJpY0luT3V0IH0gPSB7fSkge1xuXHRsZXQgbGVuID0gbm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGlmIChzdHlsZS5zdHJva2VMaW5lY2FwICE9PSAnYnV0dCcpIHtcblx0XHRsZW4gKz0gcGFyc2VJbnQoc3R5bGUuc3Ryb2tlV2lkdGgpO1xuXHR9XG5cdGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGR1cmF0aW9uID0gODAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkdXJhdGlvbiA9IGxlbiAvIHNwZWVkO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRkdXJhdGlvbiA9IGR1cmF0aW9uKGxlbik7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoXywgdSkgPT4gYFxuXHRcdFx0c3Ryb2tlLWRhc2hhcnJheTogJHtsZW59O1xuXHRcdFx0c3Ryb2tlLWRhc2hvZmZzZXQ6ICR7dSAqIGxlbn07XG5cdFx0YFxuXHR9O1xufVxuXG4vKipcbiAqIFRoZSBgY3Jvc3NmYWRlYCBmdW5jdGlvbiBjcmVhdGVzIGEgcGFpciBvZiBbdHJhbnNpdGlvbnNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3RlbXBsYXRlLXN5bnRheC1lbGVtZW50LWRpcmVjdGl2ZXMtdHJhbnNpdGlvbi1mbikgY2FsbGVkIGBzZW5kYCBhbmQgYHJlY2VpdmVgLiBXaGVuIGFuIGVsZW1lbnQgaXMgJ3NlbnQnLCBpdCBsb29rcyBmb3IgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgYmVpbmcgJ3JlY2VpdmVkJywgYW5kIGdlbmVyYXRlcyBhIHRyYW5zaXRpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSBlbGVtZW50IHRvIGl0cyBjb3VudGVycGFydCdzIHBvc2l0aW9uIGFuZCBmYWRlcyBpdCBvdXQuIFdoZW4gYW4gZWxlbWVudCBpcyAncmVjZWl2ZWQnLCB0aGUgcmV2ZXJzZSBoYXBwZW5zLiBJZiB0aGVyZSBpcyBubyBjb3VudGVycGFydCwgdGhlIGBmYWxsYmFja2AgdHJhbnNpdGlvbiBpcyB1c2VkLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS10cmFuc2l0aW9uI2Nyb3NzZmFkZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljJykuQ3Jvc3NmYWRlUGFyYW1zICYge1xuICogXHRmYWxsYmFjaz86IChub2RlOiBFbGVtZW50LCBwYXJhbXM6IGltcG9ydCgnLi9wdWJsaWMnKS5Dcm9zc2ZhZGVQYXJhbXMsIGludHJvOiBib29sZWFuKSA9PiBpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZztcbiAqIH19IHBhcmFtc1xuICogQHJldHVybnMge1sobm9kZTogYW55LCBwYXJhbXM6IGltcG9ydCgnLi9wdWJsaWMnKS5Dcm9zc2ZhZGVQYXJhbXMgJiB7IGtleTogYW55OyB9KSA9PiAoKSA9PiBpbXBvcnQoJy4vcHVibGljJykuVHJhbnNpdGlvbkNvbmZpZywgKG5vZGU6IGFueSwgcGFyYW1zOiBpbXBvcnQoJy4vcHVibGljJykuQ3Jvc3NmYWRlUGFyYW1zICYgeyBrZXk6IGFueTsgfSkgPT4gKCkgPT4gaW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWddfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3NmYWRlKHsgZmFsbGJhY2ssIC4uLmRlZmF1bHRzIH0pIHtcblx0LyoqIEB0eXBlIHtNYXA8YW55LCBFbGVtZW50Pn0gKi9cblx0Y29uc3QgdG9fcmVjZWl2ZSA9IG5ldyBNYXAoKTtcblx0LyoqIEB0eXBlIHtNYXA8YW55LCBFbGVtZW50Pn0gKi9cblx0Y29uc3QgdG9fc2VuZCA9IG5ldyBNYXAoKTtcblx0LyoqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbV9ub2RlXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMnKS5Dcm9zc2ZhZGVQYXJhbXN9IHBhcmFtc1xuXHQgKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYycpLlRyYW5zaXRpb25Db25maWd9XG5cdCAqL1xuXHRmdW5jdGlvbiBjcm9zc2ZhZGUoZnJvbV9ub2RlLCBub2RlLCBwYXJhbXMpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IChkKSA9PiBNYXRoLnNxcnQoZCkgKiAzMCxcblx0XHRcdGVhc2luZyA9IGN1YmljT3V0XG5cdFx0fSA9IGFzc2lnbihhc3NpZ24oe30sIGRlZmF1bHRzKSwgcGFyYW1zKTtcblx0XHRjb25zdCBmcm9tID0gZnJvbV9ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCBkeCA9IGZyb20ubGVmdCAtIHRvLmxlZnQ7XG5cdFx0Y29uc3QgZHkgPSBmcm9tLnRvcCAtIHRvLnRvcDtcblx0XHRjb25zdCBkdyA9IGZyb20ud2lkdGggLyB0by53aWR0aDtcblx0XHRjb25zdCBkaCA9IGZyb20uaGVpZ2h0IC8gdG8uaGVpZ2h0O1xuXHRcdGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHRcdGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVsYXksXG5cdFx0XHRkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcblx0XHRcdGVhc2luZyxcblx0XHRcdGNzczogKHQsIHUpID0+IGBcblx0XHRcdFx0b3BhY2l0eTogJHt0ICogb3BhY2l0eX07XG5cdFx0XHRcdHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuXHRcdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt1ICogZHh9cHgsJHt1ICogZHl9cHgpIHNjYWxlKCR7dCArICgxIC0gdCkgKiBkd30sICR7XG5cdFx0XHRcdHQgKyAoMSAtIHQpICogZGhcblx0XHRcdH0pO1xuXHRcdFx0YFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNYXA8YW55LCBFbGVtZW50Pn0gaXRlbXNcblx0ICogQHBhcmFtIHtNYXA8YW55LCBFbGVtZW50Pn0gY291bnRlcnBhcnRzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50cm9cblx0ICogQHJldHVybnMgeyhub2RlOiBhbnksIHBhcmFtczogaW1wb3J0KCcuL3B1YmxpYycpLkNyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IGltcG9ydCgnLi9wdWJsaWMnKS5UcmFuc2l0aW9uQ29uZmlnfVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJhbnNpdGlvbihpdGVtcywgY291bnRlcnBhcnRzLCBpbnRybykge1xuXHRcdHJldHVybiAobm9kZSwgcGFyYW1zKSA9PiB7XG5cdFx0XHRpdGVtcy5zZXQocGFyYW1zLmtleSwgbm9kZSk7XG5cdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRpZiAoY291bnRlcnBhcnRzLmhhcyhwYXJhbXMua2V5KSkge1xuXHRcdFx0XHRcdGNvbnN0IG90aGVyX25vZGUgPSBjb3VudGVycGFydHMuZ2V0KHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRcdGNvdW50ZXJwYXJ0cy5kZWxldGUocGFyYW1zLmtleSk7XG5cdFx0XHRcdFx0cmV0dXJuIGNyb3NzZmFkZShvdGhlcl9ub2RlLCBub2RlLCBwYXJhbXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBub2RlIGlzIGRpc2FwcGVhcmluZyBhbHRvZ2V0aGVyXG5cdFx0XHRcdC8vIChpLmUuIHdhc24ndCBjbGFpbWVkIGJ5IHRoZSBvdGhlciBsaXN0KVxuXHRcdFx0XHQvLyB0aGVuIHdlIG5lZWQgdG8gc3VwcGx5IGFuIG91dHJvXG5cdFx0XHRcdGl0ZW1zLmRlbGV0ZShwYXJhbXMua2V5KTtcblx0XHRcdFx0cmV0dXJuIGZhbGxiYWNrICYmIGZhbGxiYWNrKG5vZGUsIHBhcmFtcywgaW50cm8pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdHJldHVybiBbdHJhbnNpdGlvbih0b19zZW5kLCB0b19yZWNlaXZlLCBmYWxzZSksIHRyYW5zaXRpb24odG9fcmVjZWl2ZSwgdG9fc2VuZCwgdHJ1ZSldO1xufVxuIl0sIm5hbWVzIjpbImN1YmljT3V0IiwiY3ViaWNJbk91dCIsImxpbmVhciIsImFzc2lnbiIsInNwbGl0X2Nzc191bml0IiwiaXNfZnVuY3Rpb24iLCJibHVyIiwibm9kZSIsImRlbGF5IiwiZHVyYXRpb24iLCJlYXNpbmciLCJhbW91bnQiLCJvcGFjaXR5Iiwic3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwidGFyZ2V0X29wYWNpdHkiLCJmIiwiZmlsdGVyIiwib2QiLCJ2YWx1ZSIsInVuaXQiLCJjc3MiLCJfdCIsInUiLCJmYWRlIiwibyIsInQiLCJmbHkiLCJ4IiwieSIsInRyYW5zZm9ybSIsInhWYWx1ZSIsInhVbml0IiwieVZhbHVlIiwieVVuaXQiLCJzbGlkZSIsImF4aXMiLCJwcmltYXJ5X3Byb3BlcnR5IiwicHJpbWFyeV9wcm9wZXJ0eV92YWx1ZSIsInBhcnNlRmxvYXQiLCJzZWNvbmRhcnlfcHJvcGVydGllcyIsImNhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzIiwibWFwIiwiZSIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJwYWRkaW5nX3N0YXJ0X3ZhbHVlIiwicGFkZGluZ19lbmRfdmFsdWUiLCJtYXJnaW5fc3RhcnRfdmFsdWUiLCJtYXJnaW5fZW5kX3ZhbHVlIiwiYm9yZGVyX3dpZHRoX3N0YXJ0X3ZhbHVlIiwiYm9yZGVyX3dpZHRoX2VuZF92YWx1ZSIsIk1hdGgiLCJtaW4iLCJzY2FsZSIsInN0YXJ0Iiwic2QiLCJkcmF3Iiwic3BlZWQiLCJsZW4iLCJnZXRUb3RhbExlbmd0aCIsInN0cm9rZUxpbmVjYXAiLCJwYXJzZUludCIsInN0cm9rZVdpZHRoIiwidW5kZWZpbmVkIiwiXyIsImNyb3NzZmFkZSIsImZhbGxiYWNrIiwiZGVmYXVsdHMiLCJ0b19yZWNlaXZlIiwiTWFwIiwidG9fc2VuZCIsImZyb21fbm9kZSIsInBhcmFtcyIsImQiLCJzcXJ0IiwiZnJvbSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJkdyIsIndpZHRoIiwiZGgiLCJoZWlnaHQiLCJ0cmFuc2l0aW9uIiwiaXRlbXMiLCJjb3VudGVycGFydHMiLCJpbnRybyIsInNldCIsImtleSIsImhhcyIsIm90aGVyX25vZGUiLCJnZXQiLCJkZWxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///56\n")}}]);